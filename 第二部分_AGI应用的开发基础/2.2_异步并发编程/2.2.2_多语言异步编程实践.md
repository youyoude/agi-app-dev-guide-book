# 2.2.2 多语言异步编程实践

## 学习目标

熟练运用Java、Python、TypeScript等语言的异步编程机制，实现AI应用的高效并发处理。

## 2.2.2.1 Java异步编程：Enterprise级并发处理

### 线程池与任务调度

Java在企业级AI应用中提供了丰富的并发编程工具。基于JD Genie项目的实践，我们可以看到ThreadPoolExecutor的专业化应用：

```java
// ThreadUtil.java - 生产级线程池管理
public class ThreadUtil {
    private static ThreadPoolExecutor executor = null;

    public static synchronized void initPool(int poolSize) {
        if (executor == null) {
            ThreadFactory threadFactory = (new BasicThreadFactory.Builder())
                .namingPattern("exe-pool-%d")
                .daemon(true)
                .build();
            
            // 自定义拒绝策略：避免任务丢失
            RejectedExecutionHandler handler = (r, executor) -> {
                // 日志记录被拒绝的任务
                logger.warn("Task rejected: {}", r.toString());
            };
            
            int maxPoolSize = Math.max(poolSize, 1000);
            executor = new ThreadPoolExecutor(
                poolSize,                    // 核心线程数
                maxPoolSize,                 // 最大线程数  
                60000L, TimeUnit.MILLISECONDS, // 空闲线程存活时间
                new SynchronousQueue<>(),    // 工作队列
                threadFactory,               // 线程工厂
                handler                      // 拒绝策略
            );
        }
    }

    public static void execute(Runnable runnable) {
        if (executor == null) {
            initPool(100);
        }
        executor.execute(runnable);
    }

    public static CountDownLatch getCountDownLatch(int count) {
        return new CountDownLatch(count);
    }

    public static void await(CountDownLatch latch) {
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Thread interrupted while waiting", e);
        }
    }
}
```

### CountDownLatch在AI工具并发执行中的应用

```java
// BaseAgent.java - AI工具的并发执行框架
public class BaseAgent {
    /**
     * 并发执行多个工具调用命令并返回执行结果
     */
    public Map<String, String> executeTools(List<ToolCall> commands) {
        Map<String, String> result = new ConcurrentHashMap<>();
        CountDownLatch taskCount = ThreadUtil.getCountDownLatch(commands.size());
        
        for (ToolCall toolCall : commands) {
            ThreadUtil.execute(() -> {
                try {
                    long startTime = System.currentTimeMillis();
                    String toolResult = executeTool(toolCall);
                    long duration = System.currentTimeMillis() - startTime;
                    
                    result.put(toolCall.getId(), toolResult);
                    logger.info("Tool {} completed in {}ms", 
                               toolCall.getFunction().getName(), duration);
                } catch (Exception e) {
                    logger.error("Tool execution failed: {}", toolCall.getId(), e);
                    result.put(toolCall.getId(), "Error: " + e.getMessage());
                } finally {
                    taskCount.countDown();
                }
            });
        }
        
        ThreadUtil.await(taskCount);
        return result;
    }
    
    private String executeTool(ToolCall toolCall) {
        // 工具执行逻辑
        String toolName = toolCall.getFunction().getName();
        Map<String, Object> arguments = toolCall.getFunction().getArguments();
        
        // 根据工具名称分发到具体的工具实现
        return agentContext.getToolCollection().executeTool(toolName, arguments);
    }
}
```

### CompletableFuture在复杂AI流程中的应用

```java
// 高级异步编程示例：AI处理流水线
public class AIProcessingPipeline {
    
    public CompletableFuture<AIResult> processComplexQuery(String query) {
        return CompletableFuture
            // 阶段1：预处理查询
            .supplyAsync(() -> preprocessQuery(query))
            // 阶段2：并行执行多个AI任务
            .thenComposeAsync(this::executeParallelTasks)
            // 阶段3：聚合结果
            .thenApplyAsync(this::aggregateResults)
            // 错误处理
            .exceptionally(throwable -> {
                logger.error("AI processing failed", throwable);
                return AIResult.error("Processing failed: " + throwable.getMessage());
            });
    }
    
    private CompletableFuture<AIResult> executeParallelTasks(String preprocessedQuery) {
        // 创建多个并行任务
        CompletableFuture<String> textAnalysis = 
            CompletableFuture.supplyAsync(() -> analyzeText(preprocessedQuery));
        CompletableFuture<String> sentimentAnalysis = 
            CompletableFuture.supplyAsync(() -> analyzeSentiment(preprocessedQuery));
        CompletableFuture<String> entityExtraction = 
            CompletableFuture.supplyAsync(() -> extractEntities(preprocessedQuery));
        
        // 等待所有任务完成
        return CompletableFuture.allOf(textAnalysis, sentimentAnalysis, entityExtraction)
            .thenApply(v -> new AIResult(
                textAnalysis.join(),
                sentimentAnalysis.join(), 
                entityExtraction.join()
            ));
    }
}
```

### 多Agent并行执行与状态同步

```java
// PlanSolveHandlerImpl.java - 多Agent协同工作
public class PlanSolveHandlerImpl {
    
    public String handleMultiAgentTasks(List<String> tasks, ExecutorAgent mainExecutor) {
        if (tasks.size() == 1) {
            return mainExecutor.run(tasks.get(0));
        }
        
        Map<String, String> taskResults = new ConcurrentHashMap<>();
        CountDownLatch taskCount = ThreadUtil.getCountDownLatch(tasks.size());
        int memoryIndex = mainExecutor.getMemory().size();
        List<ExecutorAgent> slaveExecutors = new ArrayList<>();
        
        for (String task : tasks) {
            ExecutorAgent slaveExecutor = new ExecutorAgent(agentContext);
            // 状态同步：复制主Agent的状态和记忆
            slaveExecutor.setState(mainExecutor.getState());
            slaveExecutor.getMemory().addMessages(mainExecutor.getMemory().getMessages());
            slaveExecutors.add(slaveExecutor);
            
            ThreadUtil.execute(() -> {
                try {
                    String taskResult = slaveExecutor.run(task);
                    taskResults.put(task, taskResult);
                } catch (Exception e) {
                    logger.error("Slave agent task failed: {}", task, e);
                    taskResults.put(task, "Error: " + e.getMessage());
                } finally {
                    taskCount.countDown();
                }
            });
        }
        
        ThreadUtil.await(taskCount);
        
        // 结果聚合：将从Agent的记忆合并回主Agent
        for (ExecutorAgent slaveExecutor : slaveExecutors) {
            for (int i = memoryIndex; i < slaveExecutor.getMemory().size(); i++) {
                mainExecutor.getMemory().addMessage(slaveExecutor.getMemory().get(i));
            }
            slaveExecutor.getMemory().clear();
            mainExecutor.setState(slaveExecutor.getState());
        }
        
        return String.join("\n", taskResults.values());
    }
}
```

## 2.2.2.2 Python异步编程：协程驱动的AI处理

### AsyncIO与异步生成器

Python的asyncio库为AI应用提供了强大的异步处理能力。基于Genie Tool项目的实现：

```python
# deepsearch.py - 深度搜索的异步实现
import asyncio
from typing import AsyncGenerator, List, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

class DeepSearch:
    """深度搜索工具"""
    
    @timer()
    async def run(
        self,
        query: str,
        request_id: str = None,
        max_loop: int = 1,
        stream: bool = False,
        stream_mode: StreamMode = StreamMode(),
        *args,
        **kwargs
    ) -> AsyncGenerator[str, None]:
        """异步流式搜索处理"""
        
        try:
            # 查询分解
            queries = await query_decompose(query, request_id=request_id)
            logger.info(f"Decomposed queries: {queries}")
            
            # 并行搜索
            docs, search_results = await self._search_queries_and_dedup(queries, request_id)
            
            # 流式答案生成
            acc_content = ""
            async for chunk in answer_question(
                query=query, 
                docs=docs, 
                request_id=request_id,
                stream=stream
            ):
                if stream and chunk:
                    acc_content += chunk
                    yield json.dumps({
                        "requestId": request_id,
                        "query": query,
                        "searchResult": {"query": queries, "docs": [doc.dict() for doc in docs]},
                        "answer": chunk,
                        "isFinal": False,
                        "messageType": "search"
                    }, ensure_ascii=False)
                else:
                    acc_content += chunk
                    
        except Exception as e:
            logger.error(f"DeepSearch error: {e}")
            yield json.dumps({
                "requestId": request_id,
                "query": query,
                "error": str(e),
                "isFinal": True,
                "messageType": "error"
            }, ensure_ascii=False)
```

### 线程池与协程的混合使用

在处理CPU密集型任务时，Python需要结合线程池和协程：

```python
async def _search_queries_and_dedup(
    self, 
    queries: List[str], 
    request_id: str
) -> Tuple[List[Doc], List[List[Doc]]]:
    """异步并行搜索多个查询并去重"""
    
    def _run_async(*args, **kwargs):
        """在新的事件循环中运行异步任务"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(self._search_single_query(*args, **kwargs))
            return result
        finally:
            loop.close()

    process_list = []
    max_workers = int(os.getenv("SEARCH_THREAD_NUM", 5))
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        for query in queries:
            process = executor.submit(_run_async, query, request_id)
            process_list.append(process)
    
    # 收集所有结果
    results = [process.result() for process in as_completed(process_list)]
    all_docs = [doc for docs in results for doc in docs]
    
    # 去重处理
    seen_content = set()
    deduped_docs = []
    for doc in all_docs:
        if doc.content and doc.content not in seen_content:
            deduped_docs.append(doc)
            seen_content.add(doc.content)
    
    return deduped_docs, results
```

### 代码解释器的异步流式处理

```python
# code_interpreter.py - 异步代码执行与流式输出
async def code_interpreter_agent(
    task: str,
    file_names: Optional[List[str]] = None,
    max_file_abstract_size: int = 2000,
    max_tokens: int = 32000,
    request_id: str = "",
    stream: bool = True,
):
    work_dir = ""
    try:
        work_dir = tempfile.mkdtemp()
        output_dir = os.path.join(work_dir, "output")
        os.makedirs(output_dir, exist_ok=True)
        
        # 异步文件下载
        import_files = await download_all_files_in_path(
            file_names=file_names, 
            work_dir=work_dir
        )

        # 文件预处理（并发处理多个文件）
        files = []
        if import_files:
            file_tasks = []
            for import_file in import_files:
                file_tasks.append(process_single_file(import_file, max_file_abstract_size))
            
            files = await asyncio.gather(*file_tasks)

        # 创建AI代理
        agent = create_ci_agent(
            prompt_templates=get_prompt("code_interpreter"),
            max_tokens=max_tokens,
            return_full_result=True,
            output_dir=output_dir,
        )

        template_task = Template(ci_prompt_template["task_template"]).render(
            files=files, task=task, output_dir=output_dir
        )

        if stream:
            # 流式处理：实时返回执行结果
            for step in agent.run(task=str(template_task), stream=True, max_steps=10):
                if isinstance(step, CodeOuput):
                    file_info = await upload_file(
                        content=step.code,
                        file_name=step.file_name,
                        file_type="py",
                        request_id=request_id,
                    )
                    step.file_list = [file_info]
                    yield step
                
                elif isinstance(step, FinalAnswerStep):
                    # 处理最终输出文件
                    file_list = []
                    file_path = get_new_file_by_path(output_dir=output_dir)
                    if file_path:
                        file_info = await upload_file_by_path(
                            file_path=file_path, 
                            request_id=request_id
                        )
                        if file_info:
                            file_list.append(file_info)
                    
                    output = ActionOutput(content=step.output, file_list=file_list)
                    yield output
                
                # 控制流式输出频率
                await asyncio.sleep(0)
                
    except Exception as e:
        raise e
    finally:
        # 清理临时文件
        if work_dir:
            shutil.rmtree(work_dir, ignore_errors=True)

async def process_single_file(import_file, max_abstract_size):
    """异步处理单个文件"""
    file_name = import_file["file_name"]
    file_path = import_file["file_path"]
    
    if not file_name or not file_path:
        return None

    # 根据文件类型选择处理策略
    if file_name.split(".")[-1] in ["xlsx", "xls", "csv"]:
        # 异步读取表格文件
        loop = asyncio.get_event_loop()
        df = await loop.run_in_executor(None, lambda: 
            pd.read_csv(file_path) if file_name.endswith(".csv") 
            else pd.read_excel(file_path)
        )
        return {"path": file_path, "abstract": f"{df.head(10)}"}
    
    elif file_name.split(".")[-1] in ["txt", "md", "html"]:
        # 异步读取文本文件
        async with aiofiles.open(file_path, "r") as rf:
            content = await rf.read()
            return {
                "path": file_path,
                "abstract": content[:max_abstract_size]
            }
    
    return None
```

### 多搜索引擎的异步聚合

```python
# search_engine.py - 多引擎并行搜索
class MixSearch:
    def __init__(self):
        self._engine = "mix_search"
        self._bing_engine = BingSearch()
        self._jina_engine = JinaSearch()
        self._sogou_engine = SogouSearch()
        self._serp_engine = SerperSearch()

    async def search(
        self, 
        query: str, 
        request_id: str = None,
        use_bing: bool = True, 
        use_jina: bool = True, 
        use_sogou: bool = True,
        use_serp: bool = True, 
        *args, 
        **kwargs
    ) -> List[Doc]:
        """并行调用多个搜索引擎"""
        
        assert use_bing or use_jina or use_sogou or use_serp
        engines = []
        
        if use_bing:
            engines.append(self._bing_engine)
        if use_jina:
            engines.append(self._jina_engine)
        if use_sogou:
            engines.append(self._sogou_engine)
        if use_serp:
            engines.append(self._serp_engine)
        
        # 使用TaskGroup进行并发执行
        async with asyncio.TaskGroup() as tg:
            tasks = [
                tg.create_task(engine.search_and_dedup(query=query, request_id=request_id)) 
                for engine in engines
            ]
        
        # 聚合所有搜索结果
        results = [task.result() for task in tasks]
        return [doc for docs in results for doc in docs]
```

## 2.2.2.3 TypeScript异步编程：现代前端AI交互

### 基于Promise的异步处理

TypeScript在AI应用前端提供了优雅的异步编程体验：

```typescript
// querySSE.ts - SSE流式通信的封装
interface SSEConfig {
  body: any;
  handleMessage: (data: any) => void;
  handleError: (error: Error) => void;
  handleClose: () => void;
}

export default (config: SSEConfig, url: string = DEFAULT_SSE_URL): void => {
  const { body = null, handleMessage, handleError, handleClose } = config;

  fetchEventSource(url, {
    method: 'POST',
    credentials: 'include',
    headers: SSE_HEADERS,
    body: JSON.stringify(body),
    openWhenHidden: true,
    
    onmessage(event: EventSourceMessage) {
      if (event.data) {
        try {
          const parsedData = JSON.parse(event.data);
          handleMessage(parsedData);
        } catch (error) {
          console.error('Error parsing SSE message:', error);
          handleError(new Error('Failed to parse SSE message'));
        }
      }
    },
    
    onerror(error: Error) {
      console.error('SSE error:', error);
      handleError(error);
    },
    
    onclose() {
      console.log('SSE connection closed');
      handleClose();
    }
  });
};
```

### 响应式异步状态管理

```typescript
// 使用React Hooks管理异步AI交互状态
import { useState, useCallback, useEffect } from 'react';

interface AIStreamState {
  isLoading: boolean;
  messages: Message[];
  error: string | null;
  isConnected: boolean;
}

export const useAIStream = () => {
  const [state, setState] = useState<AIStreamState>({
    isLoading: false,
    messages: [],
    error: null,
    isConnected: false
  });

  const sendMessage = useCallback(async (query: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    const config: SSEConfig = {
      body: { query, agentType: 'react' },
      
      handleMessage: (data) => {
        setState(prev => ({
          ...prev,
          messages: [...prev.messages, data],
          isConnected: true
        }));
      },
      
      handleError: (error) => {
        setState(prev => ({
          ...prev,
          error: error.message,
          isLoading: false,
          isConnected: false
        }));
      },
      
      handleClose: () => {
        setState(prev => ({
          ...prev,
          isLoading: false,
          isConnected: false
        }));
      }
    };

    querySSE(config);
  }, []);

  return {
    ...state,
    sendMessage
  };
};
```

### 并发API调用与数据聚合

```typescript
// 多服务并发调用的最佳实践
interface AIService {
  name: string;
  endpoint: string;
  timeout: number;
}

class AIServiceOrchestrator {
  private services: AIService[];

  constructor(services: AIService[]) {
    this.services = services;
  }

  async processQuery(query: string): Promise<AIResult[]> {
    const requests = this.services.map(service => 
      this.callService(service, query)
    );

    // 使用Promise.allSettled处理并发请求
    const results = await Promise.allSettled(requests);
    
    return results.map((result, index) => ({
      serviceName: this.services[index].name,
      status: result.status,
      data: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason : null
    }));
  }

  private async callService(service: AIService, query: string): Promise<any> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), service.timeout);

    try {
      const response = await fetch(service.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query }),
        signal: controller.signal
      });

      if (!response.ok) {
        throw new Error(`Service ${service.name} returned ${response.status}`);
      }

      return await response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
}
```

## 2.2.2.4 跨语言异步通信模式

### 微服务间的异步协调

在多语言AI应用架构中，不同服务需要高效的异步通信：

```java
// Java服务 - AI控制器
@RestController
public class GenieController {
    
    @Autowired
    private AsyncAIServiceClient aiServiceClient;
    
    @PostMapping("/AutoAgent")
    public SseEmitter processAIRequest(@RequestBody AgentRequest request) {
        SseEmitter emitter = new SseEmitter(60 * 60 * 1000L);
        
        ThreadUtil.execute(() -> {
            try {
                // 异步调用Python AI服务
                CompletableFuture<String> pythonServiceFuture = 
                    aiServiceClient.callPythonService(request);
                
                // 异步调用其他微服务
                CompletableFuture<String> searchServiceFuture = 
                    aiServiceClient.callSearchService(request);
                
                // 等待所有服务响应
                CompletableFuture.allOf(pythonServiceFuture, searchServiceFuture)
                    .thenAccept(v -> {
                        String pythonResult = pythonServiceFuture.join();
                        String searchResult = searchServiceFuture.join();
                        
                        // 聚合结果并发送
                        String finalResult = aggregateResults(pythonResult, searchResult);
                        emitter.send(finalResult);
                        emitter.complete();
                    })
                    .exceptionally(throwable -> {
                        emitter.completeWithError(throwable);
                        return null;
                    });
                    
            } catch (Exception e) {
                emitter.completeWithError(e);
            }
        });
        
        return emitter;
    }
}
```

```python
# Python服务 - AI工具处理
from fastapi import FastAPI
from fastapi.responses import EventSourceResponse
import asyncio

app = FastAPI()

@app.post("/v1/tool/process")
async def process_ai_tool(request: AIToolRequest):
    """异步处理AI工具请求"""
    
    async def _stream():
        try:
            # 并行执行多个AI处理步骤
            tasks = [
                process_text_analysis(request.text),
                process_code_generation(request.task),
                process_data_analysis(request.data)
            ]
            
            # 流式返回处理结果
            async for result in asyncio.as_completed(tasks):
                processed_result = await result
                yield f"data: {json.dumps(processed_result)}\n\n"
                
        except Exception as e:
            yield f"data: {json.dumps({'error': str(e)})}\n\n"
    
    return EventSourceResponse(
        _stream(), 
        ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
        ping=15
    )

async def process_text_analysis(text: str) -> dict:
    """异步文本分析"""
    # 模拟AI处理
    await asyncio.sleep(2)
    return {"type": "text_analysis", "result": "Analysis complete"}

async def process_code_generation(task: str) -> dict:
    """异步代码生成"""
    await asyncio.sleep(3)
    return {"type": "code_generation", "result": "Code generated"}
```

## 2.2.2.5 异步编程最佳实践总结

### 1. 错误处理策略

```java
// Java - CompletableFuture错误处理
public CompletableFuture<AIResult> robustAIProcessing(String input) {
    return CompletableFuture
        .supplyAsync(() -> processInput(input))
        .thenCompose(this::callAIService)
        .thenApply(this::formatResult)
        .exceptionally(throwable -> {
            logger.error("AI processing failed", throwable);
            return AIResult.error("Processing failed");
        })
        .orTimeout(30, TimeUnit.SECONDS)
        .whenComplete((result, throwable) -> {
            if (throwable != null) {
                metrics.incrementErrorCount();
            }
        });
}
```

```python
# Python - 协程错误处理
async def safe_async_processing(data: str) -> dict:
    """安全的异步处理"""
    try:
        async with asyncio.timeout(30):  # 超时控制
            result = await process_data(data)
            return {"status": "success", "data": result}
    except asyncio.TimeoutError:
        logger.error("Processing timeout")
        return {"status": "timeout", "error": "Processing timed out"}
    except Exception as e:
        logger.error(f"Processing error: {e}")
        return {"status": "error", "error": str(e)}
```

### 2. 资源管理原则

```java
// 使用try-with-resources管理异步资源
public void processLargeDataset(List<DataChunk> chunks) {
    try (ExecutorService executor = Executors.newFixedThreadPool(10)) {
        List<CompletableFuture<ProcessResult>> futures = chunks.stream()
            .map(chunk -> CompletableFuture.supplyAsync(() -> 
                processChunk(chunk), executor))
            .collect(Collectors.toList());
        
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
    }
}
```

### 3. 性能监控集成

```python
# 异步任务性能监控
import time
from functools import wraps

def async_monitor(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"{func.__name__} completed in {duration:.2f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"{func.__name__} failed after {duration:.2f}s: {e}")
            raise
    return wrapper

@async_monitor
async def process_ai_request(request):
    # AI处理逻辑
    pass
```

## 小结

多语言异步编程是构建现代AI应用的核心技能。每种语言都有其独特的异步编程模型和最佳实践：

- **Java**：企业级的线程池管理和CompletableFuture组合
- **Python**：协程驱动的高并发处理和异步生成器
- **TypeScript**：Promise-based的响应式前端交互

掌握这些技术并合理组合使用，能够构建出高性能、高可用的AI应用系统。

---

**实践建议：**
1. 选择合适的异步模型匹配应用场景
2. 建立统一的错误处理和监控机制  
3. 注意跨语言服务间的异步协调
4. 持续优化异步任务的性能表现
