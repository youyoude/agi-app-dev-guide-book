# 2.2.4 AI-Agent的并发调度与协调

## 学习目标

构建高效的AI Agent并发调度系统，实现多Agent任务的并行执行与结果协调。

## 2.2.4.1 AI Agent并发架构设计

### Agent系统的并发需求

在复杂的AGI应用中，单个Agent往往无法高效处理所有任务。多Agent并发架构具有以下优势：

1. **任务分解并行化**：将复杂任务拆分为多个子任务并行执行
2. **专业化处理**：不同Agent专注于特定领域的任务
3. **负载均衡**：避免单点性能瓶颈
4. **容错能力**：单个Agent失败不影响整体系统

### Agent并发模式分类

基于JD Genie项目的实际应用，我们可以识别出几种典型的Agent并发模式：

```java
// Agent并发模式枚举
public enum AgentConcurrencyPattern {
    PIPELINE,           // 流水线模式：Agent按顺序处理
    PARALLEL,           // 并行模式：Agent同时处理不同任务  
    MASTER_SLAVE,       // 主从模式：主Agent协调多个从Agent
    PEER_TO_PEER,       // 对等模式：Agent间直接协作
    COMPETITION         // 竞争模式：多个Agent处理同一任务，选最佳结果
}
```

## 2.2.4.2 主从模式的Agent协调

### PlanSolve架构实现

JD Genie项目中的PlanSolveHandlerImpl展示了经典的主从Agent协调模式：

```java
// PlanSolveHandlerImpl.java - 主从Agent协调实现
public class PlanSolveHandlerImpl implements AgentHandlerService {
    
    @Override
    public void handle(AgentContext agentContext, AgentRequest request) {
        PlanningAgent planning = new PlanningAgent(agentContext);
        ExecutorAgent executor = new ExecutorAgent(agentContext);
        SummaryAgent summary = new SummaryAgent(agentContext);
        
        String planningResult = planning.run(agentContext.getQuery());
        
        while (!"finish".equals(planningResult)) {
            // 解析规划结果
            List<String> planningResults = parsePlanningResult(planningResult);
            agentContext.getTaskProductFiles().clear();
            
            String executorResult;
            if (planningResults.size() == 1) {
                // 单任务直接执行
                executorResult = executor.run(planningResults.get(0));
            } else {
                // 多任务并行执行
                executorResult = executeParallelTasks(planningResults, executor, agentContext);
            }
            
            // 继续规划
            planningResult = planning.run(executorResult);
            
            if ("finish".equals(planningResult)) {
                // 任务完成，生成总结
                String summaryResult = summary.run("");
                agentContext.getPrinter().send("result", summaryResult);
                break;
            }
        }
    }
    
    /**
     * 并行执行多个Agent任务
     */
    private String executeParallelTasks(List<String> tasks, ExecutorAgent mainExecutor, 
                                       AgentContext agentContext) {
        Map<String, String> taskResults = new ConcurrentHashMap<>();
        CountDownLatch taskCount = ThreadUtil.getCountDownLatch(tasks.size());
        int memoryIndex = mainExecutor.getMemory().size();
        List<ExecutorAgent> slaveExecutors = new ArrayList<>();
        
        for (String task : tasks) {
            // 创建从Agent并复制主Agent状态
            ExecutorAgent slaveExecutor = createSlaveAgent(mainExecutor, agentContext);
            slaveExecutors.add(slaveExecutor);
            
            ThreadUtil.execute(() -> {
                try {
                    long startTime = System.currentTimeMillis();
                    String taskResult = slaveExecutor.run(task);
                    long duration = System.currentTimeMillis() - startTime;
                    
                    taskResults.put(task, taskResult);
                    logger.info("Slave agent completed task '{}' in {}ms", 
                               task.substring(0, Math.min(50, task.length())), duration);
                } catch (Exception e) {
                    logger.error("Slave agent task failed: {}", task, e);
                    taskResults.put(task, "Error: " + e.getMessage());
                } finally {
                    taskCount.countDown();
                }
            });
        }
        
        // 等待所有从Agent完成
        ThreadUtil.await(taskCount);
        
        // 状态合并：将从Agent的执行结果和状态合并回主Agent
        mergeSlaveResults(mainExecutor, slaveExecutors, memoryIndex);
        
        return String.join("\n", taskResults.values());
    }
    
    /**
     * 创建从Agent并复制主Agent状态
     */
    private ExecutorAgent createSlaveAgent(ExecutorAgent mainExecutor, AgentContext agentContext) {
        ExecutorAgent slaveExecutor = new ExecutorAgent(agentContext);
        
        // 状态同步
        slaveExecutor.setState(mainExecutor.getState());
        
        // 记忆同步：深拷贝主Agent的记忆
        slaveExecutor.getMemory().addMessages(mainExecutor.getMemory().getMessages());
        
        return slaveExecutor;
    }
    
    /**
     * 合并从Agent的执行结果
     */
    private void mergeSlaveResults(ExecutorAgent mainExecutor, List<ExecutorAgent> slaveExecutors, 
                                  int memoryIndex) {
        for (ExecutorAgent slaveExecutor : slaveExecutors) {
            // 合并记忆：将从Agent的新记忆添加到主Agent
            for (int i = memoryIndex; i < slaveExecutor.getMemory().size(); i++) {
                mainExecutor.getMemory().addMessage(slaveExecutor.getMemory().get(i));
            }
            
            // 清理从Agent记忆，释放内存
            slaveExecutor.getMemory().clear();
            
            // 合并状态：通常使用最后一个从Agent的状态
            mainExecutor.setState(slaveExecutor.getState());
        }
    }
}
```

### Agent状态同步机制

```java
// AgentState.java - Agent状态管理
public class AgentStateManager {
    
    private final ReadWriteLock stateLock = new ReentrantReadWriteLock();
    private volatile AgentState currentState;
    private final Map<String, Object> sharedContext = new ConcurrentHashMap<>();
    
    /**
     * 线程安全的状态更新
     */
    public void updateState(AgentState newState) {
        stateLock.writeLock().lock();
        try {
            this.currentState = newState;
            notifyStateChange(newState);
        } finally {
            stateLock.writeLock().unlock();
        }
    }
    
    /**
     * 线程安全的状态读取
     */
    public AgentState getCurrentState() {
        stateLock.readLock().lock();
        try {
            return this.currentState;
        } finally {
            stateLock.readLock().unlock();
        }
    }
    
    /**
     * 共享上下文管理
     */
    public void putSharedData(String key, Object value) {
        sharedContext.put(key, value);
    }
    
    public Object getSharedData(String key) {
        return sharedContext.get(key);
    }
    
    /**
     * 状态变更通知
     */
    private void notifyStateChange(AgentState newState) {
        // 通知其他关注状态变化的组件
        logger.debug("Agent state changed to: {}", newState);
    }
}
```

## 2.2.4.3 Agent工具的并发执行

### 并发工具调用框架

```java
// BaseAgent.java - 工具并发执行框架
public class BaseAgent {
    
    private final ExecutorService toolExecutor;
    private final int maxConcurrentTools;
    
    public BaseAgent(AgentContext context) {
        this.maxConcurrentTools = context.getMaxConcurrentTools();
        this.toolExecutor = Executors.newFixedThreadPool(maxConcurrentTools);
    }
    
    /**
     * 并发执行多个工具调用
     */
    public Map<String, String> executeTools(List<ToolCall> commands) {
        if (commands.isEmpty()) {
            return new HashMap<>();
        }
        
        Map<String, String> results = new ConcurrentHashMap<>();
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        // 创建并发执行任务
        for (ToolCall toolCall : commands) {
            CompletableFuture<Void> future = CompletableFuture
                .supplyAsync(() -> executeToolSafely(toolCall), toolExecutor)
                .thenAccept(result -> results.put(toolCall.getId(), result))
                .exceptionally(throwable -> {
                    logger.error("Tool execution failed: {}", toolCall.getId(), throwable);
                    results.put(toolCall.getId(), "Error: " + throwable.getMessage());
                    return null;
                });
            futures.add(future);
        }
        
        // 等待所有工具执行完成
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        );
        
        try {
            // 设置超时时间
            allFutures.get(300, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            logger.error("Tool execution timeout after 300 seconds");
            // 取消未完成的任务
            futures.forEach(future -> future.cancel(true));
        } catch (Exception e) {
            logger.error("Tool execution error", e);
        }
        
        return results;
    }
    
    /**
     * 安全执行单个工具
     */
    private String executeToolSafely(ToolCall toolCall) {
        try {
            String toolName = toolCall.getFunction().getName();
            Map<String, Object> arguments = toolCall.getFunction().getArguments();
            
            long startTime = System.currentTimeMillis();
            String result = agentContext.getToolCollection().executeTool(toolName, arguments);
            long duration = System.currentTimeMillis() - startTime;
            
            logger.info("Tool {} executed successfully in {}ms", toolName, duration);
            return result;
            
        } catch (Exception e) {
            logger.error("Tool execution failed: {}", toolCall.getId(), e);
            return "Error: " + e.getMessage();
        }
    }
    
    /**
     * 资源清理
     */
    public void shutdown() {
        toolExecutor.shutdown();
        try {
            if (!toolExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                toolExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            toolExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### 智能工具调度策略

```java
// ToolScheduler.java - 智能工具调度器
public class IntelligentToolScheduler {
    
    private final Map<String, Integer> toolPriorities = new HashMap<>();
    private final Map<String, Long> toolExecutionHistory = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler;
    
    public IntelligentToolScheduler() {
        this.scheduler = Executors.newScheduledThreadPool(5);
        initializeToolPriorities();
    }
    
    /**
     * 基于优先级和历史性能的工具调度
     */
    public CompletableFuture<Map<String, String>> scheduleTools(List<ToolCall> toolCalls) {
        // 按优先级和预估执行时间排序
        List<ToolCall> sortedTools = toolCalls.stream()
            .sorted((t1, t2) -> {
                int priority1 = getToolPriority(t1.getFunction().getName());
                int priority2 = getToolPriority(t2.getFunction().getName());
                
                if (priority1 != priority2) {
                    return Integer.compare(priority2, priority1); // 高优先级先执行
                }
                
                // 优先级相同时，按预估执行时间排序
                long estimatedTime1 = estimateExecutionTime(t1.getFunction().getName());
                long estimatedTime2 = estimateExecutionTime(t2.getFunction().getName());
                return Long.compare(estimatedTime1, estimatedTime2);
            })
            .collect(Collectors.toList());
        
        // 分批执行工具
        return executeBatched(sortedTools);
    }
    
    private CompletableFuture<Map<String, String>> executeBatched(List<ToolCall> tools) {
        Map<String, String> allResults = new ConcurrentHashMap<>();
        List<CompletableFuture<Void>> batchFutures = new ArrayList<>();
        
        int batchSize = 3; // 每批最多3个工具并发执行
        for (int i = 0; i < tools.size(); i += batchSize) {
            List<ToolCall> batch = tools.subList(i, Math.min(i + batchSize, tools.size()));
            
            CompletableFuture<Void> batchFuture = executeBatch(batch)
                .thenAccept(allResults::putAll);
            batchFutures.add(batchFuture);
        }
        
        return CompletableFuture.allOf(batchFutures.toArray(new CompletableFuture[0]))
            .thenApply(v -> allResults);
    }
    
    private CompletableFuture<Map<String, String>> executeBatch(List<ToolCall> batch) {
        Map<String, String> batchResults = new ConcurrentHashMap<>();
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (ToolCall toolCall : batch) {
            CompletableFuture<Void> future = CompletableFuture
                .supplyAsync(() -> executeWithMetrics(toolCall))
                .thenAccept(result -> batchResults.put(toolCall.getId(), result));
            futures.add(future);
        }
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> batchResults);
    }
    
    private String executeWithMetrics(ToolCall toolCall) {
        String toolName = toolCall.getFunction().getName();
        long startTime = System.currentTimeMillis();
        
        try {
            String result = executeTool(toolCall);
            long duration = System.currentTimeMillis() - startTime;
            
            // 更新执行历史
            toolExecutionHistory.put(toolName, duration);
            
            return result;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            toolExecutionHistory.put(toolName, duration);
            throw e;
        }
    }
    
    private long estimateExecutionTime(String toolName) {
        return toolExecutionHistory.getOrDefault(toolName, 5000L); // 默认5秒
    }
    
    private int getToolPriority(String toolName) {
        return toolPriorities.getOrDefault(toolName, 5); // 默认优先级5
    }
    
    private void initializeToolPriorities() {
        toolPriorities.put("search", 10);      // 搜索工具优先级最高
        toolPriorities.put("code", 8);         // 代码工具优先级高
        toolPriorities.put("file", 6);         // 文件工具优先级中等
        toolPriorities.put("report", 4);       // 报告工具优先级较低
    }
}
```

## 2.2.4.4 Agent间通信与协调

### 消息传递机制

```java
// AgentCommunicationHub.java - Agent通信中心
public class AgentCommunicationHub {
    
    private final Map<String, Agent> agents = new ConcurrentHashMap<>();
    private final BlockingQueue<AgentMessage> messageQueue = new LinkedBlockingQueue<>();
    private final ExecutorService messageProcessor = Executors.newSingleThreadExecutor();
    private final AtomicBoolean running = new AtomicBoolean(true);
    
    public AgentCommunicationHub() {
        startMessageProcessor();
    }
    
    /**
     * 注册Agent
     */
    public void registerAgent(String agentId, Agent agent) {
        agents.put(agentId, agent);
        logger.info("Agent registered: {}", agentId);
    }
    
    /**
     * 发送消息给指定Agent
     */
    public void sendMessage(String fromAgentId, String toAgentId, Object payload) {
        AgentMessage message = new AgentMessage(fromAgentId, toAgentId, payload, System.currentTimeMillis());
        
        try {
            messageQueue.offer(message, 1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Failed to send message from {} to {}", fromAgentId, toAgentId, e);
        }
    }
    
    /**
     * 广播消息给所有Agent
     */
    public void broadcastMessage(String fromAgentId, Object payload) {
        agents.keySet().forEach(agentId -> {
            if (!agentId.equals(fromAgentId)) {
                sendMessage(fromAgentId, agentId, payload);
            }
        });
    }
    
    /**
     * 启动消息处理器
     */
    private void startMessageProcessor() {
        messageProcessor.submit(() -> {
            while (running.get()) {
                try {
                    AgentMessage message = messageQueue.take();
                    processMessage(message);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    logger.error("Message processing error", e);
                }
            }
        });
    }
    
    /**
     * 处理单个消息
     */
    private void processMessage(AgentMessage message) {
        Agent targetAgent = agents.get(message.getToAgentId());
        if (targetAgent != null) {
            try {
                targetAgent.receiveMessage(message);
                logger.debug("Message delivered from {} to {}", 
                           message.getFromAgentId(), message.getToAgentId());
            } catch (Exception e) {
                logger.error("Failed to deliver message to agent {}", 
                           message.getToAgentId(), e);
            }
        } else {
            logger.warn("Target agent not found: {}", message.getToAgentId());
        }
    }
    
    /**
     * 关闭通信中心
     */
    public void shutdown() {
        running.set(false);
        messageProcessor.shutdown();
        try {
            if (!messageProcessor.awaitTermination(30, TimeUnit.SECONDS)) {
                messageProcessor.shutdownNow();
            }
        } catch (InterruptedException e) {
            messageProcessor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}

// AgentMessage.java - Agent消息类
public class AgentMessage {
    private final String fromAgentId;
    private final String toAgentId;
    private final Object payload;
    private final long timestamp;
    private final String messageId;
    
    public AgentMessage(String fromAgentId, String toAgentId, Object payload, long timestamp) {
        this.fromAgentId = fromAgentId;
        this.toAgentId = toAgentId;
        this.payload = payload;
        this.timestamp = timestamp;
        this.messageId = UUID.randomUUID().toString();
    }
    
    // getters...
}
```

### 分布式Agent协调

```python
# distributed_agent_coordinator.py - 分布式Agent协调器
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from enum import Enum

class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class DistributedTask:
    task_id: str
    agent_id: str
    payload: Dict[str, Any]
    priority: int = 5
    timeout: int = 300
    retry_count: int = 0
    max_retries: int = 3
    status: TaskStatus = TaskStatus.PENDING

class DistributedAgentCoordinator:
    """分布式Agent协调器"""
    
    def __init__(self):
        self.agents: Dict[str, 'AsyncAgent'] = {}
        self.task_queue = asyncio.Queue()
        self.running_tasks: Dict[str, DistributedTask] = {}
        self.completed_tasks: Dict[str, Any] = {}
        self.worker_semaphore = asyncio.Semaphore(10)  # 最多10个并发任务
        
    async def register_agent(self, agent_id: str, agent: 'AsyncAgent'):
        """注册异步Agent"""
        self.agents[agent_id] = agent
        logger.info(f"Agent {agent_id} registered")
        
    async def submit_task(self, task: DistributedTask) -> str:
        """提交任务"""
        await self.task_queue.put(task)
        self.running_tasks[task.task_id] = task
        return task.task_id
        
    async def start_coordinator(self):
        """启动协调器"""
        # 启动多个工作者协程
        workers = [
            asyncio.create_task(self._worker(f"worker-{i}"))
            for i in range(5)
        ]
        
        # 启动监控任务
        monitor_task = asyncio.create_task(self._monitor_tasks())
        
        await asyncio.gather(*workers, monitor_task)
        
    async def _worker(self, worker_id: str):
        """工作者协程"""
        while True:
            try:
                # 获取任务
                task = await self.task_queue.get()
                
                async with self.worker_semaphore:
                    await self._execute_task(task, worker_id)
                
                self.task_queue.task_done()
                
            except Exception as e:
                logger.error(f"Worker {worker_id} error: {e}")
                await asyncio.sleep(1)
                
    async def _execute_task(self, task: DistributedTask, worker_id: str):
        """执行单个任务"""
        try:
            task.status = TaskStatus.RUNNING
            logger.info(f"Worker {worker_id} executing task {task.task_id}")
            
            # 查找对应的Agent
            agent = self.agents.get(task.agent_id)
            if not agent:
                raise ValueError(f"Agent {task.agent_id} not found")
            
            # 执行任务（带超时）
            result = await asyncio.wait_for(
                agent.process_task(task.payload),
                timeout=task.timeout
            )
            
            # 任务完成
            task.status = TaskStatus.COMPLETED
            self.completed_tasks[task.task_id] = result
            del self.running_tasks[task.task_id]
            
            logger.info(f"Task {task.task_id} completed by worker {worker_id}")
            
        except asyncio.TimeoutError:
            logger.error(f"Task {task.task_id} timeout")
            await self._handle_task_failure(task, "Task timeout")
            
        except Exception as e:
            logger.error(f"Task {task.task_id} failed: {e}")
            await self._handle_task_failure(task, str(e))
            
    async def _handle_task_failure(self, task: DistributedTask, error: str):
        """处理任务失败"""
        task.retry_count += 1
        
        if task.retry_count <= task.max_retries:
            # 重试任务
            task.status = TaskStatus.PENDING
            await self.task_queue.put(task)
            logger.info(f"Retrying task {task.task_id}, attempt {task.retry_count}")
        else:
            # 任务最终失败
            task.status = TaskStatus.FAILED
            self.completed_tasks[task.task_id] = {"error": error}
            del self.running_tasks[task.task_id]
            logger.error(f"Task {task.task_id} finally failed: {error}")
            
    async def _monitor_tasks(self):
        """监控任务状态"""
        while True:
            try:
                running_count = len(self.running_tasks)
                completed_count = len(self.completed_tasks)
                
                logger.debug(f"Tasks - Running: {running_count}, Completed: {completed_count}")
                
                # 检查超时任务
                current_time = asyncio.get_event_loop().time()
                timeout_tasks = []
                
                for task in self.running_tasks.values():
                    if (current_time - task.timestamp) > task.timeout:
                        timeout_tasks.append(task)
                
                # 处理超时任务
                for task in timeout_tasks:
                    await self._handle_task_failure(task, "Monitor timeout")
                
                await asyncio.sleep(10)  # 每10秒监控一次
                
            except Exception as e:
                logger.error(f"Monitor error: {e}")
                await asyncio.sleep(5)

# 使用示例
class AsyncAgent:
    """异步Agent基类"""
    
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        
    async def process_task(self, payload: Dict[str, Any]) -> Any:
        """处理任务的抽象方法"""
        # 子类需要实现具体的处理逻辑
        await asyncio.sleep(1)  # 模拟处理时间
        return {"result": f"Processed by {self.agent_id}"}

# 协调器使用示例
async def main():
    coordinator = DistributedAgentCoordinator()
    
    # 注册Agent
    agent1 = AsyncAgent("text-processor")
    agent2 = AsyncAgent("image-processor")
    
    await coordinator.register_agent("text-processor", agent1)
    await coordinator.register_agent("image-processor", agent2)
    
    # 提交任务
    task1 = DistributedTask(
        task_id="task-1",
        agent_id="text-processor",
        payload={"text": "Hello world"},
        priority=10
    )
    
    await coordinator.submit_task(task1)
    
    # 启动协调器
    await coordinator.start_coordinator()
```

## 2.2.4.5 负载均衡与容错机制

### Agent负载均衡策略

```java
// AgentLoadBalancer.java - Agent负载均衡器
public class AgentLoadBalancer {
    
    private final Map<String, List<Agent>> agentPools = new ConcurrentHashMap<>();
    private final Map<String, AtomicInteger> roundRobinCounters = new ConcurrentHashMap<>();
    private final Map<Agent, AgentMetrics> agentMetrics = new ConcurrentHashMap<>();
    
    public enum BalancingStrategy {
        ROUND_ROBIN,      // 轮询
        LEAST_CONNECTIONS, // 最少连接
        WEIGHTED_RESPONSE_TIME, // 加权响应时间
        RANDOM           // 随机
    }
    
    /**
     * 注册Agent到指定类型的池中
     */
    public void registerAgent(String agentType, Agent agent) {
        agentPools.computeIfAbsent(agentType, k -> new ArrayList<>()).add(agent);
        agentMetrics.put(agent, new AgentMetrics());
        roundRobinCounters.putIfAbsent(agentType, new AtomicInteger(0));
    }
    
    /**
     * 根据策略选择最优Agent
     */
    public Agent selectAgent(String agentType, BalancingStrategy strategy) {
        List<Agent> agents = agentPools.get(agentType);
        if (agents == null || agents.isEmpty()) {
            throw new IllegalStateException("No agents available for type: " + agentType);
        }
        
        return switch (strategy) {
            case ROUND_ROBIN -> selectRoundRobin(agentType, agents);
            case LEAST_CONNECTIONS -> selectLeastConnections(agents);
            case WEIGHTED_RESPONSE_TIME -> selectByResponseTime(agents);
            case RANDOM -> selectRandom(agents);
        };
    }
    
    private Agent selectRoundRobin(String agentType, List<Agent> agents) {
        int index = roundRobinCounters.get(agentType).getAndIncrement() % agents.size();
        return agents.get(index);
    }
    
    private Agent selectLeastConnections(List<Agent> agents) {
        return agents.stream()
            .min(Comparator.comparing(agent -> agentMetrics.get(agent).getActiveConnections()))
            .orElse(agents.get(0));
    }
    
    private Agent selectByResponseTime(List<Agent> agents) {
        // 基于历史响应时间的加权选择
        double totalWeight = agents.stream()
            .mapToDouble(agent -> 1.0 / (agentMetrics.get(agent).getAverageResponseTime() + 1))
            .sum();
        
        double random = Math.random() * totalWeight;
        double currentWeight = 0;
        
        for (Agent agent : agents) {
            currentWeight += 1.0 / (agentMetrics.get(agent).getAverageResponseTime() + 1);
            if (random <= currentWeight) {
                return agent;
            }
        }
        
        return agents.get(agents.size() - 1);
    }
    
    private Agent selectRandom(List<Agent> agents) {
        return agents.get((int) (Math.random() * agents.size()));
    }
    
    /**
     * 更新Agent指标
     */
    public void updateMetrics(Agent agent, long responseTime, boolean success) {
        AgentMetrics metrics = agentMetrics.get(agent);
        if (metrics != null) {
            metrics.recordRequest(responseTime, success);
        }
    }
}

// AgentMetrics.java - Agent性能指标
public class AgentMetrics {
    private final AtomicInteger activeConnections = new AtomicInteger(0);
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final AtomicLong totalResponseTime = new AtomicLong(0);
    private final AtomicInteger successCount = new AtomicInteger(0);
    private final AtomicInteger errorCount = new AtomicInteger(0);
    
    public void recordRequest(long responseTime, boolean success) {
        totalRequests.incrementAndGet();
        totalResponseTime.addAndGet(responseTime);
        
        if (success) {
            successCount.incrementAndGet();
        } else {
            errorCount.incrementAndGet();
        }
    }
    
    public double getAverageResponseTime() {
        long total = totalRequests.get();
        return total > 0 ? (double) totalResponseTime.get() / total : 0;
    }
    
    public double getSuccessRate() {
        long total = totalRequests.get();
        return total > 0 ? (double) successCount.get() / total : 1.0;
    }
    
    public int getActiveConnections() {
        return activeConnections.get();
    }
    
    public void incrementConnections() {
        activeConnections.incrementAndGet();
    }
    
    public void decrementConnections() {
        activeConnections.decrementAndGet();
    }
}
```

### 熔断器模式

```java
// AgentCircuitBreaker.java - Agent熔断器
public class AgentCircuitBreaker {
    
    private enum State {
        CLOSED,    // 正常状态
        OPEN,      // 熔断状态
        HALF_OPEN  // 半开状态
    }
    
    private volatile State state = State.CLOSED;
    private final AtomicInteger failureCount = new AtomicInteger(0);
    private final AtomicInteger successCount = new AtomicInteger(0);
    private volatile long lastFailureTime = 0;
    
    private final int failureThreshold;
    private final int successThreshold;
    private final long timeout;
    
    public AgentCircuitBreaker(int failureThreshold, int successThreshold, long timeout) {
        this.failureThreshold = failureThreshold;
        this.successThreshold = successThreshold;
        this.timeout = timeout;
    }
    
    /**
     * 执行Agent调用（带熔断保护）
     */
    public <T> T execute(Supplier<T> operation, Supplier<T> fallback) throws Exception {
        if (state == State.OPEN) {
            if (System.currentTimeMillis() - lastFailureTime < timeout) {
                return fallback.get(); // 熔断器开启，执行降级逻辑
            } else {
                state = State.HALF_OPEN; // 进入半开状态
            }
        }
        
        try {
            T result = operation.get();
            onSuccess();
            return result;
        } catch (Exception e) {
            onFailure();
            if (state == State.OPEN) {
                return fallback.get();
            } else {
                throw e;
            }
        }
    }
    
    private void onSuccess() {
        failureCount.set(0);
        if (state == State.HALF_OPEN) {
            int currentSuccessCount = successCount.incrementAndGet();
            if (currentSuccessCount >= successThreshold) {
                state = State.CLOSED;
                successCount.set(0);
            }
        }
    }
    
    private void onFailure() {
        lastFailureTime = System.currentTimeMillis();
        int currentFailureCount = failureCount.incrementAndGet();
        
        if (currentFailureCount >= failureThreshold) {
            state = State.OPEN;
        }
        
        if (state == State.HALF_OPEN) {
            state = State.OPEN;
            successCount.set(0);
        }
    }
    
    public State getState() {
        return state;
    }
}
```

## 2.2.4.6 Agent性能监控与调优

### 实时性能监控

```java
// AgentPerformanceMonitor.java - Agent性能监控器
public class AgentPerformanceMonitor {
    
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final Map<String, AgentPerformanceData> performanceData = new ConcurrentHashMap<>();
    
    public void startMonitoring() {
        // 每秒收集性能数据
        scheduler.scheduleAtFixedRate(this::collectMetrics, 0, 1, TimeUnit.SECONDS);
        
        // 每分钟输出性能报告
        scheduler.scheduleAtFixedRate(this::generateReport, 0, 60, TimeUnit.SECONDS);
    }
    
    private void collectMetrics() {
        for (Map.Entry<String, AgentPerformanceData> entry : performanceData.entrySet()) {
            String agentId = entry.getKey();
            AgentPerformanceData data = entry.getValue();
            
            // 收集JVM指标
            MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
            MemoryUsage heapMemory = memoryBean.getHeapMemoryUsage();
            
            data.recordMemoryUsage(heapMemory.getUsed());
            data.recordCpuUsage(getCpuUsage());
            
            // 收集Agent特定指标
            data.recordThroughput(getAgentThroughput(agentId));
            data.recordLatency(getAgentLatency(agentId));
        }
    }
    
    private void generateReport() {
        StringBuilder report = new StringBuilder();
        report.append("\n=== Agent Performance Report ===\n");
        
        for (Map.Entry<String, AgentPerformanceData> entry : performanceData.entrySet()) {
            String agentId = entry.getKey();
            AgentPerformanceData data = entry.getValue();
            
            report.append(String.format(
                "Agent: %s\n" +
                "  Memory Usage: %.2f MB\n" +
                "  CPU Usage: %.2f%%\n" +
                "  Throughput: %.2f ops/sec\n" +
                "  Average Latency: %.2f ms\n" +
                "  Error Rate: %.2f%%\n\n",
                agentId,
                data.getAverageMemoryUsage() / (1024 * 1024),
                data.getAverageCpuUsage(),
                data.getCurrentThroughput(),
                data.getAverageLatency(),
                data.getErrorRate()
            ));
        }
        
        logger.info(report.toString());
    }
    
    private double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            return ((com.sun.management.OperatingSystemMXBean) osBean).getProcessCpuLoad() * 100;
        }
        return 0;
    }
    
    private double getAgentThroughput(String agentId) {
        // 从Agent指标中获取吞吐量
        return 0; // 实际实现需要连接到Agent的指标系统
    }
    
    private double getAgentLatency(String agentId) {
        // 从Agent指标中获取延迟
        return 0; // 实际实现需要连接到Agent的指标系统
    }
}
```

## 小结

AI-Agent的并发调度与协调是构建高性能AGI应用的核心技术。通过合理的架构设计、状态同步、负载均衡和监控机制，可以实现Agent系统的高效并发处理。

关键要点：
1. **并发模式选择**：根据应用场景选择合适的Agent并发模式
2. **状态同步**：确保多Agent间的状态一致性
3. **负载均衡**：合理分配任务负载，避免单点瓶颈
4. **容错机制**：通过熔断器等模式提高系统稳定性
5. **性能监控**：实时监控Agent性能，及时发现和解决问题

---

**最佳实践建议：**
1. 设计清晰的Agent职责边界
2. 实施有效的Agent间通信机制
3. 建立完善的监控和告警体系
4. 定期进行性能调优和容量规划
