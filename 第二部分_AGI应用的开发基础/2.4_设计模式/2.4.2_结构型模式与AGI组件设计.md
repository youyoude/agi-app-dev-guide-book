# 2.4.2 结构型模式与AGI组件设计

结构型设计模式关注如何将类或对象组合成更大的结构，以获得更多的功能。在AGI应用开发中，结构型模式帮助我们构建灵活且可扩展的组件架构，能够适应AI系统的复杂性和多样性。本节将通过JoyAgent-JDGenie项目的实际实现，深入探讨装饰者模式、适配器模式、组合模式、外观模式等在AI应用中的具体应用。

## 装饰者模式：智能输出增强

装饰者模式允许我们在不修改现有对象结构的情况下，动态地给对象添加新的功能。在JoyAgent-JDGenie中，`SSEPrinter`就是装饰者模式的典型应用，它为基本的打印功能添加了服务器推送事件（SSE）的能力。

### 基础接口设计

```java
public interface Printer {
    void send(String messageId, String messageType, Object message, String digitalEmployee, Boolean isFinal);
    void send(String messageType, Object message);
    void send(String messageType, Object message, String digitalEmployee);
    void send(String messageId, String messageType, Object message, Boolean isFinal);
    void close();
    void updateAgentType(AgentType agentType);
}
```

### 装饰者实现

```java
@Slf4j
@Setter
public class SSEPrinter implements Printer {
    private SseEmitter emitter;
    private AgentRequest request;
    private Integer agentType;

    public SSEPrinter(SseEmitter emitter, AgentRequest request, Integer agentType) {
        this.emitter = emitter;
        this.request = request;
        this.agentType = agentType;
    }

    @Override
    public void send(String messageId, String messageType, Object message, String digitalEmployee, Boolean isFinal) {
        try {
            if (Objects.isNull(messageId)) {
                messageId = StringUtil.getUUID();
            }
            log.info("{} sse send {} {} {}", request.getRequestId(), messageType, message, digitalEmployee);
            
            // 构建响应对象
            AgentResponse response = AgentResponse.builder()
                    .requestId(request.getRequestId())
                    .messageId(messageId)
                    .messageType(messageType)
                    .messageTime(String.valueOf(System.currentTimeMillis()))
                    .finish("result".equals(messageType))
                    .isFinal(isFinal)
                    .build();

            // 根据消息类型进行特殊处理
            switch (messageType) {
                case "tool_thought":
                    response.setToolThought((String) message);
                    break;
                case "task":
                    response.setTask(((String) message).replaceAll("^执行顺序(\\d+)\\.\\s?", ""));
                    break;
                case "task_summary":
                    if (message instanceof Map) {
                        Map<String, Object> taskSummary = (Map<String, Object>) message;
                        response.setResultMap(taskSummary);
                        response.setTaskSummary(taskSummary.get("taskSummary").toString());
                    }
                    break;
                // ... 更多消息类型处理
            }

            // 通过SSE发送
            emitter.send(response);

        } catch (Exception e) {
            log.error("sse send error ", e);
        }
    }

    // ... 其他方法实现
}
```

### 设计优势

1. **职责分离**：基础打印功能与SSE通信功能分离
2. **动态扩展**：可以在运行时添加或移除装饰器
3. **灵活组合**：可以组合多个装饰器实现复杂功能
4. **开闭原则**：对扩展开放，对修改封闭

### AGI应用中的扩展应用

在AGI应用中，装饰者模式特别适用于以下场景：

```java
// 日志装饰器
public class LoggingPrinter implements Printer {
    private final Printer delegate;
    private final Logger logger;
    
    public LoggingPrinter(Printer delegate, Logger logger) {
        this.delegate = delegate;
        this.logger = logger;
    }
    
    @Override
    public void send(String messageType, Object message) {
        logger.info("Sending message: type={}, content={}", messageType, message);
        delegate.send(messageType, message);
        logger.info("Message sent successfully");
    }
}

// 消息过滤装饰器
public class FilteringPrinter implements Printer {
    private final Printer delegate;
    private final MessageFilter filter;
    
    @Override
    public void send(String messageType, Object message) {
        if (filter.shouldSend(messageType, message)) {
            delegate.send(messageType, message);
        }
    }
}

// 使用示例
Printer printer = new LoggingPrinter(
    new FilteringPrinter(
        new SSEPrinter(emitter, request, agentType),
        new SensitiveContentFilter()
    ),
    LoggerFactory.getLogger(AgentPrinter.class)
);
```

## 适配器模式：多AI模型提供商适配

适配器模式允许接口不兼容的类协同工作。在JoyAgent-JDGenie中，`LLM`类就是一个复杂的适配器，它统一了不同AI模型提供商（OpenAI、Claude、DeepSeek等）的接口。

### 统一接口设计

```java
@Slf4j
@Data
public class LLM {
    private final String model;
    private final String apiKey;
    private final String baseUrl;
    private final String functionCallType;
    private final ObjectMapper objectMapper;

    /**
     * 统一的消息格式化方法
     */
    public static List<Map<String, Object>> formatMessages(List<Message> messages, boolean isClaude) {
        List<Map<String, Object>> formattedMessages = new ArrayList<>();

        for (Message message : messages) {
            Map<String, Object> messageMap = new HashMap<>();
            
            // 处理工具调用 - OpenAI vs Claude格式差异
            if (message.getToolCalls() != null && !message.getToolCalls().isEmpty()) {
                if (isClaude) {
                    // Claude格式的工具调用处理
                    List<Map<String, Object>> claudeToolCalls = new ArrayList<>();
                    for (ToolCall toolCall : message.getToolCalls()) {
                        Map<String, Object> claudeToolCall = new HashMap<>();
                        claudeToolCall.put("type", "tool_use");
                        claudeToolCall.put("id", toolCall.getId());
                        claudeToolCall.put("name", toolCall.getFunction().getName());
                        claudeToolCall.put("input", JSON.parseObject(toolCall.getFunction().getArguments()));
                        claudeToolCalls.add(claudeToolCall);
                    }
                    messageMap.put("content", claudeToolCalls);
                } else {
                    // OpenAI格式
                    messageMap.put("tool_calls", JSON.parseObject(JSON.toJSONString(message.getToolCalls()),
                            new TypeReference<List<Map<String, Object>>>() {}));
                }
            }
            // ... 其他格式处理
            
            formattedMessages.add(messageMap);
        }

        return formattedMessages;
    }

    /**
     * 统一的工具格式转换
     */
    public List<Map<String, Object>> gptToClaudeTool(List<Map<String, Object>> gptTools) {
        List<Map<String, Object>> claudeTools = new ArrayList<>();
        for (Map<String, Object> gptToolWrapper : gptTools) {
            Map<String, Object> gptTool = (Map<String, Object>) gptToolWrapper.get("function");
            Map<String, Object> claudeTool = new HashMap<>();
            claudeTool.put("name", gptTool.get("name"));
            claudeTool.put("description", gptTool.get("description"));
            claudeTool.put("input_schema", gptTool.get("parameters"));
            claudeTools.add(claudeTool);
        }
        return claudeTools;
    }
}
```

### 多提供商API调用适配

```java
public CompletableFuture<ToolCallResponse> askTool(
        AgentContext context,
        List<Message> messages,
        Message systemMsgs,
        ToolCollection tools,
        ToolChoice toolChoice,
        Double temperature,
        boolean stream,
        int timeout) {
    
    try {
        // 根据模型类型选择不同的处理逻辑
        if (model.contains("claude")) {
            return callClaudeFunctionCallStream(context, params);
        } else {
            return callOpenAIFunctionCallStream(context, params);
        }
    } catch (Exception e) {
        log.error("Unexpected error in askTool", e);
        CompletableFuture<ToolCallResponse> future = new CompletableFuture<>();
        future.completeExceptionally(e);
        return future;
    }
}
```

### 设计优势

1. **接口统一**：为不同的AI模型提供统一的调用接口
2. **易于扩展**：新增AI模型提供商只需添加适配逻辑
3. **降低耦合**：客户端代码不需要知道具体的模型差异
4. **配置驱动**：通过配置切换不同的模型提供商

### 配置化适配器实现

```java
@Component
public class LLMProviderAdapter {
    private final Map<String, LLMProvider> providers = new HashMap<>();
    
    @PostConstruct
    public void initProviders() {
        providers.put("openai", new OpenAIProvider());
        providers.put("claude", new ClaudeProvider());
        providers.put("deepseek", new DeepSeekProvider());
    }
    
    public LLMResponse callLLM(String providerName, LLMRequest request) {
        LLMProvider provider = providers.get(providerName);
        if (provider == null) {
            throw new IllegalArgumentException("Unsupported provider: " + providerName);
        }
        return provider.call(request);
    }
}

// 具体提供商实现
public class OpenAIProvider implements LLMProvider {
    @Override
    public LLMResponse call(LLMRequest request) {
        // OpenAI特定的调用逻辑
        return convertToStandardResponse(callOpenAI(request));
    }
}

public class ClaudeProvider implements LLMProvider {
    @Override
    public LLMResponse call(LLMRequest request) {
        // Claude特定的调用逻辑
        return convertToStandardResponse(callClaude(request));
    }
}
```

## 组合模式：工具集合的层次化管理

组合模式允许我们将对象组合成树形结构来表示"部分-整体"的层次结构。在JoyAgent-JDGenie中，`ToolCollection`类使用组合模式来管理不同类型的工具。

### 组合结构设计

```java
@Data
@Slf4j
public class ToolCollection {
    private Map<String, BaseTool> toolMap;
    private Map<String, McpToolInfo> mcpToolMap;
    private AgentContext agentContext;

    public ToolCollection() {
        this.toolMap = new HashMap<>();
        this.mcpToolMap = new HashMap<>();
    }

    /**
     * 添加基础工具
     */
    public void addTool(BaseTool tool) {
        toolMap.put(tool.getName(), tool);
    }

    /**
     * 添加MCP工具
     */
    public void addMcpTool(String name, String desc, String parameters, String mcpServerUrl) {
        mcpToolMap.put(name, McpToolInfo.builder()
                .name(name)
                .desc(desc)
                .parameters(parameters)
                .mcpServerUrl(mcpServerUrl)
                .build());
    }

    /**
     * 统一的工具执行接口
     */
    public Object execute(String name, Object toolInput) {
        if (toolMap.containsKey(name)) {
            BaseTool tool = getTool(name);
            return tool.execute(toolInput);
        } else if (mcpToolMap.containsKey(name)) {
            McpToolInfo toolInfo = mcpToolMap.get(name);
            McpTool mcpTool = new McpTool();
            mcpTool.setAgentContext(agentContext);
            return mcpTool.callTool(toolInfo.getMcpServerUrl(), name, toolInput);
        } else {
            log.error("Error: Unknown tool {}", name);
        }
        return null;
    }
}
```

### 工具层次化组织

```java
// 工具分组管理
public class ToolGroup {
    private String groupName;
    private List<BaseTool> tools;
    private List<ToolGroup> subGroups;
    
    public void addTool(BaseTool tool) {
        tools.add(tool);
    }
    
    public void addSubGroup(ToolGroup subGroup) {
        subGroups.add(subGroup);
    }
    
    public List<BaseTool> getAllTools() {
        List<BaseTool> allTools = new ArrayList<>(tools);
        for (ToolGroup subGroup : subGroups) {
            allTools.addAll(subGroup.getAllTools());
        }
        return allTools;
    }
    
    public Object execute(String toolName, Object input) {
        // 先在当前组中查找
        for (BaseTool tool : tools) {
            if (tool.getName().equals(toolName)) {
                return tool.execute(input);
            }
        }
        
        // 在子组中递归查找
        for (ToolGroup subGroup : subGroups) {
            Object result = subGroup.execute(toolName, input);
            if (result != null) {
                return result;
            }
        }
        
        return null;
    }
}

// 使用示例
ToolGroup aiToolGroup = new ToolGroup("AI Tools");
aiToolGroup.addTool(new CodeInterpreterTool());
aiToolGroup.addTool(new ReportTool());

ToolGroup searchGroup = new ToolGroup("Search Tools");
searchGroup.addTool(new DeepSearchTool());
searchGroup.addTool(new WebSearchTool());

ToolGroup rootGroup = new ToolGroup("All Tools");
rootGroup.addSubGroup(aiToolGroup);
rootGroup.addSubGroup(searchGroup);
```

### 设计优势

1. **统一接口**：不同类型的工具通过统一的接口调用
2. **透明性**：客户端不需要区分单个工具和工具集合
3. **灵活组织**：支持工具的层次化组织和管理
4. **易于扩展**：新增工具类型不影响现有代码

## 外观模式：简化AI系统复杂性

外观模式为复杂子系统提供一个简单的接口。在JoyAgent-JDGenie中，`GenieController`就是一个外观类，它简化了复杂的Agent调度系统。

### 外观接口设计

```java
@Slf4j
@RestController
@RequestMapping("/")
public class GenieController {
    @Autowired
    private AgentHandlerFactory agentHandlerFactory;
    @Autowired
    private IGptProcessService gptProcessService;

    /**
     * 执行智能体调度 - 简化的外观接口
     */
    @PostMapping("/AutoAgent")
    public SseEmitter AutoAgent(@RequestBody AgentRequest request) throws UnsupportedEncodingException {
        log.info("{} auto agent request: {}", request.getRequestId(), JSON.toJSONString(request));

        SseEmitter emitter = new SseEmitter(60 * 60 * 1000L);
        
        // 简化的调用流程，隐藏复杂性
        ThreadUtil.execute(() -> {
            try {
                // 1. 创建上下文
                AgentContext agentContext = buildAgentContext(request, emitter);
                
                // 2. 构建工具集合
                agentContext.setToolCollection(buildToolCollection(agentContext, request));
                
                // 3. 获取处理器
                AgentHandlerService handler = agentHandlerFactory.getHandler(agentContext, request);
                
                // 4. 执行处理
                handler.handle(agentContext, request);
                
                // 5. 关闭连接
                emitter.complete();
                
            } catch (Exception e) {
                log.error("{} auto agent error", request.getRequestId(), e);
            }
        });

        return emitter;
    }

    /**
     * 构建智能体上下文
     */
    private AgentContext buildAgentContext(AgentRequest request, SseEmitter emitter) {
        Printer printer = new SSEPrinter(emitter, request, request.getAgentType());
        
        return AgentContext.builder()
                .requestId(request.getRequestId())
                .sessionId(request.getRequestId())
                .printer(printer)
                .query(handleOutputStyle(request))
                .task("")
                .dateInfo(DateUtil.CurrentDateInfo())
                .productFiles(new ArrayList<>())
                .taskProductFiles(new ArrayList<>())
                .sopPrompt(request.getSopPrompt())
                .basePrompt(request.getBasePrompt())
                .agentType(request.getAgentType())
                .isStream(Objects.nonNull(request.getIsStream()) ? request.getIsStream() : false)
                .build();
    }

    /**
     * 构建工具集合
     */
    private ToolCollection buildToolCollection(AgentContext agentContext, AgentRequest request) {
        ToolCollection toolCollection = new ToolCollection();
        toolCollection.setAgentContext(agentContext);
        
        // 添加文件工具
        FileTool fileTool = new FileTool();
        fileTool.setAgentContext(agentContext);
        toolCollection.addTool(fileTool);

        // 根据配置添加工具
        List<String> agentToolList = Arrays.asList(genieConfig.getMultiAgentToolListMap()
                .getOrDefault("default", "search,code,report").split(","));
        
        if (agentToolList.contains("code")) {
            CodeInterpreterTool codeTool = new CodeInterpreterTool();
            codeTool.setAgentContext(agentContext);
            toolCollection.addTool(codeTool);
        }
        
        if (agentToolList.contains("report")) {
            ReportTool htmlTool = new ReportTool();
            htmlTool.setAgentContext(agentContext);
            toolCollection.addTool(htmlTool);
        }
        
        if (agentToolList.contains("search")) {
            DeepSearchTool deepSearchTool = new DeepSearchTool();
            deepSearchTool.setAgentContext(agentContext);
            toolCollection.addTool(deepSearchTool);
        }

        // 添加MCP工具
        addMcpTools(toolCollection, agentContext);

        return toolCollection;
    }
}
```

### 设计优势

1. **简化接口**：将复杂的子系统操作封装为简单的方法调用
2. **降低耦合**：客户端不需要直接与多个子系统交互
3. **统一入口**：提供系统的统一访问点
4. **职责明确**：每个外观方法都有明确的职责

## 代理模式：智能缓存与权限控制

代理模式为其他对象提供一种代理以控制对这个对象的访问。在AGI应用中，代理模式特别适用于缓存、权限控制和资源管理。

### 缓存代理实现

```java
public class CachedLLMProxy implements LLMProvider {
    private final LLMProvider target;
    private final Cache<String, LLMResponse> cache;
    
    public CachedLLMProxy(LLMProvider target) {
        this.target = target;
        this.cache = CacheBuilder.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build();
    }
    
    @Override
    public LLMResponse call(LLMRequest request) {
        String cacheKey = generateCacheKey(request);
        
        try {
            return cache.get(cacheKey, () -> {
                log.info("Cache miss for request: {}", cacheKey);
                return target.call(request);
            });
        } catch (Exception e) {
            log.error("Error calling LLM", e);
            return target.call(request);
        }
    }
    
    private String generateCacheKey(LLMRequest request) {
        return DigestUtils.md5Hex(JSON.toJSONString(request));
    }
}
```

### 权限控制代理

```java
public class AuthorizedLLMProxy implements LLMProvider {
    private final LLMProvider target;
    private final PermissionService permissionService;
    
    @Override
    public LLMResponse call(LLMRequest request) {
        if (!permissionService.hasPermission(request.getUserId(), "llm:call")) {
            throw new SecurityException("User does not have permission to call LLM");
        }
        
        if (!permissionService.checkQuota(request.getUserId())) {
            throw new QuotaExceededException("User has exceeded LLM quota");
        }
        
        return target.call(request);
    }
}
```

## 桥接模式：抽象与实现分离

桥接模式将抽象部分与实现部分分离，使它们都可以独立变化。在AGI应用中，这对于支持不同的AI模型和执行策略非常有用。

### 桥接结构设计

```java
// 抽象Agent
public abstract class Agent {
    protected LLMBridge llmBridge;
    
    public Agent(LLMBridge llmBridge) {
        this.llmBridge = llmBridge;
    }
    
    public abstract String process(String input);
}

// 具体Agent实现
public class ChatAgent extends Agent {
    public ChatAgent(LLMBridge llmBridge) {
        super(llmBridge);
    }
    
    @Override
    public String process(String input) {
        return llmBridge.generateText(input);
    }
}

public class CodeAgent extends Agent {
    public CodeAgent(LLMBridge llmBridge) {
        super(llmBridge);
    }
    
    @Override
    public String process(String input) {
        String code = llmBridge.generateCode(input);
        return llmBridge.executeCode(code);
    }
}

// LLM桥接接口
public interface LLMBridge {
    String generateText(String prompt);
    String generateCode(String prompt);
    String executeCode(String code);
}

// 具体LLM实现
public class OpenAIBridge implements LLMBridge {
    @Override
    public String generateText(String prompt) {
        // OpenAI文本生成实现
    }
    
    @Override
    public String generateCode(String prompt) {
        // OpenAI代码生成实现
    }
    
    @Override
    public String executeCode(String code) {
        // 代码执行实现
    }
}

// 使用示例
Agent chatAgent = new ChatAgent(new OpenAIBridge());
Agent codeAgent = new CodeAgent(new ClaudeBridge());
```

## 享元模式：模型实例共享

享元模式通过共享有效支持大量细粒度对象。在AGI应用中，这对于管理大型模型实例特别有用。

```java
public class LLMModelFlyweightFactory {
    private static final Map<String, LLMModel> models = new ConcurrentHashMap<>();
    
    public static LLMModel getModel(String modelName) {
        return models.computeIfAbsent(modelName, name -> {
            log.info("Loading model: {}", name);
            return new LLMModel(name);
        });
    }
    
    public static void clearUnusedModels() {
        models.entrySet().removeIf(entry -> 
            entry.getValue().getLastUsedTime() < System.currentTimeMillis() - TimeUnit.HOURS.toMillis(1)
        );
    }
}
```

## 小结

结构型模式在AGI应用开发中发挥着重要作用：

1. **装饰者模式**帮助我们动态扩展AI组件的功能
2. **适配器模式**统一了不同AI模型提供商的接口
3. **组合模式**支持工具的层次化管理
4. **外观模式**简化了复杂AI系统的使用
5. **代理模式**提供了缓存、权限控制等增强功能
6. **桥接模式**实现了抽象与实现的分离
7. **享元模式**优化了大型模型的内存使用

这些模式的合理应用不仅提高了系统的灵活性和可维护性，还为AGI应用的性能优化和功能扩展提供了坚实的基础。在下一节中，我们将探讨行为型模式如何驱动AGI系统的决策流程。