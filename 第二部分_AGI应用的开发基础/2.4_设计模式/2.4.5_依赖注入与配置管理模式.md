# 2.4.5 依赖注入与配置管理模式

依赖注入（Dependency Injection，DI）是一种设计模式，它通过外部容器来管理对象之间的依赖关系，从而实现松耦合的设计。在AGI应用开发中，依赖注入模式配合配置管理，能够有效地管理复杂的AI组件依赖关系，提高系统的可维护性和可扩展性。本节将通过JoyAgent-JDGenie项目的实际实现，探讨依赖注入和配置管理在AI应用中的最佳实践。

## 依赖注入在AI组件中的实现

### Spring框架的依赖注入应用

JoyAgent-JDGenie项目基于Spring框架，充分利用了Spring的依赖注入功能：

```java
@Component
public class AgentHandlerFactory {
    
    private final Map<String, AgentHandlerService> handlerMap = new ConcurrentHashMap<>();
    
    // 构造函数注入 - Spring自动注入所有AgentHandlerService实现
    @Autowired
    public AgentHandlerFactory(List<AgentHandlerService> handlers) {
        // 初始化处理器映射
        for (AgentHandlerService handler : handlers) {
            handlerMap.put(handler.getClass().getSimpleName().toLowerCase(), handler);
        }
    }
    
    public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
        // 通过supports方法匹配合适的处理器
        for (AgentHandlerService handler : handlerMap.values()) {
            if (handler.support(context, request)) {
                return handler;
            }
        }
        return null;
    }
}
```

### 智能体组件的依赖注入设计

```java
@Component
public class GenieController {
    
    // 字段注入 - 注入工厂和服务
    @Autowired
    private AgentHandlerFactory agentHandlerFactory;
    
    @Autowired
    private IGptProcessService gptProcessService;
    
    @Autowired
    private GenieConfig genieConfig;
    
    @PostMapping("/AutoAgent")
    public SseEmitter AutoAgent(@RequestBody AgentRequest request) {
        SseEmitter emitter = new SseEmitter(60 * 60 * 1000L);
        
        ThreadUtil.execute(() -> {
            try {
                // 利用注入的组件构建处理流程
                AgentContext agentContext = buildAgentContext(request, emitter);
                agentContext.setToolCollection(buildToolCollection(agentContext, request));
                
                AgentHandlerService handler = agentHandlerFactory.getHandler(agentContext, request);
                handler.handle(agentContext, request);
                
                emitter.complete();
            } catch (Exception e) {
                log.error("Auto agent error", e);
            }
        });
        
        return emitter;
    }
}
```

## 配置管理最佳实践

### 分层配置架构

JoyAgent-JDGenie采用了分层的配置管理架构：

```java
@Slf4j
@Getter
@Configuration
@ConfigurationProperties(prefix = "autobots.autoagent")
public class GenieConfig {
    
    // 规划器配置
    @NestedConfigurationProperty
    private PlannerConfig planner = new PlannerConfig();
    
    // 执行器配置  
    @NestedConfigurationProperty
    private ExecutorConfig executor = new ExecutorConfig();
    
    // React配置
    @NestedConfigurationProperty
    private ReactConfig react = new ReactConfig();
    
    @Data
    public static class PlannerConfig {
        private String modelName = "gpt-4o-0806";
        private Map<String, String> systemPromptMap = new HashMap<>();
        private int maxSteps = 10;
        private double temperature = 0.1;
    }
    
    @Data
    public static class ExecutorConfig {
        private String modelName = "gpt-4o-0806";
        private int maxSteps = 15;
        private boolean enableParallel = true;
        private Duration timeout = Duration.ofMinutes(5);
    }
}
```

## 服务定位器模式

### 服务注册与发现

```java
@Component
public class AgentServiceRegistry {
    
    private final Map<String, AgentService> serviceMap = new ConcurrentHashMap<>();
    private final Map<Class<?>, List<AgentService>> typeMap = new ConcurrentHashMap<>();
    
    @Autowired
    public AgentServiceRegistry(List<AgentService> services) {
        registerServices(services);
    }
    
    private void registerServices(List<AgentService> services) {
        for (AgentService service : services) {
            // 按名称注册
            String serviceName = service.getClass().getSimpleName();
            serviceMap.put(serviceName, service);
            
            // 按类型注册
            Class<?>[] interfaces = service.getClass().getInterfaces();
            for (Class<?> interfaceClass : interfaces) {
                typeMap.computeIfAbsent(interfaceClass, k -> new ArrayList<>()).add(service);
            }
            
            log.info("Registered agent service: {}", serviceName);
        }
    }
    
    public <T extends AgentService> T getService(String serviceName, Class<T> serviceType) {
        AgentService service = serviceMap.get(serviceName);
        if (service != null && serviceType.isInstance(service)) {
            return serviceType.cast(service);
        }
        return null;
    }
}
```

## 小结与最佳实践

依赖注入与配置管理模式在AGI应用中发挥着重要作用：

### 核心优势
1. **松耦合设计**：组件之间的依赖关系由容器管理，降低了耦合度
2. **配置集中化**：所有配置统一管理，便于维护和更新
3. **环境适配**：支持不同环境的配置差异化
4. **动态配置**：支持运行时配置更新，提高系统灵活性

### 最佳实践建议
1. **合理使用注入方式**：构造函数注入 > 字段注入，避免循环依赖
2. **分层配置管理**：按功能模块组织配置，使用嵌套配置类
3. **配置验证**：对关键配置进行验证，确保系统稳定性
4. **敏感信息保护**：对API密钥等敏感配置进行加密存储

依赖注入与配置管理为AGI应用提供了强大的架构基础，使得系统具备良好的可维护性、可扩展性和可配置性。在下一节中，我们将总结设计模式的最佳实践，并分析常见的反模式。
