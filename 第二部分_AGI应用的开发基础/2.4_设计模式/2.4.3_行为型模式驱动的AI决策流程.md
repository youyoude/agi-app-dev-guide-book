# 2.4.3 行为型模式驱动的AI决策流程

行为型设计模式专注于对象之间的通信和职责分配，在AGI应用开发中尤为重要。本节将通过JoyAgent-JDGenie项目的实际实现，探讨这些模式在AI决策流程中的具体应用。

## 模板方法模式：智能体执行流程标准化

模板方法模式在BaseAgent中得到完美体现：

```java
public abstract class BaseAgent {
    public String run(String query) {
        setState(AgentState.IDLE);
        updateMemory(RoleType.USER, query, null);
        
        List<String> results = new ArrayList<>();
        try {
            while (currentStep < maxSteps && state != AgentState.FINISHED) {
                currentStep++;
                String stepResult = step(); // 抽象方法，子类实现
                results.add(stepResult);
            }
        } catch (Exception e) {
            state = AgentState.ERROR;
            throw e;
        }
        return results.get(results.size() - 1);
    }
    
    public abstract String step(); // 抽象步骤，子类定制
}
```

ReActAgent进一步细化了模板：

```java
public abstract class ReActAgent extends BaseAgent {
    @Override
    public String step() {
        boolean shouldAct = think(); // 思考阶段
        if (!shouldAct) return "Thinking complete";
        return act(); // 行动阶段
    }
    
    public abstract boolean think();
    public abstract String act();
}
```

## 策略模式：多样化的智能体决策策略

不同的智能体类型实现了不同的决策策略：

```java
public interface AgentStrategy {
    String process(AgentContext context, String query);
    boolean supports(AgentContext context, AgentRequest request);
    String getStrategyName();
}

@Component
public class PlanningStrategy implements AgentStrategy {
    @Override
    public String process(AgentContext context, String query) {
        PlanningAgent agent = new PlanningAgent(context);
        return agent.run(query);
    }
    
    @Override
    public boolean supports(AgentContext context, AgentRequest request) {
        return AgentType.PLAN_AND_SOLVE.getValue().equals(request.getAgentType());
    }
}

@Component
public class ReactStrategy implements AgentStrategy {
    @Override
    public String process(AgentContext context, String query) {
        ReactImplAgent agent = new ReactImplAgent(context);
        return agent.run(query);
    }
    
    @Override
    public boolean supports(AgentContext context, AgentRequest request) {
        return AgentType.REACT.getValue().equals(request.getAgentType());
    }
}
```

策略选择器根据请求类型动态选择合适的策略：

```java
@Component
public class AgentStrategySelector {
    @Autowired
    private List<AgentStrategy> strategies;
    
    public AgentStrategy selectStrategy(AgentContext context, AgentRequest request) {
        return strategies.stream()
                .filter(strategy -> strategy.supports(context, request))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("No suitable strategy found"));
    }
}
```

## 状态模式：智能体状态管理

JoyAgent-JDGenie通过AgentState枚举管理智能体状态：

```java
public enum AgentState {
    IDLE,       // 空闲状态
    RUNNING,    // 运行状态
    FINISHED,   // 完成状态
    ERROR       // 错误状态
}
```

状态处理接口定义了状态转换规则：

```java
public interface AgentStateHandler {
    void handle(BaseAgent agent, AgentContext context);
    boolean canTransitionTo(AgentState targetState);
    AgentState getState();
}

public class RunningStateHandler implements AgentStateHandler {
    @Override
    public void handle(BaseAgent agent, AgentContext context) {
        try {
            String stepResult = agent.step();
            if (agent.getCurrentStep() >= agent.getMaxSteps()) {
                agent.setState(AgentState.FINISHED);
            }
        } catch (Exception e) {
            agent.setState(AgentState.ERROR);
        }
    }
    
    @Override
    public boolean canTransitionTo(AgentState targetState) {
        return targetState == AgentState.FINISHED || targetState == AgentState.ERROR;
    }
}
```

## 观察者模式：事件驱动的通信机制

项目中的SSE机制体现了观察者模式：

```java
public interface SseEventListener {
    void onEvent(String event);
    void onComplete();
    void onError(IOException e);
}

public class SseNotificationService {
    public void sseRequest(String url, String jsonParams, 
                          SseEventListener eventListener) {
        // 建立SSE连接
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onResponse(Call call, Response response) {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(response.body().byteStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        eventListener.onEvent(line); // 通知观察者
                    }
                }
                eventListener.onComplete();
            }
        });
    }
}
```

## 命令模式：工具调用的封装与管理

ToolCall类封装了工具调用请求：

```java
@Data
@Builder
public class ToolCall {
    private String id;
    private String type;
    private Function function;
    
    @Data
    @Builder
    public static class Function {
        private String name;
        private String arguments;
    }
    
    public Object execute(ToolCollection toolCollection) {
        return toolCollection.execute(function.getName(), 
                JSON.parseObject(function.getArguments()));
    }
}
```

命令调度器管理命令的执行和撤销：

```java
@Component
public class CommandInvoker {
    private final Deque<Command> executedCommands = new ArrayDeque<>();
    
    public Object executeCommand(Command command) {
        Object result = command.execute();
        if (command.isUndoable()) {
            executedCommands.push(command);
        }
        return result;
    }
    
    public void undo() {
        if (!executedCommands.isEmpty()) {
            Command command = executedCommands.pop();
            command.undo();
        }
    }
}
```

## 设计优势总结

1. **模板方法模式**：
   - 标准化执行流程
   - 提供扩展点
   - 代码复用

2. **策略模式**：
   - 支持算法切换
   - 易于扩展新策略
   - 运行时选择

3. **状态模式**：
   - 规范状态转换
   - 封装状态行为
   - 避免状态混乱

4. **观察者模式**：
   - 事件驱动通信
   - 松耦合设计
   - 实时响应

5. **命令模式**：
   - 封装操作请求
   - 支持撤销重做
   - 操作记录

这些行为型模式的合理应用，使得JoyAgent-JDGenie的AI决策流程更加清晰、灵活和可维护。在下一节中，我们将深入探讨责任链模式在智能体协作中的应用。