# 2.3.5 å¤šAgentåä½œçš„åˆ†å¸ƒå¼çŠ¶æ€æœº

## å­¦ä¹ ç›®æ ‡

ğŸ—ï¸ **æ¶æ„è®¾è®¡å±‚é¢**
- å­¦ä¼šè®¾è®¡å¤šAgentç³»ç»Ÿçš„çŠ¶æ€ä¸€è‡´æ€§åè®®
- ç†è§£åˆ†å¸ƒå¼çŠ¶æ€æœºçš„ç»„åˆä¸åè°ƒæ¨¡å¼
- æŒæ¡Agenté—´æ¶ˆæ¯ä¼ é€’çš„çŠ¶æ€æœºæ¨¡å‹

âš™ï¸ **å·¥ç¨‹å®ç°å±‚é¢**
- æŒæ¡Plan-Solveæ¨¡å¼ä¸­Planningã€Executorã€Summary Agentçš„çŠ¶æ€åŒæ­¥
- å­¦ä¼šå®ç°åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„çŠ¶æ€å†²çªæ£€æµ‹ä¸è§£å†³
- æŒæ¡å¤šAgentåä½œçš„å®¹é”™ä¸æ¢å¤æœºåˆ¶

ğŸš€ **ä¼ä¸šçº§åº”ç”¨**
- ç†è§£å¤§è§„æ¨¡å¤šAgentç³»ç»Ÿçš„çŠ¶æ€ç®¡ç†ç­–ç•¥
- æŒæ¡åˆ†å¸ƒå¼çŠ¶æ€æœºçš„æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

## å¼•è¨€

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å•ä¸ªAgentï¼ˆ2.3.2ï¼‰ã€ä»»åŠ¡ï¼ˆ2.3.3ï¼‰å’Œå·¥å…·ï¼ˆ2.3.4ï¼‰çš„çŠ¶æ€æœºè®¾è®¡ã€‚ç°åœ¨æˆ‘ä»¬å°†é¢å¯¹AGIåº”ç”¨ä¸­æœ€å¤æ‚çš„çŠ¶æ€ç®¡ç†æŒ‘æˆ˜â€”â€”å¤šAgentåä½œçš„åˆ†å¸ƒå¼çŠ¶æ€æœºã€‚

å¤šAgentåä½œæ˜¯AIåº”ç”¨çš„æ ¸å¿ƒèƒ½åŠ›ä¹‹ä¸€ï¼Œå®ƒå°†å¤æ‚ä»»åŠ¡åˆ†è§£ç»™ä¸“é—¨çš„Agentæ¥å¤„ç†ï¼Œæé«˜ç³»ç»Ÿçš„ä¸“ä¸šåŒ–ç¨‹åº¦å’Œå¤„ç†æ•ˆç‡ã€‚è¿™æ­£æ˜¯2.3.1ç« èŠ‚ä¸­æåˆ°çš„**çŠ¶æ€æœºç»„åˆä¸åˆ†å±‚**åŸåˆ™åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„å…·ä½“åº”ç”¨ã€‚ç„¶è€Œï¼Œå¤šAgentç³»ç»Ÿçš„çŠ¶æ€ç®¡ç†æ¯”å•Agentå¤æ‚å¾—å¤šï¼Œéœ€è¦è§£å†³çŠ¶æ€åŒæ­¥ã€æ¶ˆæ¯åè°ƒã€æ•…éšœæ¢å¤ç­‰åˆ†å¸ƒå¼ç³»ç»Ÿçš„å…¸å‹é—®é¢˜ã€‚

åœ¨è¿™ä¸ªå¤æ‚çš„ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬éœ€è¦åº”ç”¨å‰é¢å­¦åˆ°çš„æ‰€æœ‰è®¾è®¡åŸåˆ™ï¼šæ¯ä¸ªAgentä¿æŒå…¶çŠ¶æ€çš„å•ä¸€èŒè´£ï¼ˆSRPï¼‰ï¼Œæ•´ä¸ªåä½œç³»ç»Ÿå¯¹æ‰©å±•å¼€æ”¾ã€å¯¹ä¿®æ”¹å°é—­ï¼ˆOCPï¼‰ï¼Œä¸åŒç±»å‹çš„Agentå¯ä»¥äº’ç›¸æ›¿æ¢ï¼ˆLSPï¼‰ï¼Œå„Agenté€šè¿‡æ˜ç¡®çš„æ¥å£è¿›è¡Œåä½œï¼ˆISPï¼‰ï¼Œæ•´ä¸ªç³»ç»Ÿä¾èµ–äºæŠ½è±¡çš„åä½œåè®®è€Œä¸æ˜¯å…·ä½“å®ç°ï¼ˆDIPï¼‰ã€‚

æœ¬èŠ‚å°†æ·±å…¥åˆ†æJoyAgent-JDGenieé¡¹ç›®ä¸­å¤šAgentåä½œçš„çŠ¶æ€æœºè®¾è®¡ï¼Œæ¢è®¨åˆ†å¸ƒå¼çŠ¶æ€ä¸€è‡´æ€§çš„å®ç°ç­–ç•¥ã€‚

## 1. å¤šAgentåä½œçŠ¶æ€æ¨¡å‹

åœ¨è®¾è®¡å¤šAgentåä½œçŠ¶æ€æ¨¡å‹æ—¶ï¼Œæˆ‘ä»¬é¢ä¸´çš„æŒ‘æˆ˜ä¸ä»…æ˜¯å•ä¸ªAgentçš„çŠ¶æ€ç®¡ç†ï¼Œæ›´é‡è¦çš„æ˜¯å¦‚ä½•åè°ƒå¤šä¸ªAgentçš„çŠ¶æ€è½¬æ¢ã€‚è¿™éœ€è¦å¼•å…¥ä¸€ä¸ªæ–°çš„æŠ½è±¡å±‚â€”â€”åä½œçŠ¶æ€ï¼ˆCollaboration Stateï¼‰ï¼Œå®ƒä»£è¡¨æ•´ä¸ªå¤šAgentç³»ç»Ÿçš„å…¨å±€çŠ¶æ€ï¼ŒåŒæ—¶éœ€è¦ä¸å„ä¸ªAgentçš„å±€éƒ¨çŠ¶æ€ä¿æŒä¸€è‡´æ€§ã€‚

### 1.1 åä½œçŠ¶æ€æšä¸¾è®¾è®¡

```java
/**
 * å¤šAgentåä½œçŠ¶æ€æšä¸¾
 */
public enum CollaborationState {
    INITIALIZING("initializing"),     // åˆå§‹åŒ–ï¼šåˆ›å»ºAgentå®ä¾‹ï¼Œåˆ†é…ä»»åŠ¡
    COORDINATING("coordinating"),     // åè°ƒä¸­ï¼šAgenté—´è¿›è¡Œä»»åŠ¡åå•†å’Œèµ„æºåˆ†é…
    EXECUTING("executing"),           // æ‰§è¡Œä¸­ï¼šå„Agentå¹¶è¡Œæˆ–ä¸²è¡Œæ‰§è¡Œä»»åŠ¡
    SYNCHRONIZING("synchronizing"),   // åŒæ­¥ä¸­ï¼šAgenté—´äº¤æ¢ä¸­é—´ç»“æœ
    INTEGRATING("integrating"),       // æ•´åˆä¸­ï¼šæ±‡æ€»å„Agentçš„æ‰§è¡Œç»“æœ
    COMPLETED("completed"),           // å·²å®Œæˆï¼šæ‰€æœ‰Agentä»»åŠ¡å®Œæˆï¼Œç»“æœæ•´åˆå®Œæ¯•
    FAILED("failed"),                // æ‰§è¡Œå¤±è´¥ï¼šå…³é”®Agentå¤±è´¥å¯¼è‡´æ•´ä½“ä»»åŠ¡å¤±è´¥
    PARTIAL("partial");              // éƒ¨åˆ†å®Œæˆï¼šéƒ¨åˆ†Agentå®Œæˆï¼Œå¯æ¥å—çš„ç»“æœ

    private final String value;
    
    CollaborationState(String value) {
        this.value = value;
    }
}
```

### 1.2 åä½œä¸Šä¸‹æ–‡è®¾è®¡

```java
/**
 * å¤šAgentåä½œä¸Šä¸‹æ–‡
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CollaborationContext {
    private String collaborationId;
    private String sessionId;
    private String requestId;
    
    // åä½œçŠ¶æ€
    private CollaborationState state = CollaborationState.INITIALIZING;
    private long startTime;
    private long endTime;
    private Map<String, Object> sharedData = new ConcurrentHashMap<>();
    
    // Agentç®¡ç†
    private Map<String, BaseAgent> agents = new ConcurrentHashMap<>();
    private Map<String, AgentState> agentStates = new ConcurrentHashMap<>();
    private Map<String, String> agentResults = new ConcurrentHashMap<>();
    
    // æ¶ˆæ¯é˜Ÿåˆ—
    private BlockingQueue<AgentMessage> messageQueue = new LinkedBlockingQueue<>();
    private Map<String, BlockingQueue<AgentMessage>> agentQueues = new ConcurrentHashMap<>();
    
    // åŒæ­¥æ§åˆ¶
    private CountDownLatch coordinationLatch;
    private CountDownLatch executionLatch;
    private CountDownLatch integrationLatch;
    
    // çŠ¶æ€ç›‘å¬å™¨
    private List<CollaborationStateListener> stateListeners = new ArrayList<>();
    
    /**
     * çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æ›´æ–°
     */
    public synchronized void updateCollaborationState(CollaborationState newState) {
        CollaborationState oldState = this.state;
        this.state = newState;
        
        log.info("Collaboration state transition: {} -> {} for session {}", 
            oldState, newState, sessionId);
        
        // é€šçŸ¥çŠ¶æ€ç›‘å¬å™¨
        notifyStateListeners(oldState, newState);
        
        // å¤„ç†çŠ¶æ€è½¬æ¢çš„ç‰¹æ®Šé€»è¾‘
        handleStateTransition(oldState, newState);
    }
    
    /**
     * æ›´æ–°AgentçŠ¶æ€
     */
    public synchronized void updateAgentState(String agentId, AgentState newState) {
        AgentState oldState = agentStates.put(agentId, newState);
        
        log.debug("Agent {} state updated: {} -> {}", agentId, oldState, newState);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°åä½œçŠ¶æ€
        checkCollaborationStateUpdate();
    }
    
    /**
     * æ£€æŸ¥å¹¶æ›´æ–°åä½œçŠ¶æ€
     */
    private void checkCollaborationStateUpdate() {
        List<AgentState> states = new ArrayList<>(agentStates.values());
        
        // å¦‚æœæ‰€æœ‰Agentéƒ½å®Œæˆï¼Œæ›´æ–°åä½œçŠ¶æ€
        if (states.stream().allMatch(state -> state == AgentState.FINISHED)) {
            if (this.state == CollaborationState.EXECUTING) {
                updateCollaborationState(CollaborationState.INTEGRATING);
            }
        }
        
        // å¦‚æœæœ‰å…³é”®Agentå¤±è´¥ï¼Œæ›´æ–°åä½œçŠ¶æ€
        boolean hasCriticalFailure = agents.entrySet().stream()
            .anyMatch(entry -> {
                String agentId = entry.getKey();
                BaseAgent agent = entry.getValue();
                AgentState state = agentStates.get(agentId);
                return isCriticalAgent(agent) && state == AgentState.ERROR;
            });
        
        if (hasCriticalFailure && this.state == CollaborationState.EXECUTING) {
            updateCollaborationState(CollaborationState.FAILED);
        }
    }
}
```

### 1.3 Agenté—´æ¶ˆæ¯æ¨¡å‹

```java
/**
 * Agenté—´æ¶ˆæ¯æ¨¡å‹
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AgentMessage {
    private String messageId;
    private String fromAgentId;
    private String toAgentId;
    private MessageType type;
    private String content;
    private Map<String, Object> payload = new HashMap<>();
    private long timestamp;
    private int priority = 5; // 1-10ï¼Œ1æœ€é«˜ä¼˜å…ˆçº§
    
    public enum MessageType {
        TASK_ASSIGNMENT,    // ä»»åŠ¡åˆ†é…
        RESULT_SHARING,     // ç»“æœåˆ†äº«
        STATE_UPDATE,       // çŠ¶æ€æ›´æ–°
        COORDINATION,       // åè°ƒæ¶ˆæ¯
        ERROR_NOTIFICATION, // é”™è¯¯é€šçŸ¥
        HEARTBEAT          // å¿ƒè·³æ¶ˆæ¯
    }
    
    /**
     * åˆ›å»ºä»»åŠ¡åˆ†é…æ¶ˆæ¯
     */
    public static AgentMessage taskAssignment(String from, String to, String task) {
        return AgentMessage.builder()
            .messageId(UUID.randomUUID().toString())
            .fromAgentId(from)
            .toAgentId(to)
            .type(MessageType.TASK_ASSIGNMENT)
            .content(task)
            .timestamp(System.currentTimeMillis())
            .priority(1)
            .build();
    }
    
    /**
     * åˆ›å»ºç»“æœåˆ†äº«æ¶ˆæ¯
     */
    public static AgentMessage resultSharing(String from, String to, String result) {
        return AgentMessage.builder()
            .messageId(UUID.randomUUID().toString())
            .fromAgentId(from)
            .toAgentId(to)
            .type(MessageType.RESULT_SHARING)
            .content(result)
            .timestamp(System.currentTimeMillis())
            .priority(3)
            .build();
    }
}
```

## 2. Plan-Solveåä½œæ¨¡å¼çš„çŠ¶æ€åŒæ­¥

### 2.1 Plan-Solveåä½œæµç¨‹è®¾è®¡

```java
/**
 * Plan-Solveåä½œçŠ¶æ€æœº
 */
@Component
public class PlanSolveCollaborationStateMachine {
    
    /**
     * Plan-Solveåä½œæµç¨‹çŠ¶æ€
     */
    public enum PlanSolveState {
        PLANNING_PHASE,      // è§„åˆ’é˜¶æ®µï¼šPlanning Agentå·¥ä½œ
        PLANNING_REVIEW,     // è§„åˆ’å®¡æ ¸ï¼šæ£€æŸ¥è§„åˆ’ç»“æœ
        EXECUTION_PHASE,     // æ‰§è¡Œé˜¶æ®µï¼šExecutor Agentå·¥ä½œ
        EXECUTION_MONITOR,   // æ‰§è¡Œç›‘æ§ï¼šç›‘æ§æ‰§è¡Œè¿›åº¦
        SUMMARY_PHASE,       // æ€»ç»“é˜¶æ®µï¼šSummary Agentå·¥ä½œ
        INTEGRATION,         // æ•´åˆé˜¶æ®µï¼šæ•´åˆæœ€ç»ˆç»“æœ
        COMPLETED           // å®Œæˆé˜¶æ®µ
    }
    
    @Autowired
    private CollaborationContextManager contextManager;
    
    /**
     * æ‰§è¡ŒPlan-Solveåä½œæµç¨‹
     */
    public CompletableFuture<String> executePlanSolveFlow(AgentRequest request) {
        CollaborationContext context = contextManager.createCollaborationContext(request);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                // é˜¶æ®µ1ï¼šè§„åˆ’é˜¶æ®µ
                String planningResult = executePlanningPhase(context, request);
                
                // é˜¶æ®µ2ï¼šæ‰§è¡Œé˜¶æ®µ
                String executionResult = executeExecutionPhase(context, planningResult);
                
                // é˜¶æ®µ3ï¼šæ€»ç»“é˜¶æ®µ
                String summaryResult = executeSummaryPhase(context, executionResult, request);
                
                // æ ‡è®°åä½œå®Œæˆ
                context.updateCollaborationState(CollaborationState.COMPLETED);
                
                return summaryResult;
                
            } catch (Exception e) {
                log.error("Plan-Solve collaboration failed", e);
                context.updateCollaborationState(CollaborationState.FAILED);
                throw new RuntimeException("Collaboration failed: " + e.getMessage());
            }
        });
    }
    
    /**
     * æ‰§è¡Œè§„åˆ’é˜¶æ®µ
     */
    private String executePlanningPhase(CollaborationContext context, AgentRequest request) {
        log.info("Starting planning phase for collaboration: {}", context.getCollaborationId());
        
        // åˆ›å»ºPlanning Agent
        PlanningAgent planningAgent = new PlanningAgent(context.toAgentContext());
        context.getAgents().put("planning", planningAgent);
        context.updateAgentState("planning", AgentState.IDLE);
        
        // æ›´æ–°åä½œçŠ¶æ€
        context.updateCollaborationState(CollaborationState.COORDINATING);
        
        try {
            // æ‰§è¡Œè§„åˆ’
            context.updateAgentState("planning", AgentState.RUNNING);
            String planningResult = planningAgent.run(request.getQuery());
            context.updateAgentState("planning", AgentState.FINISHED);
            
            // ä¿å­˜è§„åˆ’ç»“æœåˆ°å…±äº«æ•°æ®
            context.getSharedData().put("planning_result", planningResult);
            context.getAgentResults().put("planning", planningResult);
            
            log.info("Planning phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return planningResult;
            
        } catch (Exception e) {
            context.updateAgentState("planning", AgentState.ERROR);
            throw e;
        }
    }
    
    /**
     * æ‰§è¡Œæ‰§è¡Œé˜¶æ®µ
     */
    private String executeExecutionPhase(CollaborationContext context, String planningResult) {
        log.info("Starting execution phase for collaboration: {}", context.getCollaborationId());
        
        // åˆ›å»ºExecutor Agent
        ExecutorAgent executorAgent = new ExecutorAgent(context.toAgentContext());
        context.getAgents().put("executor", executorAgent);
        context.updateAgentState("executor", AgentState.IDLE);
        
        // æ›´æ–°åä½œçŠ¶æ€
        context.updateCollaborationState(CollaborationState.EXECUTING);
        
        try {
            // è§£æè§„åˆ’ç»“æœä¸ºä»»åŠ¡åˆ—è¡¨
            List<String> tasks = parsePlanningResult(planningResult);
            StringBuilder executionResults = new StringBuilder();
            
            int stepIdx = 0;
            int maxSteps = getMaxExecutionSteps();
            
            while (stepIdx < maxSteps && !tasks.isEmpty()) {
                context.updateAgentState("executor", AgentState.RUNNING);
                
                String currentTask = tasks.get(0);
                String taskResult = executorAgent.run(currentTask);
                
                executionResults.append(taskResult).append("\n");
                tasks.remove(0);
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­æ‰§è¡Œ
                if (executorAgent.getState() == AgentState.FINISHED) {
                    break;
                }
                
                stepIdx++;
            }
            
            context.updateAgentState("executor", AgentState.FINISHED);
            
            // ä¿å­˜æ‰§è¡Œç»“æœåˆ°å…±äº«æ•°æ®
            String finalExecutionResult = executionResults.toString();
            context.getSharedData().put("execution_result", finalExecutionResult);
            context.getAgentResults().put("executor", finalExecutionResult);
            
            log.info("Execution phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return finalExecutionResult;
            
        } catch (Exception e) {
            context.updateAgentState("executor", AgentState.ERROR);
            throw e;
        }
    }
    
    /**
     * æ‰§è¡Œæ€»ç»“é˜¶æ®µ
     */
    private String executeSummaryPhase(CollaborationContext context, 
                                     String executionResult, AgentRequest request) {
        log.info("Starting summary phase for collaboration: {}", context.getCollaborationId());
        
        // åˆ›å»ºSummary Agent
        SummaryAgent summaryAgent = new SummaryAgent(context.toAgentContext());
        summaryAgent.setSystemPrompt(
            summaryAgent.getSystemPrompt().replace("{{query}}", request.getQuery()));
        
        context.getAgents().put("summary", summaryAgent);
        context.updateAgentState("summary", AgentState.IDLE);
        
        // æ›´æ–°åä½œçŠ¶æ€
        context.updateCollaborationState(CollaborationState.INTEGRATING);
        
        try {
            context.updateAgentState("summary", AgentState.RUNNING);
            
            // æ„å»ºæ€»ç»“ä»»åŠ¡
            String summaryTask = buildSummaryTask(context, executionResult, request);
            String summaryResult = summaryAgent.run(summaryTask);
            
            context.updateAgentState("summary", AgentState.FINISHED);
            
            // ä¿å­˜æ€»ç»“ç»“æœ
            context.getSharedData().put("summary_result", summaryResult);
            context.getAgentResults().put("summary", summaryResult);
            
            log.info("Summary phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return summaryResult;
            
        } catch (Exception e) {
            context.updateAgentState("summary", AgentState.ERROR);
            throw e;
        }
    }
}
```

### 2.2 AgentçŠ¶æ€åŒæ­¥æœºåˆ¶

```java
/**
 * AgentçŠ¶æ€åŒæ­¥ç®¡ç†å™¨
 */
@Component
public class AgentStateSynchronizer {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final String STATE_SYNC_CHANNEL = "agent_state_sync";
    private final Map<String, CollaborationContext> collaborationContexts = 
        new ConcurrentHashMap<>();
    
    /**
     * çŠ¶æ€åŒæ­¥æ¶ˆæ¯
     */
    @Data
    @Builder
    public static class StateSyncMessage {
        private String collaborationId;
        private String agentId;
        private AgentState oldState;
        private AgentState newState;
        private long timestamp;
        private String nodeId;
        private Map<String, Object> metadata = new HashMap<>();
    }
    
    /**
     * å¹¿æ’­AgentçŠ¶æ€æ›´æ–°
     */
    public void broadcastStateUpdate(String collaborationId, String agentId, 
                                   AgentState oldState, AgentState newState) {
        StateSyncMessage message = StateSyncMessage.builder()
            .collaborationId(collaborationId)
            .agentId(agentId)
            .oldState(oldState)
            .newState(newState)
            .timestamp(System.currentTimeMillis())
            .nodeId(getNodeId())
            .build();
        
        try {
            redisTemplate.convertAndSend(STATE_SYNC_CHANNEL, message);
            log.debug("Broadcasted state update: {} {} -> {}", 
                agentId, oldState, newState);
        } catch (Exception e) {
            log.error("Failed to broadcast state update", e);
        }
    }
    
    /**
     * ç›‘å¬çŠ¶æ€åŒæ­¥æ¶ˆæ¯
     */
    @RedisMessageListener(STATE_SYNC_CHANNEL)
    public void handleStateSyncMessage(StateSyncMessage message) {
        if (getNodeId().equals(message.getNodeId())) {
            // å¿½ç•¥æœ¬èŠ‚ç‚¹å‘é€çš„æ¶ˆæ¯
            return;
        }
        
        CollaborationContext context = collaborationContexts.get(message.getCollaborationId());
        if (context != null) {
            // æ›´æ–°æœ¬åœ°çŠ¶æ€
            context.updateAgentState(message.getAgentId(), message.getNewState());
            
            log.debug("Received state update from remote node: {} {} -> {}", 
                message.getAgentId(), message.getOldState(), message.getNewState());
        }
    }
    
    /**
     * æ£€æŸ¥çŠ¶æ€ä¸€è‡´æ€§
     */
    public StateConsistencyReport checkStateConsistency(String collaborationId) {
        CollaborationContext localContext = collaborationContexts.get(collaborationId);
        if (localContext == null) {
            return StateConsistencyReport.notFound(collaborationId);
        }
        
        // ä»Redisè·å–åˆ†å¸ƒå¼çŠ¶æ€
        Map<String, AgentState> distributedStates = getDistributedStates(collaborationId);
        Map<String, AgentState> localStates = localContext.getAgentStates();
        
        List<StateInconsistency> inconsistencies = new ArrayList<>();
        
        // æ£€æŸ¥æœ¬åœ°çŠ¶æ€ä¸åˆ†å¸ƒå¼çŠ¶æ€çš„ä¸€è‡´æ€§
        for (Map.Entry<String, AgentState> entry : localStates.entrySet()) {
            String agentId = entry.getKey();
            AgentState localState = entry.getValue();
            AgentState distributedState = distributedStates.get(agentId);
            
            if (distributedState != null && !localState.equals(distributedState)) {
                inconsistencies.add(StateInconsistency.builder()
                    .agentId(agentId)
                    .localState(localState)
                    .distributedState(distributedState)
                    .build());
            }
        }
        
        return StateConsistencyReport.builder()
            .collaborationId(collaborationId)
            .consistent(inconsistencies.isEmpty())
            .inconsistencies(inconsistencies)
            .checkTime(System.currentTimeMillis())
            .build();
    }
    
    /**
     * è§£å†³çŠ¶æ€ä¸ä¸€è‡´
     */
    public void resolveStateInconsistency(String collaborationId, String agentId) {
        CollaborationContext context = collaborationContexts.get(collaborationId);
        if (context == null) {
            return;
        }
        
        // é‡‡ç”¨æœ€åå†™å…¥è·èƒœç­–ç•¥
        Map<String, AgentState> distributedStates = getDistributedStates(collaborationId);
        AgentState distributedState = distributedStates.get(agentId);
        
        if (distributedState != null) {
            context.updateAgentState(agentId, distributedState);
            log.info("Resolved state inconsistency for agent {}: updated to {}", 
                agentId, distributedState);
        }
    }
    
    private Map<String, AgentState> getDistributedStates(String collaborationId) {
        String key = "collaboration_states:" + collaborationId;
        
        try {
            Map<Object, Object> rawStates = redisTemplate.opsForHash().entries(key);
            Map<String, AgentState> states = new HashMap<>();
            
            for (Map.Entry<Object, Object> entry : rawStates.entrySet()) {
                String agentId = (String) entry.getKey();
                String stateName = (String) entry.getValue();
                AgentState state = AgentState.valueOf(stateName);
                states.put(agentId, state);
            }
            
            return states;
            
        } catch (Exception e) {
            log.error("Failed to get distributed states", e);
            return new HashMap<>();
        }
    }
}
```

## 3. Agenté—´æ¶ˆæ¯ä¼ é€’çŠ¶æ€æœº

### 3.1 æ¶ˆæ¯è·¯ç”±ä¸åˆ†å‘æœºåˆ¶

```java
/**
 * Agentæ¶ˆæ¯è·¯ç”±å™¨
 */
@Component
public class AgentMessageRouter {
    
    /**
     * æ¶ˆæ¯è·¯ç”±çŠ¶æ€
     */
    public enum RoutingState {
        PENDING,     // å¾…è·¯ç”±
        ROUTING,     // è·¯ç”±ä¸­
        DELIVERED,   // å·²é€è¾¾
        FAILED,      // è·¯ç”±å¤±è´¥
        EXPIRED      // æ¶ˆæ¯è¿‡æœŸ
    }
    
    /**
     * æ¶ˆæ¯è·¯ç”±ä¸Šä¸‹æ–‡
     */
    @Data
    @Builder
    public static class MessageRoutingContext {
        private String messageId;
        private AgentMessage message;
        private RoutingState state;
        private List<String> routingPath = new ArrayList<>();
        private int retryCount;
        private long expirationTime;
        private String errorMessage;
    }
    
    private final Map<String, BlockingQueue<AgentMessage>> agentQueues = 
        new ConcurrentHashMap<>();
    private final Map<String, MessageRoutingContext> routingContexts = 
        new ConcurrentHashMap<>();
    private final ScheduledExecutorService routingExecutor = 
        Executors.newScheduledThreadPool(5);
    
    /**
     * å‘é€æ¶ˆæ¯
     */
    public CompletableFuture<Boolean> sendMessage(AgentMessage message) {
        MessageRoutingContext context = MessageRoutingContext.builder()
            .messageId(message.getMessageId())
            .message(message)
            .state(RoutingState.PENDING)
            .expirationTime(System.currentTimeMillis() + getMessageTTL(message))
            .build();
        
        routingContexts.put(message.getMessageId(), context);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                return routeMessage(context);
            } catch (Exception e) {
                log.error("Message routing failed: {}", message.getMessageId(), e);
                context.setState(RoutingState.FAILED);
                context.setErrorMessage(e.getMessage());
                return false;
            }
        });
    }
    
    /**
     * è·¯ç”±æ¶ˆæ¯åˆ°ç›®æ ‡Agent
     */
    private boolean routeMessage(MessageRoutingContext context) {
        AgentMessage message = context.getMessage();
        context.setState(RoutingState.ROUTING);
        context.getRoutingPath().add(getCurrentNodeId());
        
        String targetAgentId = message.getToAgentId();
        
        // æ£€æŸ¥ç›®æ ‡Agentæ˜¯å¦åœ¨æœ¬åœ°
        BlockingQueue<AgentMessage> targetQueue = agentQueues.get(targetAgentId);
        
        if (targetQueue != null) {
            // æœ¬åœ°æŠ•é€’
            return deliverMessageLocally(context, targetQueue);
        } else {
            // è¿œç¨‹æŠ•é€’
            return deliverMessageRemotely(context);
        }
    }
    
    /**
     * æœ¬åœ°æ¶ˆæ¯æŠ•é€’
     */
    private boolean deliverMessageLocally(MessageRoutingContext context, 
                                        BlockingQueue<AgentMessage> targetQueue) {
        try {
            AgentMessage message = context.getMessage();
            
            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦è¿‡æœŸ
            if (System.currentTimeMillis() > context.getExpirationTime()) {
                context.setState(RoutingState.EXPIRED);
                return false;
            }
            
            // æŠ•é€’æ¶ˆæ¯
            boolean delivered = targetQueue.offer(message, 5, TimeUnit.SECONDS);
            
            if (delivered) {
                context.setState(RoutingState.DELIVERED);
                log.debug("Message {} delivered locally to agent {}", 
                    message.getMessageId(), message.getToAgentId());
                return true;
            } else {
                // é˜Ÿåˆ—æ»¡ï¼Œé‡è¯•
                if (context.getRetryCount() < 3) {
                    context.setRetryCount(context.getRetryCount() + 1);
                    scheduleRetry(context);
                    return false;
                } else {
                    context.setState(RoutingState.FAILED);
                    context.setErrorMessage("Target agent queue is full");
                    return false;
                }
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            context.setState(RoutingState.FAILED);
            context.setErrorMessage("Message delivery interrupted");
            return false;
        }
    }
    
    /**
     * è¿œç¨‹æ¶ˆæ¯æŠ•é€’
     */
    private boolean deliverMessageRemotely(MessageRoutingContext context) {
        try {
            AgentMessage message = context.getMessage();
            String targetAgentId = message.getToAgentId();
            
            // æŸ¥æ‰¾ç›®æ ‡Agentæ‰€åœ¨èŠ‚ç‚¹
            String targetNodeId = findAgentNode(targetAgentId);
            
            if (targetNodeId == null) {
                context.setState(RoutingState.FAILED);
                context.setErrorMessage("Target agent not found: " + targetAgentId);
                return false;
            }
            
            // å‘é€åˆ°ç›®æ ‡èŠ‚ç‚¹
            boolean sent = sendToRemoteNode(message, targetNodeId);
            
            if (sent) {
                context.setState(RoutingState.DELIVERED);
                context.getRoutingPath().add(targetNodeId);
                log.debug("Message {} sent to remote node {} for agent {}", 
                    message.getMessageId(), targetNodeId, targetAgentId);
                return true;
            } else {
                context.setState(RoutingState.FAILED);
                context.setErrorMessage("Failed to send to remote node: " + targetNodeId);
                return false;
            }
            
        } catch (Exception e) {
            context.setState(RoutingState.FAILED);
            context.setErrorMessage("Remote delivery failed: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * å®‰æ’æ¶ˆæ¯é‡è¯•
     */
    private void scheduleRetry(MessageRoutingContext context) {
        long delay = calculateRetryDelay(context.getRetryCount());
        
        routingExecutor.schedule(() -> {
            if (context.getState() != RoutingState.EXPIRED) {
                routeMessage(context);
            }
        }, delay, TimeUnit.MILLISECONDS);
    }
    
    /**
     * æ³¨å†ŒAgentæ¶ˆæ¯é˜Ÿåˆ—
     */
    public void registerAgent(String agentId) {
        agentQueues.put(agentId, new PriorityBlockingQueue<>(100, 
            Comparator.comparingInt(AgentMessage::getPriority)));
        log.debug("Registered message queue for agent: {}", agentId);
    }
    
    /**
     * æ³¨é”€Agentæ¶ˆæ¯é˜Ÿåˆ—
     */
    public void unregisterAgent(String agentId) {
        BlockingQueue<AgentMessage> queue = agentQueues.remove(agentId);
        if (queue != null) {
            // å¤„ç†é˜Ÿåˆ—ä¸­å‰©ä½™çš„æ¶ˆæ¯
            handleRemainingMessages(agentId, queue);
        }
        log.debug("Unregistered message queue for agent: {}", agentId);
    }
}
```

### 3.2 æ¶ˆæ¯å¤„ç†çŠ¶æ€æœº

```java
/**
 * Agentæ¶ˆæ¯å¤„ç†å™¨
 */
@Component
public class AgentMessageProcessor {
    
    /**
     * æ¶ˆæ¯å¤„ç†çŠ¶æ€
     */
    public enum ProcessingState {
        RECEIVED,       // å·²æ¥æ”¶
        VALIDATING,     // éªŒè¯ä¸­
        PROCESSING,     // å¤„ç†ä¸­
        RESPONDING,     // å“åº”ä¸­
        COMPLETED,      // å¤„ç†å®Œæˆ
        FAILED          // å¤„ç†å¤±è´¥
    }
    
    /**
     * æ¶ˆæ¯å¤„ç†ä¸Šä¸‹æ–‡
     */
    @Data
    @Builder
    public static class MessageProcessingContext {
        private String messageId;
        private String agentId;
        private AgentMessage message;
        private ProcessingState state;
        private long startTime;
        private long endTime;
        private String response;
        private String errorMessage;
        private Map<String, Object> processingData = new HashMap<>();
    }
    
    private final Map<String, MessageProcessingContext> processingContexts = 
        new ConcurrentHashMap<>();
    
    /**
     * å¤„ç†Agentæ¶ˆæ¯
     */
    public CompletableFuture<String> processMessage(String agentId, AgentMessage message) {
        MessageProcessingContext context = MessageProcessingContext.builder()
            .messageId(message.getMessageId())
            .agentId(agentId)
            .message(message)
            .state(ProcessingState.RECEIVED)
            .startTime(System.currentTimeMillis())
            .build();
        
        processingContexts.put(message.getMessageId(), context);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                return processMessageInternal(context);
            } catch (Exception e) {
                log.error("Message processing failed", e);
                context.setState(ProcessingState.FAILED);
                context.setErrorMessage(e.getMessage());
                context.setEndTime(System.currentTimeMillis());
                return null;
            }
        });
    }
    
    /**
     * å†…éƒ¨æ¶ˆæ¯å¤„ç†é€»è¾‘
     */
    private String processMessageInternal(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        // 1. éªŒè¯æ¶ˆæ¯
        context.setState(ProcessingState.VALIDATING);
        if (!validateMessage(message)) {
            context.setState(ProcessingState.FAILED);
            context.setErrorMessage("Message validation failed");
            return null;
        }
        
        // 2. å¤„ç†æ¶ˆæ¯
        context.setState(ProcessingState.PROCESSING);
        String response = handleMessageByType(context);
        
        // 3. ç”Ÿæˆå“åº”
        context.setState(ProcessingState.RESPONDING);
        if (response != null) {
            context.setResponse(response);
            context.setState(ProcessingState.COMPLETED);
        } else {
            context.setState(ProcessingState.FAILED);
            context.setErrorMessage("No response generated");
        }
        
        context.setEndTime(System.currentTimeMillis());
        
        return response;
    }
    
    /**
     * æ ¹æ®æ¶ˆæ¯ç±»å‹å¤„ç†æ¶ˆæ¯
     */
    private String handleMessageByType(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        
        switch (message.getType()) {
            case TASK_ASSIGNMENT:
                return handleTaskAssignment(context);
                
            case RESULT_SHARING:
                return handleResultSharing(context);
                
            case STATE_UPDATE:
                return handleStateUpdate(context);
                
            case COORDINATION:
                return handleCoordination(context);
                
            case ERROR_NOTIFICATION:
                return handleErrorNotification(context);
                
            case HEARTBEAT:
                return handleHeartbeat(context);
                
            default:
                log.warn("Unknown message type: {}", message.getType());
                return null;
        }
    }
    
    /**
     * å¤„ç†ä»»åŠ¡åˆ†é…æ¶ˆæ¯
     */
    private String handleTaskAssignment(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        log.info("Agent {} received task assignment: {}", agentId, message.getContent());
        
        // è·å–Agentå®ä¾‹
        BaseAgent agent = getAgent(agentId);
        if (agent == null) {
            context.setErrorMessage("Agent not found: " + agentId);
            return null;
        }
        
        try {
            // åˆ†é…ä»»åŠ¡ç»™Agent
            String result = agent.run(message.getContent());
            
            // å‘é€ç»“æœåˆ†äº«æ¶ˆæ¯ç»™å‘é€è€…
            AgentMessage responseMessage = AgentMessage.resultSharing(
                agentId, message.getFromAgentId(), result);
            
            messageRouter.sendMessage(responseMessage);
            
            return "Task accepted and executed";
            
        } catch (Exception e) {
            log.error("Task execution failed for agent: " + agentId, e);
            context.setErrorMessage("Task execution failed: " + e.getMessage());
            
            // å‘é€é”™è¯¯é€šçŸ¥
            AgentMessage errorMessage = AgentMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .fromAgentId(agentId)
                .toAgentId(message.getFromAgentId())
                .type(AgentMessage.MessageType.ERROR_NOTIFICATION)
                .content("Task execution failed: " + e.getMessage())
                .timestamp(System.currentTimeMillis())
                .build();
            
            messageRouter.sendMessage(errorMessage);
            
            return null;
        }
    }
    
    /**
     * å¤„ç†ç»“æœåˆ†äº«æ¶ˆæ¯
     */
    private String handleResultSharing(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        log.info("Agent {} received result sharing from {}: {}", 
            agentId, message.getFromAgentId(), message.getContent());
        
        // å°†ç»“æœä¿å­˜åˆ°åä½œä¸Šä¸‹æ–‡
        CollaborationContext collabContext = getCollaborationContext(agentId);
        if (collabContext != null) {
            collabContext.getAgentResults().put(message.getFromAgentId(), message.getContent());
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¿…éœ€çš„ç»“æœéƒ½å·²æ”¶åˆ°
            if (areAllRequiredResultsReceived(collabContext)) {
                // è§¦å‘ä¸‹ä¸€é˜¶æ®µçš„åä½œ
                triggerNextCollaborationPhase(collabContext);
            }
        }
        
        return "Result received and processed";
    }
}
```

## 4. åˆ†å¸ƒå¼çŠ¶æ€å†²çªæ£€æµ‹ä¸è§£å†³

### 4.1 çŠ¶æ€å†²çªæ£€æµ‹æœºåˆ¶

```java
/**
 * åˆ†å¸ƒå¼çŠ¶æ€å†²çªæ£€æµ‹å™¨
 */
@Component
public class DistributedStateConflictDetector {
    
    /**
     * çŠ¶æ€å†²çªç±»å‹
     */
    public enum ConflictType {
        STATE_MISMATCH,     // çŠ¶æ€ä¸åŒ¹é…
        VERSION_CONFLICT,   // ç‰ˆæœ¬å†²çª
        TIMING_CONFLICT,    // æ—¶åºå†²çª
        RESOURCE_CONFLICT   // èµ„æºå†²çª
    }
    
    /**
     * çŠ¶æ€å†²çªæè¿°
     */
    @Data
    @Builder
    public static class StateConflict {
        private String conflictId;
        private ConflictType type;
        private String collaborationId;
        private String agentId;
        private String description;
        
        // å†²çªè¯¦æƒ…
        private Object localValue;
        private Object remoteValue;
        private long localTimestamp;
        private long remoteTimestamp;
        private String localNodeId;
        private String remoteNodeId;
        
        // è§£å†³çŠ¶æ€
        private boolean resolved;
        private String resolutionStrategy;
        private long resolvedTime;
    }
    
    private final List<StateConflictResolver> conflictResolvers = new ArrayList<>();
    private final Map<String, StateConflict> activeConflicts = new ConcurrentHashMap<>();
    
    /**
     * æ£€æµ‹çŠ¶æ€å†²çª
     */
    @Scheduled(fixedRate = 10000) // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
    public void detectStateConflicts() {
        for (CollaborationContext context : collaborationManager.getAllActiveCollaborations()) {
            try {
                List<StateConflict> conflicts = checkCollaborationConflicts(context);
                
                for (StateConflict conflict : conflicts) {
                    if (!activeConflicts.containsKey(conflict.getConflictId())) {
                        activeConflicts.put(conflict.getConflictId(), conflict);
                        log.warn("Detected state conflict: {}", conflict.getDescription());
                        
                        // å°è¯•è‡ªåŠ¨è§£å†³å†²çª
                        resolveConflictAsync(conflict);
                    }
                }
            } catch (Exception e) {
                log.error("Error during conflict detection", e);
            }
        }
    }
    
    /**
     * æ£€æŸ¥åä½œä¸­çš„çŠ¶æ€å†²çª
     */
    private List<StateConflict> checkCollaborationConflicts(CollaborationContext context) {
        List<StateConflict> conflicts = new ArrayList<>();
        String collaborationId = context.getCollaborationId();
        
        // è·å–åˆ†å¸ƒå¼çŠ¶æ€å¿«ç…§
        Map<String, StateSnapshot> distributedSnapshots = getDistributedStateSnapshots(collaborationId);
        
        for (Map.Entry<String, AgentState> entry : context.getAgentStates().entrySet()) {
            String agentId = entry.getKey();
            AgentState localState = entry.getValue();
            
            StateSnapshot remoteSnapshot = distributedSnapshots.get(agentId);
            if (remoteSnapshot != null) {
                
                // æ£€æŸ¥çŠ¶æ€ä¸åŒ¹é…
                if (!localState.equals(remoteSnapshot.getState())) {
                    conflicts.add(StateConflict.builder()
                        .conflictId(UUID.randomUUID().toString())
                        .type(ConflictType.STATE_MISMATCH)
                        .collaborationId(collaborationId)
                        .agentId(agentId)
                        .description(String.format("State mismatch for agent %s: local=%s, remote=%s", 
                            agentId, localState, remoteSnapshot.getState()))
                        .localValue(localState)
                        .remoteValue(remoteSnapshot.getState())
                        .localTimestamp(System.currentTimeMillis())
                        .remoteTimestamp(remoteSnapshot.getTimestamp())
                        .localNodeId(getCurrentNodeId())
                        .remoteNodeId(remoteSnapshot.getNodeId())
                        .build());
                }
                
                // æ£€æŸ¥ç‰ˆæœ¬å†²çª
                if (hasVersionConflict(context, agentId, remoteSnapshot)) {
                    conflicts.add(createVersionConflict(context, agentId, remoteSnapshot));
                }
            }
        }
        
        return conflicts;
    }
    
    /**
     * å¼‚æ­¥è§£å†³çŠ¶æ€å†²çª
     */
    private void resolveConflictAsync(StateConflict conflict) {
        CompletableFuture.runAsync(() -> {
            try {
                boolean resolved = false;
                
                // å°è¯•ä½¿ç”¨å„ç§è§£å†³ç­–ç•¥
                for (StateConflictResolver resolver : conflictResolvers) {
                    if (resolver.canResolve(conflict)) {
                        resolved = resolver.resolve(conflict);
                        if (resolved) {
                            conflict.setResolved(true);
                            conflict.setResolutionStrategy(resolver.getStrategyName());
                            conflict.setResolvedTime(System.currentTimeMillis());
                            
                            log.info("Resolved state conflict using strategy: {}", 
                                resolver.getStrategyName());
                            break;
                        }
                    }
                }
                
                if (!resolved) {
                    log.warn("Failed to resolve state conflict: {}", conflict.getConflictId());
                    // å¯ä»¥è€ƒè™‘äººå·¥ä»‹å…¥æˆ–å…¶ä»–é™çº§ç­–ç•¥
                }
                
            } catch (Exception e) {
                log.error("Error during conflict resolution", e);
            }
        });
    }
}
```

### 4.2 çŠ¶æ€å†²çªè§£å†³ç­–ç•¥

```java
/**
 * çŠ¶æ€å†²çªè§£å†³å™¨æ¥å£
 */
public interface StateConflictResolver {
    boolean canResolve(StateConflict conflict);
    boolean resolve(StateConflict conflict);
    String getStrategyName();
    int getPriority(); // ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
}

/**
 * æœ€åå†™å…¥è·èƒœè§£å†³å™¨
 */
@Component
public class LastWriteWinsResolver implements StateConflictResolver {
    
    @Override
    public boolean canResolve(StateConflict conflict) {
        return conflict.getType() == ConflictType.STATE_MISMATCH;
    }
    
    @Override
    public boolean resolve(StateConflict conflict) {
        try {
            // æ¯”è¾ƒæ—¶é—´æˆ³ï¼Œé€‰æ‹©æœ€æ–°çš„çŠ¶æ€
            if (conflict.getRemoteTimestamp() > conflict.getLocalTimestamp()) {
                // è¿œç¨‹çŠ¶æ€æ›´æ–°ï¼Œæ›´æ–°æœ¬åœ°çŠ¶æ€
                updateLocalState(conflict.getCollaborationId(), 
                                conflict.getAgentId(), 
                                (AgentState) conflict.getRemoteValue());
                
                log.info("Applied remote state for agent {}: {}", 
                    conflict.getAgentId(), conflict.getRemoteValue());
            } else {
                // æœ¬åœ°çŠ¶æ€æ›´æ–°ï¼Œå¹¿æ’­åˆ°å…¶ä»–èŠ‚ç‚¹
                broadcastStateUpdate(conflict.getCollaborationId(), 
                                   conflict.getAgentId(), 
                                   (AgentState) conflict.getLocalValue());
                
                log.info("Broadcasted local state for agent {}: {}", 
                    conflict.getAgentId(), conflict.getLocalValue());
            }
            
            return true;
            
        } catch (Exception e) {
            log.error("Failed to resolve conflict using LastWriteWins strategy", e);
            return false;
        }
    }
    
    @Override
    public String getStrategyName() {
        return "LastWriteWins";
    }
    
    @Override
    public int getPriority() {
        return 10; // è¾ƒä½ä¼˜å…ˆçº§ï¼Œä½œä¸ºé»˜è®¤ç­–ç•¥
    }
}

/**
 * ä¸šåŠ¡ä¼˜å…ˆçº§è§£å†³å™¨
 */
@Component
public class BusinessPriorityResolver implements StateConflictResolver {
    
    @Override
    public boolean canResolve(StateConflict conflict) {
        return conflict.getType() == ConflictType.STATE_MISMATCH && 
               isCriticalAgent(conflict.getAgentId());
    }
    
    @Override
    public boolean resolve(StateConflict conflict) {
        try {
            String agentId = conflict.getAgentId();
            AgentState localState = (AgentState) conflict.getLocalValue();
            AgentState remoteState = (AgentState) conflict.getRemoteValue();
            
            // åŸºäºä¸šåŠ¡è§„åˆ™é€‰æ‹©çŠ¶æ€
            AgentState chosenState = chooseStateByBusinessRules(agentId, localState, remoteState);
            
            if (chosenState.equals(localState)) {
                // ä¿æŒæœ¬åœ°çŠ¶æ€ï¼Œå¹¿æ’­æ›´æ–°
                broadcastStateUpdate(conflict.getCollaborationId(), agentId, localState);
            } else {
                // é‡‡ç”¨è¿œç¨‹çŠ¶æ€ï¼Œæ›´æ–°æœ¬åœ°
                updateLocalState(conflict.getCollaborationId(), agentId, remoteState);
            }
            
            log.info("Resolved conflict using business priority: agent={}, chosen_state={}", 
                agentId, chosenState);
            
            return true;
            
        } catch (Exception e) {
            log.error("Failed to resolve conflict using BusinessPriority strategy", e);
            return false;
        }
    }
    
    private AgentState chooseStateByBusinessRules(String agentId, AgentState local, AgentState remote) {
        // ä¸šåŠ¡è§„åˆ™ï¼šå¦‚æœä»»ä¸€çŠ¶æ€ä¸ºERRORï¼Œä¼˜å…ˆé€‰æ‹©ERRORçŠ¶æ€
        if (local == AgentState.ERROR || remote == AgentState.ERROR) {
            return local == AgentState.ERROR ? local : remote;
        }
        
        // ä¸šåŠ¡è§„åˆ™ï¼šä¼˜å…ˆé€‰æ‹©æ›´"è¿›æ­¥"çš„çŠ¶æ€
        int localProgress = getStateProgress(local);
        int remoteProgress = getStateProgress(remote);
        
        return localProgress >= remoteProgress ? local : remote;
    }
    
    private int getStateProgress(AgentState state) {
        switch (state) {
            case IDLE: return 0;
            case RUNNING: return 1;
            case FINISHED: return 2;
            case ERROR: return -1;
            default: return 0;
        }
    }
    
    @Override
    public String getStrategyName() {
        return "BusinessPriority";
    }
    
    @Override
    public int getPriority() {
        return 5; // é«˜ä¼˜å…ˆçº§
    }
}
```

## 5. å°ç»“

æœ¬èŠ‚æ·±å…¥æ¢è®¨äº†å¤šAgentåä½œçš„åˆ†å¸ƒå¼çŠ¶æ€æœºè®¾è®¡ä¸å®ç°ï¼š

1. **åä½œçŠ¶æ€æ¨¡å‹**ï¼šè®¾è®¡äº†å¤šAgentç³»ç»Ÿçš„åä½œçŠ¶æ€å’ŒåŒæ­¥æœºåˆ¶
2. **Plan-Solveåä½œ**ï¼šå®ç°äº†Planningã€Executorã€Summary Agentçš„çŠ¶æ€åè°ƒæµç¨‹
3. **æ¶ˆæ¯ä¼ é€’çŠ¶æ€æœº**ï¼šå»ºç«‹äº†Agenté—´æ¶ˆæ¯è·¯ç”±å’Œå¤„ç†çš„çŠ¶æ€ç®¡ç†
4. **çŠ¶æ€å†²çªæ£€æµ‹**ï¼šæä¾›äº†åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„çŠ¶æ€ä¸€è‡´æ€§æ£€æµ‹å’Œè§£å†³æ–¹æ¡ˆ

è¿™äº›æŠ€æœ¯ä¿è¯äº†å¤šAgentç³»ç»Ÿåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„å¯é åä½œï¼Œä¸ºå¤æ‚AIåº”ç”¨çš„æ¨ªå‘æ‰©å±•æä¾›äº†æŠ€æœ¯åŸºç¡€ã€‚

## å»¶ä¼¸æ€è€ƒ

1. å¦‚ä½•ä¼˜åŒ–å¤šAgentç³»ç»Ÿçš„æ¶ˆæ¯ä¼ é€’æ€§èƒ½ï¼Ÿ
2. å¦‚ä½•å®ç°Agentçš„åŠ¨æ€å‘ç°å’Œè´Ÿè½½å‡è¡¡ï¼Ÿ
3. å¦‚ä½•è®¾è®¡æ›´æ™ºèƒ½çš„çŠ¶æ€å†²çªé¢„æµ‹å’Œé¢„é˜²æœºåˆ¶ï¼Ÿ
4. å¦‚ä½•åœ¨ç½‘ç»œåˆ†åŒºæƒ…å†µä¸‹ä¿è¯ç³»ç»Ÿçš„å¯ç”¨æ€§ï¼Ÿ

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†æ¢è®¨å‰åç«¯çŠ¶æ€åŒæ­¥ä¸å®æ—¶é€šä¿¡çŠ¶æ€æœºçš„å…·ä½“å®ç°ã€‚
