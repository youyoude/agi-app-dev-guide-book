# 2.3.6 前后端状态同步与实时通信状态机

## 学习目标

🏗️ **架构设计层面**
- 理解前后端状态同步的整体架构设计
- 掌握实时通信状态机与业务状态机的协调模式
- 学会设计状态同步协议和数据格式

⚙️ **工程实现层面**
- 掌握WebSocket连接的状态机设计（连接、断开、重连、心跳）
- 学会实现前端聊天状态与后端执行状态的双向同步
- 理解SSE（Server-Sent Events）流式响应的状态管理
- 掌握实时任务进度更新的状态机实现模式

🚀 **企业级应用**
- 掌握大规模实时通信的状态管理策略
- 理解状态同步的性能优化和容错机制

## 引言

在前面的章节中，我们学习了后端各种状态机的设计：Agent状态机（2.3.2）、任务状态机（2.3.3）、工具状态机（2.3.4）和多Agent协作状态机（2.3.5）。现在我们需要将这些后端状态有效地同步到前端，为用户提供实时的状态反馈。

前后端状态同步是AI应用用户体验的关键因素，特别是在长时间执行的AI任务中，用户需要实时了解任务进度、Agent状态和执行结果。这个同步过程本身也是一个复杂的状态管理问题，涉及网络连接状态、数据传输状态、UI渲染状态等多个层面。

在JoyAgent-JDGenie项目中，我们采用了WebSocket和SSE技术来实现实时通信，并应用2.3.1章节中的**状态机分层与组合**原则：通信状态机负责连接管理，业务状态机负责数据同步，UI状态机负责界面更新。每个层面都遵循前面学到的设计原则，确保整个系统的可靠性和可维护性。

本节将深入分析前后端状态同步的设计原理和实现方案。

## 1. 前端状态管理架构

### 1.1 前端聊天状态模型

```typescript
/**
 * 前端聊天状态枚举
 */
export enum ChatState {
  IDLE = 'idle',                    // 空闲状态：等待用户输入
  SENDING = 'sending',              // 发送中：用户消息正在发送
  PROCESSING = 'processing',        // 处理中：后端正在处理请求
  STREAMING = 'streaming',          // 流式响应：接收实时数据流
  COMPLETED = 'completed',          // 已完成：任务执行完毕
  ERROR = 'error',                  // 错误状态：处理过程中出现错误
  TIMEOUT = 'timeout',              // 超时状态：请求超时
  CANCELLED = 'cancelled'           // 已取消：用户主动取消任务
}

/**
 * 任务状态枚举 - 与后端保持一致
 */
export enum TaskStatus {
  PENDING = 0,      // 待处理
  RUNNING = 1,      // 执行中
  COMPLETED = 2,    // 已完成
  FAILED = 3,       // 失败
  CANCELLED = 4     // 取消
}

/**
 * 聊天项目状态接口
 */
export interface ChatItem {
  query: string;
  files?: File[];
  responseType: "txt" | "json" | "stream";
  sessionId: string;
  requestId: string;
  loading: boolean;
  forceStop: boolean;
  
  // 任务相关状态
  tasks: MESSAGE.Task[][];
  taskStatus: TaskStatus;
  thought: string;
  response: string;
  
  // 多Agent相关状态
  multiAgent: {
    tasks: MESSAGE.Task[][];
  };
  
  // 计划相关状态
  plan?: CHAT.Plan;
  planList?: CHAT.PlanItem[];
  conclusion?: any;
}
```

### 1.2 前端状态机实现

```typescript
/**
 * 聊天状态机管理器
 */
class ChatStateMachine {
  private state: ChatState = ChatState.IDLE;
  private chatItem: ChatItem | null = null;
  private listeners: Map<string, (state: ChatState) => void> = new Map();
  private stateHistory: Array<{state: ChatState, timestamp: number}> = [];
  
  /**
   * 状态转换验证
   */
  private isValidTransition(from: ChatState, to: ChatState): boolean {
    const validTransitions: Record<ChatState, ChatState[]> = {
      [ChatState.IDLE]: [ChatState.SENDING, ChatState.ERROR],
      [ChatState.SENDING]: [ChatState.PROCESSING, ChatState.ERROR, ChatState.TIMEOUT],
      [ChatState.PROCESSING]: [ChatState.STREAMING, ChatState.COMPLETED, ChatState.ERROR, ChatState.TIMEOUT],
      [ChatState.STREAMING]: [ChatState.COMPLETED, ChatState.ERROR, ChatState.CANCELLED],
      [ChatState.COMPLETED]: [ChatState.IDLE],
      [ChatState.ERROR]: [ChatState.IDLE],
      [ChatState.TIMEOUT]: [ChatState.IDLE, ChatState.SENDING],
      [ChatState.CANCELLED]: [ChatState.IDLE]
    };
    
    return validTransitions[from]?.includes(to) ?? false;
  }
  
  /**
   * 状态转换
   */
  public transitionTo(newState: ChatState, context?: any): boolean {
    if (!this.isValidTransition(this.state, newState)) {
      console.warn(`Invalid state transition: ${this.state} -> ${newState}`);
      return false;
    }
    
    const oldState = this.state;
    this.state = newState;
    
    // 记录状态历史
    this.stateHistory.push({
      state: newState,
      timestamp: Date.now()
    });
    
    console.log(`Chat state transition: ${oldState} -> ${newState}`);
    
    // 通知监听器
    this.notifyListeners(newState);
    
    // 执行状态进入逻辑
    this.onStateEnter(newState, context);
    
    return true;
  }
  
  /**
   * 状态进入处理
   */
  private onStateEnter(state: ChatState, context?: any): void {
    switch (state) {
      case ChatState.SENDING:
        this.handleSendingState();
        break;
      case ChatState.PROCESSING:
        this.handleProcessingState();
        break;
      case ChatState.STREAMING:
        this.handleStreamingState();
        break;
      case ChatState.COMPLETED:
        this.handleCompletedState();
        break;
      case ChatState.ERROR:
        this.handleErrorState(context);
        break;
      case ChatState.TIMEOUT:
        this.handleTimeoutState();
        break;
      case ChatState.CANCELLED:
        this.handleCancelledState();
        break;
    }
  }
  
  /**
   * 处理发送中状态
   */
  private handleSendingState(): void {
    if (this.chatItem) {
      this.chatItem.loading = true;
      this.chatItem.forceStop = false;
    }
  }
  
  /**
   * 处理流式响应状态
   */
  private handleStreamingState(): void {
    // 启动心跳检测，确保连接活跃
    this.startHeartbeat();
    
    // 重置强制停止标志
    if (this.chatItem) {
      this.chatItem.forceStop = false;
    }
  }
  
  /**
   * 处理完成状态
   */
  private handleCompletedState(): void {
    this.stopHeartbeat();
    
    if (this.chatItem) {
      this.chatItem.loading = false;
      this.chatItem.taskStatus = TaskStatus.COMPLETED;
    }
    
    // 延时转换到空闲状态
    setTimeout(() => {
      this.transitionTo(ChatState.IDLE);
    }, 1000);
  }
  
  /**
   * 处理错误状态
   */
  private handleErrorState(error?: any): void {
    this.stopHeartbeat();
    
    if (this.chatItem) {
      this.chatItem.loading = false;
      this.chatItem.taskStatus = TaskStatus.FAILED;
    }
    
    console.error('Chat state error:', error);
    
    // 显示错误通知
    this.showErrorNotification(error);
  }
  
  private heartbeatTimer: NodeJS.Timeout | null = null;
  
  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      // 发送心跳或检查连接状态
      this.checkConnectionHealth();
    }, 30000); // 每30秒检查一次
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
}
```

### 1.3 消息状态组合与处理

```typescript
/**
 * 消息状态组合处理器
 */
export const combineData = (
  eventData: MESSAGE.EventData,
  currentChat: CHAT.ChatItem
): CHAT.ChatItem => {
  
  const messageType = eventData.messageType;
  
  switch (messageType) {
    case "plan":
      return handlePlanMessage(eventData, currentChat);
    case "plan_thought":
      return handlePlanThoughtMessage(eventData, currentChat);
    case "task":
      return handleTaskMessage(eventData, currentChat);
    case "content":
      return handleContentMessage(eventData, currentChat);
    case "code":
      return handleCodeMessage(eventData, currentChat);
    case "deep_search":
      return handleDeepSearchMessage(eventData, currentChat);
    case "result":
      return handleResultMessage(eventData, currentChat);
    default:
      console.warn("Unknown message type:", messageType);
      return currentChat;
  }
};

/**
 * 处理计划类型消息
 */
function handlePlanMessage(eventData: MESSAGE.EventData, currentChat: CHAT.ChatItem): CHAT.ChatItem {
  const plan = eventData.plan;
  if (plan) {
    currentChat.plan = plan;
    
    // 构建计划项目列表
    currentChat.planList = plan.stages?.reduce(
      (result: CHAT.PlanItem[], stage: string, index: number) => {
        const group = result.find((item) => item.name === stage);
        if (group) {
          group.list.push(plan.steps[index] || "");
        } else {
          result.push({
            name: stage,
            list: [plan.steps[index] || ""],
          });
        }
        return result;
      },
      []
    );
    
    // 更新任务状态
    if (plan.stepStatus) {
      const completedCount = plan.stepStatus.filter(status => status === "completed").length;
      const totalCount = plan.stepStatus.length;
      
      if (completedCount === totalCount) {
        currentChat.taskStatus = TaskStatus.COMPLETED;
      } else if (completedCount > 0) {
        currentChat.taskStatus = TaskStatus.RUNNING;
      } else {
        currentChat.taskStatus = TaskStatus.PENDING;
      }
    }
  }
  
  return currentChat;
}

/**
 * 处理内容消息
 */
function handleContentMessage(eventData: MESSAGE.EventData, currentChat: CHAT.ChatItem): CHAT.ChatItem {
  const taskIndex = findTaskIndex(currentChat.multiAgent.tasks, eventData.taskId);
  const toolIndex = taskIndex !== -1 ? findToolIndex(
    currentChat.multiAgent.tasks[taskIndex], 
    eventData.taskId
  ) : -1;
  
  if (taskIndex !== -1) {
    if (toolIndex !== -1) {
      // 更新现有工具执行结果
      const tool = currentChat.multiAgent.tasks[taskIndex][toolIndex];
      
      if (eventData.resultMap.resultMap.isFinal) {
        // 最终结果
        tool.resultMap = {
          ...eventData.resultMap.resultMap,
          codeOutput: eventData.resultMap.resultMap.data,
        };
        
        // 更新工具状态
        tool.status = TaskStatus.COMPLETED;
      } else {
        // 中间结果
        tool.resultMap.isFinal = false;
        tool.resultMap.codeOutput = (tool.resultMap.codeOutput || "") + 
          (eventData.resultMap.resultMap?.data || "");
        
        // 更新工具状态
        tool.status = TaskStatus.RUNNING;
      }
    } else {
      // 添加新的工具执行
      const newTool: MESSAGE.Task = {
        taskId: eventData.taskId,
        messageType: eventData.messageType,
        status: eventData.resultMap.resultMap.isFinal ? TaskStatus.COMPLETED : TaskStatus.RUNNING,
        ...eventData.resultMap,
      };
      
      currentChat.multiAgent.tasks[taskIndex].push(newTool);
    }
  } else {
    // 添加新的任务组
    const newTask: MESSAGE.Task = {
      taskId: eventData.taskId,
      messageType: eventData.messageType,
      status: eventData.resultMap.resultMap.isFinal ? TaskStatus.COMPLETED : TaskStatus.RUNNING,
      ...eventData.resultMap,
    };
    
    currentChat.multiAgent.tasks.push([newTask]);
  }
  
  return currentChat;
}
```

## 2. WebSocket连接状态机

### 2.1 WebSocket连接状态设计

```typescript
/**
 * WebSocket连接状态枚举
 */
export enum WebSocketState {
  DISCONNECTED = 'disconnected',     // 未连接
  CONNECTING = 'connecting',         // 连接中
  CONNECTED = 'connected',           // 已连接
  RECONNECTING = 'reconnecting',     // 重连中
  ERROR = 'error',                   // 连接错误
  CLOSING = 'closing',               // 关闭中
  CLOSED = 'closed'                  // 已关闭
}

/**
 * WebSocket状态机管理器
 */
class WebSocketStateMachine {
  private state: WebSocketState = WebSocketState.DISCONNECTED;
  private websocket: WebSocket | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelay: number = 1000;
  private heartbeatInterval: number = 30000;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private lastHeartbeat: number = 0;
  
  constructor(private url: string, private onMessage?: (data: any) => void) {}
  
  /**
   * 连接WebSocket
   */
  public connect(): Promise<void> {
    if (this.state === WebSocketState.CONNECTED || 
        this.state === WebSocketState.CONNECTING) {
      return Promise.resolve();
    }
    
    this.transitionTo(WebSocketState.CONNECTING);
    
    return new Promise((resolve, reject) => {
      try {
        this.websocket = new WebSocket(this.url);
        
        this.websocket.onopen = (event) => {
          this.transitionTo(WebSocketState.CONNECTED);
          this.reconnectAttempts = 0;
          this.startHeartbeat();
          resolve();
        };
        
        this.websocket.onmessage = (event) => {
          this.handleMessage(event);
        };
        
        this.websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.transitionTo(WebSocketState.ERROR);
          reject(error);
        };
        
        this.websocket.onclose = (event) => {
          this.handleClose(event);
        };
        
        // 连接超时处理
        setTimeout(() => {
          if (this.state === WebSocketState.CONNECTING) {
            this.transitionTo(WebSocketState.ERROR);
            reject(new Error('Connection timeout'));
          }
        }, 10000);
        
      } catch (error) {
        this.transitionTo(WebSocketState.ERROR);
        reject(error);
      }
    });
  }
  
  /**
   * 发送消息
   */
  public sendMessage(message: any): boolean {
    if (this.state !== WebSocketState.CONNECTED || !this.websocket) {
      console.warn('WebSocket not connected, message not sent');
      return false;
    }
    
    try {
      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);
      this.websocket.send(messageStr);
      return true;
    } catch (error) {
      console.error('Failed to send WebSocket message:', error);
      this.transitionTo(WebSocketState.ERROR);
      return false;
    }
  }
  
  /**
   * 关闭连接
   */
  public close(): void {
    if (this.state === WebSocketState.DISCONNECTED || 
        this.state === WebSocketState.CLOSED) {
      return;
    }
    
    this.transitionTo(WebSocketState.CLOSING);
    this.stopHeartbeat();
    
    if (this.websocket) {
      this.websocket.close();
    }
  }
  
  /**
   * 状态转换
   */
  private transitionTo(newState: WebSocketState): void {
    const oldState = this.state;
    this.state = newState;
    
    console.log(`WebSocket state transition: ${oldState} -> ${newState}`);
    
    // 状态变更处理
    this.onStateChange(oldState, newState);
  }
  
  /**
   * 处理状态变更
   */
  private onStateChange(from: WebSocketState, to: WebSocketState): void {
    switch (to) {
      case WebSocketState.CONNECTED:
        console.log('WebSocket connected successfully');
        break;
        
      case WebSocketState.ERROR:
        console.error('WebSocket entered error state');
        this.stopHeartbeat();
        this.scheduleReconnect();
        break;
        
      case WebSocketState.CLOSED:
        console.log('WebSocket connection closed');
        this.stopHeartbeat();
        this.scheduleReconnect();
        break;
    }
  }
  
  /**
   * 处理消息接收
   */
  private handleMessage(event: MessageEvent): void {
    this.lastHeartbeat = Date.now();
    
    try {
      const data = JSON.parse(event.data);
      
      // 检查是否是心跳响应
      if (data.type === 'heartbeat') {
        return; // 心跳消息不需要进一步处理
      }
      
      // 调用消息处理回调
      if (this.onMessage) {
        this.onMessage(data);
      }
      
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error);
    }
  }
  
  /**
   * 处理连接关闭
   */
  private handleClose(event: CloseEvent): void {
    const wasConnected = this.state === WebSocketState.CONNECTED;
    
    this.transitionTo(WebSocketState.CLOSED);
    
    // 如果是非正常关闭且之前已连接，尝试重连
    if (event.code !== 1000 && wasConnected) {
      this.scheduleReconnect();
    }
  }
  
  /**
   * 安排重连
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnect attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // 指数退避
    
    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    setTimeout(() => {
      if (this.state === WebSocketState.CLOSED || this.state === WebSocketState.ERROR) {
        this.transitionTo(WebSocketState.RECONNECTING);
        this.connect().catch(error => {
          console.error('Reconnect failed:', error);
        });
      }
    }, delay);
  }
  
  /**
   * 启动心跳
   */
  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.lastHeartbeat = Date.now();
    
    this.heartbeatTimer = setInterval(() => {
      if (this.state === WebSocketState.CONNECTED) {
        // 发送心跳消息
        this.sendMessage({ type: 'heartbeat', timestamp: Date.now() });
        
        // 检查心跳超时
        const now = Date.now();
        if (now - this.lastHeartbeat > this.heartbeatInterval * 2) {
          console.warn('Heartbeat timeout detected');
          this.transitionTo(WebSocketState.ERROR);
        }
      }
    }, this.heartbeatInterval);
  }
  
  /**
   * 停止心跳
   */
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
}
```

## 3. SSE流式响应状态管理

### 3.1 SSE连接状态机

```typescript
/**
 * SSE（Server-Sent Events）状态机管理器
 */
class SSEStateMachine {
  private state: 'idle' | 'connecting' | 'connected' | 'error' | 'closed' = 'idle';
  private eventSource: EventSource | null = null;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 3;
  
  constructor(
    private url: string,
    private onMessage: (data: any) => void,
    private onError?: (error: Event) => void,
    private onClose?: () => void
  ) {}
  
  /**
   * 开始SSE连接
   */
  public start(params: Record<string, any>): void {
    if (this.state === 'connected' || this.state === 'connecting') {
      return;
    }
    
    this.state = 'connecting';
    
    // 构建查询参数
    const queryString = new URLSearchParams(params).toString();
    const fullUrl = `${this.url}?${queryString}`;
    
    try {
      this.eventSource = new EventSource(fullUrl);
      
      this.eventSource.onopen = (event) => {
        this.state = 'connected';
        this.reconnectAttempts = 0;
        console.log('SSE connection opened');
      };
      
      this.eventSource.onmessage = (event) => {
        this.handleMessage(event);
      };
      
      this.eventSource.onerror = (error) => {
        this.handleError(error);
      };
      
    } catch (error) {
      console.error('Failed to create SSE connection:', error);
      this.state = 'error';
      if (this.onError) {
        this.onError(error as Event);
      }
    }
  }
  
  /**
   * 停止SSE连接
   */
  public stop(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    this.state = 'closed';
    
    if (this.onClose) {
      this.onClose();
    }
  }
  
  /**
   * 处理SSE消息
   */
  private handleMessage(event: MessageEvent): void {
    try {
      // 解析JSON数据
      const data = JSON.parse(event.data);
      
      // 检查消息状态
      if (data.finished === true) {
        console.log('SSE stream finished');
        this.stop();
        return;
      }
      
      // 检查特殊状态
      if (data.status === "tokenUseUp") {
        console.warn('Token usage limit reached');
        this.stop();
        // 可以触发特殊处理逻辑
        return;
      }
      
      // 处理正常消息
      if (data.packageType !== "heartbeat") {
        this.onMessage(data);
      }
      
    } catch (error) {
      console.error('Failed to parse SSE message:', event.data, error);
    }
  }
  
  /**
   * 处理SSE错误
   */
  private handleError(error: Event): void {
    console.error('SSE connection error:', error);
    this.state = 'error';
    
    if (this.onError) {
      this.onError(error);
    }
    
    // 尝试重连
    this.scheduleReconnect();
  }
  
  /**
   * 安排重连
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max SSE reconnect attempts reached');
      this.state = 'closed';
      return;
    }
    
    this.reconnectAttempts++;
    const delay = 1000 * Math.pow(2, this.reconnectAttempts - 1); // 指数退避
    
    console.log(`Scheduling SSE reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    this.reconnectTimer = setTimeout(() => {
      if (this.state === 'error') {
        this.start({}); // 需要传递原始参数
      }
    }, delay);
  }
  
  /**
   * 获取当前状态
   */
  public getState(): string {
    return this.state;
  }
  
  /**
   * 是否连接中
   */
  public isConnected(): boolean {
    return this.state === 'connected';
  }
}
```

### 3.2 流式数据处理状态机

```typescript
/**
 * 流式数据处理状态机
 */
class StreamDataProcessor {
  private processingState: 'idle' | 'processing' | 'paused' | 'completed' | 'error' = 'idle';
  private dataBuffer: any[] = [];
  private processTimer: NodeJS.Timeout | null = null;
  
  constructor(
    private onDataProcessed: (data: any) => void,
    private onComplete?: () => void,
    private onError?: (error: any) => void
  ) {}
  
  /**
   * 添加数据到处理队列
   */
  public addData(data: any): void {
    this.dataBuffer.push({
      data,
      timestamp: Date.now(),
      id: Math.random().toString(36).substr(2, 9)
    });
    
    if (this.processingState === 'idle') {
      this.startProcessing();
    }
  }
  
  /**
   * 开始处理数据
   */
  private startProcessing(): void {
    if (this.processingState !== 'idle') {
      return;
    }
    
    this.processingState = 'processing';
    this.processNextBatch();
  }
  
  /**
   * 处理下一批数据
   */
  private processNextBatch(): void {
    if (this.processingState !== 'processing') {
      return;
    }
    
    if (this.dataBuffer.length === 0) {
      this.processingState = 'idle';
      return;
    }
    
    // 批量处理数据，避免界面阻塞
    const batchSize = Math.min(5, this.dataBuffer.length);
    const batch = this.dataBuffer.splice(0, batchSize);
    
    try {
      // 处理当前批次
      batch.forEach(item => {
        this.onDataProcessed(item.data);
      });
      
      // 安排下一批次处理
      this.processTimer = setTimeout(() => {
        this.processNextBatch();
      }, 10); // 10ms间隔，保证界面响应性
      
    } catch (error) {
      console.error('Error processing stream data:', error);
      this.processingState = 'error';
      
      if (this.onError) {
        this.onError(error);
      }
    }
  }
  
  /**
   * 暂停处理
   */
  public pause(): void {
    if (this.processingState === 'processing') {
      this.processingState = 'paused';
      
      if (this.processTimer) {
        clearTimeout(this.processTimer);
        this.processTimer = null;
      }
    }
  }
  
  /**
   * 恢复处理
   */
  public resume(): void {
    if (this.processingState === 'paused') {
      this.processingState = 'processing';
      this.processNextBatch();
    }
  }
  
  /**
   * 停止处理
   */
  public stop(): void {
    this.processingState = 'completed';
    
    if (this.processTimer) {
      clearTimeout(this.processTimer);
      this.processTimer = null;
    }
    
    // 清空缓冲区
    this.dataBuffer = [];
    
    if (this.onComplete) {
      this.onComplete();
    }
  }
  
  /**
   * 获取处理状态
   */
  public getState(): string {
    return this.processingState;
  }
  
  /**
   * 获取缓冲区大小
   */
  public getBufferSize(): number {
    return this.dataBuffer.length;
  }
}
```

## 4. 后端流式响应状态管理

### 4.1 SSE响应状态控制器

```java
/**
 * SSE响应状态控制器
 */
@RestController
public class SSEResponseController {
    
    /**
     * SSE响应状态枚举
     */
    public enum SSEResponseState {
        INITIALIZING,    // 初始化中
        STREAMING,       // 流式响应中
        PAUSED,         // 暂停响应
        COMPLETED,      // 响应完成
        ERROR,          // 响应错误
        CANCELLED       // 响应取消
    }
    
    /**
     * SSE响应上下文
     */
    @Data
    @Builder
    public static class SSEResponseContext {
        private String responseId;
        private String sessionId;
        private String requestId;
        private SSEResponseState state;
        private SseEmitter emitter;
        private long startTime;
        private long lastSendTime;
        private AtomicLong messageCount;
        private volatile boolean cancelled;
    }
    
    private final Map<String, SSEResponseContext> responseContexts = new ConcurrentHashMap<>();
    private final ScheduledExecutorService heartbeatExecutor = Executors.newScheduledThreadPool(2);
    
    /**
     * 创建SSE流式响应
     */
    @GetMapping("/api/stream")
    public SseEmitter createStreamResponse(
            @RequestParam String sessionId,
            @RequestParam String requestId,
            @RequestParam String query,
            @RequestParam(defaultValue = "0") Integer deepThink,
            @RequestParam(required = false) String outputStyle) {
        
        String responseId = UUID.randomUUID().toString();
        SseEmitter emitter = new SseEmitter(300000L); // 5分钟超时
        
        SSEResponseContext context = SSEResponseContext.builder()
            .responseId(responseId)
            .sessionId(sessionId)
            .requestId(requestId)
            .state(SSEResponseState.INITIALIZING)
            .emitter(emitter)
            .startTime(System.currentTimeMillis())
            .messageCount(new AtomicLong(0))
            .cancelled(false)
            .build();
        
        responseContexts.put(responseId, context);
        
        // 设置SSE事件处理
        setupSSEEventHandlers(context);
        
        // 异步处理请求
        CompletableFuture.runAsync(() -> {
            processStreamingRequest(context, query, deepThink, outputStyle);
        });
        
        return emitter;
    }
    
    /**
     * 设置SSE事件处理器
     */
    private void setupSSEEventHandlers(SSEResponseContext context) {
        SseEmitter emitter = context.getEmitter();
        
        // 完成事件
        emitter.onCompletion(() -> {
            context.setState(SSEResponseState.COMPLETED);
            responseContexts.remove(context.getResponseId());
            log.info("SSE response completed: {}", context.getResponseId());
        });
        
        // 超时事件
        emitter.onTimeout(() -> {
            context.setState(SSEResponseState.ERROR);
            responseContexts.remove(context.getResponseId());
            log.warn("SSE response timeout: {}", context.getResponseId());
        });
        
        // 错误事件
        emitter.onError((ex) -> {
            context.setState(SSEResponseState.ERROR);
            responseContexts.remove(context.getResponseId());
            log.error("SSE response error: " + context.getResponseId(), ex);
        });
        
        // 启动心跳
        startHeartbeat(context);
    }
    
    /**
     * 处理流式请求
     */
    private void processStreamingRequest(SSEResponseContext context, 
                                       String query, Integer deepThink, String outputStyle) {
        try {
            context.setState(SSEResponseState.STREAMING);
            
            // 构建Agent请求
            AgentRequest request = new AgentRequest();
            request.setSessionId(context.getSessionId());
            request.setRequestId(context.getRequestId());
            request.setQuery(query);
            
            // 创建消息处理器
            StreamMessageHandler messageHandler = new StreamMessageHandler(context);
            
            // 执行Agent处理
            agentHandlerService.handleAsync(request, messageHandler);
            
        } catch (Exception e) {
            log.error("Error processing streaming request", e);
            sendErrorMessage(context, "Processing failed: " + e.getMessage());
        }
    }
    
    /**
     * 流式消息处理器
     */
    private class StreamMessageHandler {
        private final SSEResponseContext context;
        
        public StreamMessageHandler(SSEResponseContext context) {
            this.context = context;
        }
        
        /**
         * 处理Agent消息
         */
        public void handleMessage(String messageType, Object data) {
            if (context.isCancelled() || context.getState() != SSEResponseState.STREAMING) {
                return;
            }
            
            try {
                // 构建SSE消息
                Map<String, Object> message = new HashMap<>();
                message.put("requestId", context.getRequestId());
                message.put("messageType", messageType);
                message.put("data", data);
                message.put("timestamp", System.currentTimeMillis());
                message.put("finished", false);
                
                // 发送消息
                sendMessage(context, message);
                
            } catch (Exception e) {
                log.error("Error handling stream message", e);
                sendErrorMessage(context, "Message handling failed: " + e.getMessage());
            }
        }
        
        /**
         * 处理完成消息
         */
        public void handleCompletion(String result) {
            Map<String, Object> message = new HashMap<>();
            message.put("requestId", context.getRequestId());
            message.put("messageType", "result");
            message.put("result", result);
            message.put("finished", true);
            message.put("timestamp", System.currentTimeMillis());
            
            sendMessage(context, message);
            completeResponse(context);
        }
        
        /**
         * 处理错误消息
         */
        public void handleError(String error) {
            sendErrorMessage(context, error);
        }
    }
    
    /**
     * 发送SSE消息
     */
    private void sendMessage(SSEResponseContext context, Object data) {
        if (context.isCancelled()) {
            return;
        }
        
        try {
            SseEmitter.SseEventBuilder eventBuilder = SseEmitter.event()
                .data(data)
                .id(context.getMessageCount().incrementAndGet());
            
            context.getEmitter().send(eventBuilder);
            context.setLastSendTime(System.currentTimeMillis());
            
        } catch (IOException e) {
            log.error("Failed to send SSE message", e);
            context.setState(SSEResponseState.ERROR);
            context.setCancelled(true);
        }
    }
    
    /**
     * 发送错误消息
     */
    private void sendErrorMessage(SSEResponseContext context, String error) {
        Map<String, Object> errorMessage = new HashMap<>();
        errorMessage.put("error", true);
        errorMessage.put("message", error);
        errorMessage.put("finished", true);
        
        sendMessage(context, errorMessage);
        context.setState(SSEResponseState.ERROR);
    }
    
    /**
     * 完成响应
     */
    private void completeResponse(SSEResponseContext context) {
        try {
            context.setState(SSEResponseState.COMPLETED);
            context.getEmitter().complete();
        } catch (IOException e) {
            log.error("Failed to complete SSE response", e);
        }
    }
    
    /**
     * 启动心跳
     */
    private void startHeartbeat(SSEResponseContext context) {
        heartbeatExecutor.scheduleAtFixedRate(() -> {
            if (context.getState() == SSEResponseState.STREAMING && !context.isCancelled()) {
                // 检查是否需要发送心跳
                long now = System.currentTimeMillis();
                if (now - context.getLastSendTime() > 30000) { // 30秒无消息则发送心跳
                    Map<String, Object> heartbeat = new HashMap<>();
                    heartbeat.put("packageType", "heartbeat");
                    heartbeat.put("timestamp", now);
                    
                    sendMessage(context, heartbeat);
                }
            }
        }, 30, 30, TimeUnit.SECONDS);
    }
}
```

## 5. 前后端状态同步最佳实践

### 5.1 状态同步协议设计

```typescript
/**
 * 前后端状态同步协议
 */
export interface StateSyncProtocol {
  // 状态同步消息类型
  type: 'state_sync' | 'state_request' | 'state_response';
  
  // 同步范围
  scope: 'chat' | 'task' | 'agent' | 'global';
  
  // 状态数据
  state: {
    sessionId: string;
    requestId?: string;
    agentId?: string;
    currentState: string;
    previousState?: string;
    timestamp: number;
    version: number;
  };
  
  // 同步元数据
  metadata?: {
    source: 'frontend' | 'backend';
    reliable: boolean;
    priority: number;
  };
}

/**
 * 状态同步管理器
 */
class StateSyncManager {
  private syncQueue: StateSyncProtocol[] = [];
  private syncTimer: NodeJS.Timeout | null = null;
  private lastSyncTime: number = 0;
  private syncInterval: number = 5000; // 5秒同步间隔
  
  constructor(
    private websocket: WebSocketStateMachine,
    private onStateUpdate: (state: any) => void
  ) {
    this.startSyncTimer();
  }
  
  /**
   * 请求状态同步
   */
  public requestStateSync(scope: string, identifier: string): void {
    const syncMessage: StateSyncProtocol = {
      type: 'state_request',
      scope: scope as any,
      state: {
        sessionId: identifier,
        currentState: 'unknown',
        timestamp: Date.now(),
        version: 0
      },
      metadata: {
        source: 'frontend',
        reliable: true,
        priority: 1
      }
    };
    
    this.sendSyncMessage(syncMessage);
  }
  
  /**
   * 发送状态更新
   */
  public sendStateUpdate(scope: string, state: any): void {
    const syncMessage: StateSyncProtocol = {
      type: 'state_sync',
      scope: scope as any,
      state: {
        ...state,
        timestamp: Date.now(),
        version: (state.version || 0) + 1
      },
      metadata: {
        source: 'frontend',
        reliable: false,
        priority: 3
      }
    };
    
    this.addToSyncQueue(syncMessage);
  }
  
  /**
   * 处理状态同步响应
   */
  public handleSyncResponse(message: StateSyncProtocol): void {
    if (message.type === 'state_response') {
      // 更新本地状态
      this.onStateUpdate(message.state);
      
      console.log('Received state sync response:', message.state);
    }
  }
  
  /**
   * 添加到同步队列
   */
  private addToSyncQueue(message: StateSyncProtocol): void {
    this.syncQueue.push(message);
    
    // 如果是高优先级消息，立即发送
    if (message.metadata?.priority <= 2) {
      this.flushSyncQueue();
    }
  }
  
  /**
   * 发送同步消息
   */
  private sendSyncMessage(message: StateSyncProtocol): void {
    if (this.websocket.isConnected()) {
      this.websocket.sendMessage(message);
    } else {
      console.warn('WebSocket not connected, sync message queued');
      this.addToSyncQueue(message);
    }
  }
  
  /**
   * 清空同步队列
   */
  private flushSyncQueue(): void {
    if (this.syncQueue.length === 0) {
      return;
    }
    
    const messages = this.syncQueue.splice(0);
    
    for (const message of messages) {
      this.sendSyncMessage(message);
    }
    
    this.lastSyncTime = Date.now();
  }
  
  /**
   * 启动同步定时器
   */
  private startSyncTimer(): void {
    this.syncTimer = setInterval(() => {
      this.flushSyncQueue();
    }, this.syncInterval);
  }
  
  /**
   * 停止同步定时器
   */
  public stop(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }
}
```

### 5.2 状态一致性检查

```typescript
/**
 * 状态一致性检查器
 */
class StateConsistencyChecker {
  private inconsistencies: Map<string, any> = new Map();
  private checkTimer: NodeJS.Timeout | null = null;
  
  constructor(
    private localStateManager: any,
    private syncManager: StateSyncManager
  ) {
    this.startConsistencyCheck();
  }
  
  /**
   * 检查状态一致性
   */
  public async checkConsistency(scope: string, identifier: string): Promise<boolean> {
    // 获取本地状态
    const localState = this.localStateManager.getState(scope, identifier);
    
    // 请求远程状态
    const remoteState = await this.requestRemoteState(scope, identifier);
    
    // 比较状态
    const isConsistent = this.compareStates(localState, remoteState);
    
    if (!isConsistent) {
      this.recordInconsistency(scope, identifier, localState, remoteState);
      await this.resolveInconsistency(scope, identifier, localState, remoteState);
    }
    
    return isConsistent;
  }
  
  /**
   * 请求远程状态
   */
  private async requestRemoteState(scope: string, identifier: string): Promise<any> {
    return new Promise((resolve, reject) => {
      // 发送状态请求
      this.syncManager.requestStateSync(scope, identifier);
      
      // 设置超时
      const timeout = setTimeout(() => {
        reject(new Error('Remote state request timeout'));
      }, 10000);
      
      // 监听状态响应（简化实现）
      const handleResponse = (state: any) => {
        if (state.sessionId === identifier) {
          clearTimeout(timeout);
          resolve(state);
        }
      };
      
      // 注册临时监听器
      this.syncManager.onStateUpdate = handleResponse;
    });
  }
  
  /**
   * 比较状态
   */
  private compareStates(local: any, remote: any): boolean {
    if (!local || !remote) {
      return false;
    }
    
    // 比较关键字段
    const keyFields = ['currentState', 'taskStatus', 'loading'];
    
    for (const field of keyFields) {
      if (local[field] !== remote[field]) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * 记录不一致性
   */
  private recordInconsistency(scope: string, identifier: string, local: any, remote: any): void {
    const inconsistency = {
      scope,
      identifier,
      localState: local,
      remoteState: remote,
      timestamp: Date.now()
    };
    
    this.inconsistencies.set(`${scope}:${identifier}`, inconsistency);
    
    console.warn('State inconsistency detected:', inconsistency);
  }
  
  /**
   * 解决不一致性
   */
  private async resolveInconsistency(scope: string, identifier: string, 
                                   local: any, remote: any): Promise<void> {
    // 采用时间戳优先策略
    const localTimestamp = local.timestamp || 0;
    const remoteTimestamp = remote.timestamp || 0;
    
    if (remoteTimestamp > localTimestamp) {
      // 采用远程状态
      this.localStateManager.setState(scope, identifier, remote);
      console.log('Resolved inconsistency: adopted remote state');
    } else {
      // 发送本地状态
      this.syncManager.sendStateUpdate(scope, local);
      console.log('Resolved inconsistency: sent local state');
    }
    
    // 移除记录
    this.inconsistencies.delete(`${scope}:${identifier}`);
  }
  
  /**
   * 启动一致性检查
   */
  private startConsistencyCheck(): void {
    this.checkTimer = setInterval(() => {
      // 检查所有活跃的会话状态
      const activeSessions = this.localStateManager.getActiveSessions();
      
      for (const sessionId of activeSessions) {
        this.checkConsistency('chat', sessionId).catch(error => {
          console.error('Consistency check failed:', error);
        });
      }
    }, 30000); // 每30秒检查一次
  }
  
  /**
   * 停止一致性检查
   */
  public stop(): void {
    if (this.checkTimer) {
      clearInterval(this.checkTimer);
      this.checkTimer = null;
    }
  }
}
```

## 6. 小结

本节深入探讨了前后端状态同步与实时通信状态机的关键技术：

1. **前端状态管理**：设计了聊天状态和任务状态的统一管理模型
2. **WebSocket状态机**：实现了可靠的WebSocket连接管理和自动重连机制
3. **SSE流式响应**：建立了服务端流式数据推送的状态控制系统
4. **状态同步协议**：定义了前后端状态同步的标准化协议和一致性检查机制

这些技术确保了AI应用中前后端状态的实时同步和一致性，为用户提供了流畅的交互体验。

## 延伸思考

1. 如何优化大量并发用户的状态同步性能？
2. 如何实现离线状态的本地缓存和恢复机制？
3. 如何处理网络不稳定环境下的状态同步问题？
4. 如何设计更智能的冲突解决策略？

下一节我们将通过企业级AI应用案例来分析状态机架构的实际应用。
