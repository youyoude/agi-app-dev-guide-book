# 2.1.4 流式通信的可靠性保障

**学习目标：** 掌握保障流式通信稳定性的关键技术，学会处理各种异常情况

## 心跳机制的设计与实现

### 心跳机制的核心作用

心跳机制是保障长连接稳定性的关键技术，主要解决以下问题：

1. **连接活性检测**：及时发现连接断开
2. **中间设备保活**：防止代理服务器或防火墙关闭空闲连接
3. **网络状态监控**：监测网络延迟和质量
4. **资源清理触发**：为异常情况下的资源清理提供信号

### 服务端心跳实现

让我们分析项目中的心跳机制实现：

```java
@RestController
public class GenieController {
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
    private static final long HEARTBEAT_INTERVAL = 10_000L; // 10秒心跳间隔

    /**
     * 启动SSE心跳机制
     */
    private ScheduledFuture<?> startHeartbeat(SseEmitter emitter, String requestId) {
        return executor.scheduleAtFixedRate(() -> {
            try {
                // 发送心跳消息
                log.info("{} 发送心跳", requestId);
                emitter.send("heartbeat");
            } catch (Exception e) {
                // 发送心跳失败，说明连接已断开
                log.error("{} 心跳发送失败，关闭连接", requestId, e);
                emitter.completeWithError(e);
            }
        }, HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL, TimeUnit.MILLISECONDS);
    }

    /**
     * 注册SSE事件监听器
     */
    private void registerSSEMonitor(SseEmitter emitter, String requestId, ScheduledFuture<?> heartbeatFuture) {
        // 正常完成监听
        emitter.onCompletion(() -> {
            log.info("{} SSE连接正常完成", requestId);
            heartbeatFuture.cancel(true);
            // 清理相关资源
            cleanupResources(requestId);
        });

        // 超时监听
        emitter.onTimeout(() -> {
            log.info("{} SSE连接超时", requestId);
            heartbeatFuture.cancel(true);
            emitter.complete();
        });

        // 错误监听
        emitter.onError((ex) -> {
            log.info("{} SSE连接错误: ", requestId, ex);
            heartbeatFuture.cancel(true);
            emitter.completeWithError(ex);
        });
    }

    private void cleanupResources(String requestId) {
        // 清理缓存数据
        // 释放临时文件
        // 停止后台任务等
    }
}
```

### 客户端心跳处理

客户端需要正确处理服务端发送的心跳消息，并监控心跳的连续性：

```typescript
class HeartbeatMonitor {
    private lastHeartbeatTime: number = Date.now();
    private heartbeatTimeout: NodeJS.Timeout | null = null;
    private maxHeartbeatInterval: number;
    private onHeartbeatTimeout: () => void;

    constructor(maxInterval: number = 30000, onTimeout: () => void) {
        this.maxHeartbeatInterval = maxInterval;
        this.onHeartbeatTimeout = onTimeout;
        this.startMonitoring();
    }

    // 接收到心跳时调用
    onHeartbeatReceived() {
        this.lastHeartbeatTime = Date.now();
        this.resetTimeout();
    }

    private startMonitoring() {
        this.resetTimeout();
    }

    private resetTimeout() {
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }

        this.heartbeatTimeout = setTimeout(() => {
            const timeSinceLastHeartbeat = Date.now() - this.lastHeartbeatTime;
            
            if (timeSinceLastHeartbeat > this.maxHeartbeatInterval) {
                console.warn(`心跳超时: ${timeSinceLastHeartbeat}ms`);
                this.onHeartbeatTimeout();
            }
        }, this.maxHeartbeatInterval);
    }

    stop() {
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }
    }

    getLastHeartbeatTime(): number {
        return this.lastHeartbeatTime;
    }

    isHealthy(): boolean {
        return (Date.now() - this.lastHeartbeatTime) < this.maxHeartbeatInterval;
    }
}
```

### 双向心跳机制

在需要检测客户端状态的场景中，可以实现双向心跳：

```typescript
class BidirectionalHeartbeat {
    private sendInterval: NodeJS.Timeout | null = null;
    private receiveMonitor: HeartbeatMonitor;
    private sendHeartbeat: () => void;

    constructor(
        sendIntervalMs: number = 30000,
        maxReceiveIntervalMs: number = 45000,
        sendCallback: () => void,
        onReceiveTimeout: () => void
    ) {
        this.sendHeartbeat = sendCallback;
        this.receiveMonitor = new HeartbeatMonitor(maxReceiveIntervalMs, onReceiveTimeout);
        
        // 启动发送心跳
        this.startSending(sendIntervalMs);
    }

    private startSending(intervalMs: number) {
        this.sendInterval = setInterval(() => {
            try {
                this.sendHeartbeat();
            } catch (error) {
                console.error('发送心跳失败:', error);
            }
        }, intervalMs);
    }

    onHeartbeatReceived() {
        this.receiveMonitor.onHeartbeatReceived();
    }

    stop() {
        if (this.sendInterval) {
            clearInterval(this.sendInterval);
        }
        this.receiveMonitor.stop();
    }

    getStatus() {
        return {
            isHealthy: this.receiveMonitor.isHealthy(),
            lastHeartbeatTime: this.receiveMonitor.getLastHeartbeatTime()
        };
    }
}
```

## 连接断线重连策略

### 指数退避重连算法

```typescript
interface ReconnectConfig {
    initialDelay: number;        // 初始重连延迟
    maxDelay: number;           // 最大重连延迟
    maxRetries: number;         // 最大重连次数
    backoffMultiplier: number;  // 退避倍数
    jitterRange: number;        // 抖动范围（0-1）
}

class ExponentialBackoffReconnect {
    private config: ReconnectConfig;
    private retryCount: number = 0;
    private reconnectTimer: NodeJS.Timeout | null = null;
    private isReconnecting: boolean = false;

    constructor(config: ReconnectConfig) {
        this.config = config;
    }

    async attemptReconnect(connectFn: () => Promise<void>): Promise<boolean> {
        if (this.isReconnecting || this.retryCount >= this.config.maxRetries) {
            return false;
        }

        this.isReconnecting = true;
        
        try {
            // 计算延迟时间
            const delay = this.calculateDelay();
            console.log(`第${this.retryCount + 1}次重连，延迟${delay}ms`);
            
            // 等待延迟
            await this.sleep(delay);
            
            // 尝试连接
            await connectFn();
            
            // 连接成功，重置重试计数
            this.retryCount = 0;
            this.isReconnecting = false;
            return true;
            
        } catch (error) {
            this.retryCount++;
            this.isReconnecting = false;
            
            console.error(`第${this.retryCount}次重连失败:`, error);
            
            if (this.retryCount >= this.config.maxRetries) {
                console.error('达到最大重连次数，停止重连');
                return false;
            }
            
            // 递归重试
            return this.attemptReconnect(connectFn);
        }
    }

    private calculateDelay(): number {
        // 基础延迟：初始延迟 * (退避倍数 ^ 重试次数)
        let delay = this.config.initialDelay * Math.pow(this.config.backoffMultiplier, this.retryCount);
        
        // 限制最大延迟
        delay = Math.min(delay, this.config.maxDelay);
        
        // 添加随机抖动，避免雷群效应
        if (this.config.jitterRange > 0) {
            const jitter = delay * this.config.jitterRange * Math.random();
            delay += jitter;
        }
        
        return Math.round(delay);
    }

    private sleep(ms: number): Promise<void> {
        return new Promise(resolve => {
            this.reconnectTimer = setTimeout(resolve, ms);
        });
    }

    cancel() {
        this.isReconnecting = false;
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }
    }

    reset() {
        this.retryCount = 0;
        this.cancel();
    }

    getStats() {
        return {
            retryCount: this.retryCount,
            isReconnecting: this.isReconnecting,
            maxRetries: this.config.maxRetries
        };
    }
}
```

### 智能重连策略

```typescript
enum DisconnectReason {
    NETWORK_ERROR = 'network_error',
    SERVER_ERROR = 'server_error', 
    CLIENT_ERROR = 'client_error',
    TIMEOUT = 'timeout',
    UNKNOWN = 'unknown'
}

class IntelligentReconnect {
    private reconnectStrategy: Map<DisconnectReason, ReconnectConfig> = new Map();
    private reconnector: ExponentialBackoffReconnect | null = null;
    private networkMonitor: NetworkMonitor;

    constructor() {
        this.initializeStrategies();
        this.networkMonitor = new NetworkMonitor();
    }

    private initializeStrategies() {
        // 网络错误：快速重连
        this.reconnectStrategy.set(DisconnectReason.NETWORK_ERROR, {
            initialDelay: 1000,
            maxDelay: 10000,
            maxRetries: 10,
            backoffMultiplier: 1.5,
            jitterRange: 0.2
        });

        // 服务器错误：保守重连
        this.reconnectStrategy.set(DisconnectReason.SERVER_ERROR, {
            initialDelay: 5000,
            maxDelay: 60000,
            maxRetries: 5,
            backoffMultiplier: 2,
            jitterRange: 0.3
        });

        // 客户端错误：不重连
        this.reconnectStrategy.set(DisconnectReason.CLIENT_ERROR, {
            initialDelay: 0,
            maxDelay: 0,
            maxRetries: 0,
            backoffMultiplier: 1,
            jitterRange: 0
        });

        // 超时：中等策略
        this.reconnectStrategy.set(DisconnectReason.TIMEOUT, {
            initialDelay: 2000,
            maxDelay: 30000,
            maxRetries: 8,
            backoffMultiplier: 2,
            jitterRange: 0.25
        });
    }

    async handleDisconnect(
        error: Error, 
        connectFn: () => Promise<void>
    ): Promise<boolean> {
        const reason = this.analyzeDisconnectReason(error);
        const config = this.reconnectStrategy.get(reason) || 
                       this.reconnectStrategy.get(DisconnectReason.UNKNOWN)!;

        console.log(`连接断开原因: ${reason}, 使用重连策略:`, config);

        // 如果是客户端错误，不重连
        if (reason === DisconnectReason.CLIENT_ERROR) {
            return false;
        }

        // 检查网络状态
        if (!await this.networkMonitor.isNetworkAvailable()) {
            console.log('网络不可用，等待网络恢复...');
            await this.networkMonitor.waitForNetwork();
        }

        // 执行重连
        this.reconnector = new ExponentialBackoffReconnect(config);
        return this.reconnector.attemptReconnect(connectFn);
    }

    private analyzeDisconnectReason(error: Error): DisconnectReason {
        const message = error.message.toLowerCase();

        if (message.includes('network') || message.includes('connection')) {
            return DisconnectReason.NETWORK_ERROR;
        }
        
        if (message.includes('timeout')) {
            return DisconnectReason.TIMEOUT;
        }

        if (message.includes('400') || message.includes('401') || message.includes('403')) {
            return DisconnectReason.CLIENT_ERROR;
        }

        if (message.includes('500') || message.includes('502') || message.includes('503')) {
            return DisconnectReason.SERVER_ERROR;
        }

        return DisconnectReason.UNKNOWN;
    }

    cancel() {
        this.reconnector?.cancel();
    }
}
```

### 网络状态监控

```typescript
class NetworkMonitor {
    private isOnline: boolean = navigator.onLine;
    private listeners: Set<(online: boolean) => void> = new Set();

    constructor() {
        this.setupEventListeners();
    }

    private setupEventListeners() {
        window.addEventListener('online', () => {
            console.log('网络连接已恢复');
            this.isOnline = true;
            this.notifyListeners(true);
        });

        window.addEventListener('offline', () => {
            console.log('网络连接已断开');
            this.isOnline = false;
            this.notifyListeners(false);
        });

        // 定期网络探测
        setInterval(() => {
            this.probeNetwork();
        }, 30000);
    }

    private async probeNetwork(): Promise<void> {
        try {
            // 发送轻量级探测请求
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            await fetch('/health', { 
                method: 'HEAD',
                signal: controller.signal,
                cache: 'no-cache'
            });

            clearTimeout(timeoutId);
            
            if (!this.isOnline) {
                this.isOnline = true;
                this.notifyListeners(true);
            }
        } catch (error) {
            if (this.isOnline) {
                this.isOnline = false;
                this.notifyListeners(false);
            }
        }
    }

    async isNetworkAvailable(): Promise<boolean> {
        if (!this.isOnline) {
            return false;
        }

        // 主动探测网络可用性
        try {
            await this.probeNetwork();
            return this.isOnline;
        } catch {
            return false;
        }
    }

    async waitForNetwork(timeoutMs: number = 60000): Promise<boolean> {
        if (this.isOnline) {
            return true;
        }

        return new Promise((resolve) => {
            const timeout = setTimeout(() => {
                this.removeListener(onlineListener);
                resolve(false);
            }, timeoutMs);

            const onlineListener = (online: boolean) => {
                if (online) {
                    clearTimeout(timeout);
                    this.removeListener(onlineListener);
                    resolve(true);
                }
            };

            this.addListener(onlineListener);
        });
    }

    addListener(listener: (online: boolean) => void) {
        this.listeners.add(listener);
    }

    removeListener(listener: (online: boolean) => void) {
        this.listeners.delete(listener);
    }

    private notifyListeners(online: boolean) {
        this.listeners.forEach(listener => {
            try {
                listener(online);
            } catch (error) {
                console.error('网络状态监听器执行失败:', error);
            }
        });
    }
}
```

## 超时处理与错误恢复

### 分层超时策略

```java
public class TimeoutConfiguration {
    
    // 连接建立超时
    public static final long CONNECTION_TIMEOUT = 10_000L; // 10秒
    
    // 读取超时
    public static final long READ_TIMEOUT = 30_000L; // 30秒
    
    // SSE流超时 
    public static final long SSE_TIMEOUT = 60 * 60 * 1000L; // 1小时
    
    // 心跳超时
    public static final long HEARTBEAT_TIMEOUT = 15_000L; // 15秒
    
    // 任务执行超时
    public static final long TASK_TIMEOUT = 30 * 60 * 1000L; // 30分钟
}

@Service
public class TimeoutManager {
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final Map<String, ScheduledFuture<?>> taskTimeouts = new ConcurrentHashMap<>();

    /**
     * 设置任务超时
     */
    public void setTaskTimeout(String requestId, long timeoutMs, Runnable timeoutAction) {
        // 取消之前的超时任务
        cancelTimeout(requestId);
        
        ScheduledFuture<?> future = scheduler.schedule(() -> {
            log.warn("任务超时: {}", requestId);
            taskTimeouts.remove(requestId);
            timeoutAction.run();
        }, timeoutMs, TimeUnit.MILLISECONDS);
        
        taskTimeouts.put(requestId, future);
    }

    /**
     * 取消超时任务
     */
    public void cancelTimeout(String requestId) {
        ScheduledFuture<?> future = taskTimeouts.remove(requestId);
        if (future != null && !future.isDone()) {
            future.cancel(false);
        }
    }

    /**
     * 延长超时时间
     */
    public void extendTimeout(String requestId, long additionalMs) {
        ScheduledFuture<?> future = taskTimeouts.get(requestId);
        if (future != null) {
            // 获取剩余时间并延长
            long remainingMs = future.getDelay(TimeUnit.MILLISECONDS);
            if (remainingMs > 0) {
                future.cancel(false);
                // 重新设置超时时间
                // 这里需要从原始的超时动作中获取回调，实际实现中需要存储这些信息
            }
        }
    }

    @PreDestroy
    public void shutdown() {
        taskTimeouts.values().forEach(future -> future.cancel(true));
        scheduler.shutdown();
    }
}
```

### 客户端超时处理

```typescript
interface TimeoutConfig {
    connection: number;
    message: number;
    heartbeat: number;
    total: number;
}

class ClientTimeoutManager {
    private config: TimeoutConfig;
    private timers: Map<string, NodeJS.Timeout> = new Map();
    private startTime: number = 0;

    constructor(config: TimeoutConfig) {
        this.config = config;
    }

    startSession() {
        this.startTime = Date.now();
        
        // 设置总体会话超时
        this.setTimer('session', this.config.total, () => {
            throw new Error('会话总体超时');
        });
    }

    onConnectionEstablished() {
        // 连接建立成功，清除连接超时
        this.clearTimer('connection');
        
        // 设置消息接收超时
        this.resetMessageTimeout();
    }

    onMessageReceived() {
        // 重置消息超时
        this.resetMessageTimeout();
        
        // 重置心跳超时
        this.resetHeartbeatTimeout();
    }

    onHeartbeatReceived() {
        // 重置心跳超时
        this.resetHeartbeatTimeout();
    }

    private resetMessageTimeout() {
        this.setTimer('message', this.config.message, () => {
            throw new Error('消息接收超时');
        });
    }

    private resetHeartbeatTimeout() {
        this.setTimer('heartbeat', this.config.heartbeat, () => {
            throw new Error('心跳超时');
        });
    }

    private setTimer(name: string, timeoutMs: number, callback: () => void) {
        this.clearTimer(name);
        
        const timer = setTimeout(() => {
            this.timers.delete(name);
            callback();
        }, timeoutMs);
        
        this.timers.set(name, timer);
    }

    private clearTimer(name: string) {
        const timer = this.timers.get(name);
        if (timer) {
            clearTimeout(timer);
            this.timers.delete(name);
        }
    }

    getElapsedTime(): number {
        return Date.now() - this.startTime;
    }

    getRemainingTime(): number {
        const elapsed = this.getElapsedTime();
        return Math.max(0, this.config.total - elapsed);
    }

    cleanup() {
        this.timers.forEach(timer => clearTimeout(timer));
        this.timers.clear();
    }
}
```

## 流式数据的完整性校验

### 消息序号机制

```java
public class StreamMessage {
    private String messageId;
    private Long sequenceNumber;
    private String requestId;
    private String messageType;
    private Object data;
    private String checksum;
    private Long timestamp;

    // 生成消息校验和
    public void generateChecksum() {
        String content = requestId + sequenceNumber + messageType + 
                        JSON.toJSONString(data) + timestamp;
        this.checksum = DigestUtils.md5DigestAsHex(content.getBytes());
    }

    // 验证消息完整性
    public boolean verifyChecksum() {
        String content = requestId + sequenceNumber + messageType + 
                        JSON.toJSONString(data) + timestamp;
        String calculatedChecksum = DigestUtils.md5DigestAsHex(content.getBytes());
        return Objects.equals(this.checksum, calculatedChecksum);
    }
}

@Component
public class StreamIntegrityManager {
    private final Map<String, AtomicLong> sequenceCounters = new ConcurrentHashMap<>();
    private final Map<String, Set<Long>> receivedMessages = new ConcurrentHashMap<>();

    /**
     * 生成下一个序号
     */
    public long getNextSequence(String requestId) {
        return sequenceCounters.computeIfAbsent(requestId, k -> new AtomicLong(0))
                               .incrementAndGet();
    }

    /**
     * 验证消息序号
     */
    public boolean verifySequence(String requestId, long sequenceNumber) {
        Set<Long> received = receivedMessages.computeIfAbsent(requestId, k -> new HashSet<>());
        
        // 检查是否重复
        if (received.contains(sequenceNumber)) {
            log.warn("检测到重复消息: requestId={}, sequence={}", requestId, sequenceNumber);
            return false;
        }
        
        received.add(sequenceNumber);
        return true;
    }

    /**
     * 检查消息缺失
     */
    public List<Long> findMissingSequences(String requestId, long maxSequence) {
        Set<Long> received = receivedMessages.get(requestId);
        if (received == null) {
            return Collections.emptyList();
        }

        List<Long> missing = new ArrayList<>();
        for (long i = 1; i <= maxSequence; i++) {
            if (!received.contains(i)) {
                missing.add(i);
            }
        }
        return missing;
    }

    /**
     * 清理会话数据
     */
    public void cleanup(String requestId) {
        sequenceCounters.remove(requestId);
        receivedMessages.remove(requestId);
    }
}
```

### 客户端数据校验

```typescript
interface MessageIntegrity {
    sequenceNumber: number;
    checksum: string;
    timestamp: number;
}

class ClientStreamVerifier {
    private expectedSequence: Map<string, number> = new Map();
    private receivedMessages: Map<string, Set<number>> = new Map();
    private missingMessages: Map<string, Set<number>> = new Map();

    verifyMessage(requestId: string, message: any): boolean {
        // 验证序号
        if (!this.verifySequence(requestId, message.sequenceNumber)) {
            return false;
        }

        // 验证校验和
        if (!this.verifyChecksum(message)) {
            console.error('消息校验和验证失败:', message);
            return false;
        }

        // 验证时间戳（防止重放攻击）
        if (!this.verifyTimestamp(message.timestamp)) {
            console.error('消息时间戳异常:', message);
            return false;
        }

        return true;
    }

    private verifySequence(requestId: string, sequenceNumber: number): boolean {
        const expected = this.expectedSequence.get(requestId) || 1;
        const received = this.receivedMessages.get(requestId) || new Set();

        if (sequenceNumber === expected) {
            // 正常的下一个消息
            received.add(sequenceNumber);
            this.receivedMessages.set(requestId, received);
            this.expectedSequence.set(requestId, expected + 1);
            
            // 检查是否有之前缺失的消息现在到达了
            this.checkForLateMessages(requestId, sequenceNumber);
            
            return true;
        } else if (sequenceNumber > expected) {
            // 消息乱序或丢失
            this.handleMissingMessages(requestId, expected, sequenceNumber);
            received.add(sequenceNumber);
            this.receivedMessages.set(requestId, received);
            return true;
        } else {
            // 重复消息或过期消息
            if (received.has(sequenceNumber)) {
                console.warn(`重复消息: requestId=${requestId}, sequence=${sequenceNumber}`);
            } else {
                console.warn(`过期消息: requestId=${requestId}, sequence=${sequenceNumber}`);
            }
            return false;
        }
    }

    private verifyChecksum(message: any): boolean {
        if (!message.checksum) {
            return true; // 如果没有校验和，跳过验证
        }

        const content = message.requestId + message.sequenceNumber + 
                       message.messageType + JSON.stringify(message.data) + 
                       message.timestamp;
        
        const calculatedChecksum = this.calculateMD5(content);
        return calculatedChecksum === message.checksum;
    }

    private verifyTimestamp(timestamp: number): boolean {
        const now = Date.now();
        const maxAge = 5 * 60 * 1000; // 5分钟
        
        // 消息不能太旧
        if (now - timestamp > maxAge) {
            return false;
        }
        
        // 消息不能来自未来（考虑时钟偏差）
        const maxClockSkew = 30 * 1000; // 30秒
        if (timestamp - now > maxClockSkew) {
            return false;
        }
        
        return true;
    }

    private handleMissingMessages(requestId: string, expectedSeq: number, receivedSeq: number) {
        const missing = this.missingMessages.get(requestId) || new Set();
        
        for (let i = expectedSeq; i < receivedSeq; i++) {
            missing.add(i);
            console.warn(`检测到缺失消息: requestId=${requestId}, sequence=${i}`);
        }
        
        this.missingMessages.set(requestId, missing);
        this.expectedSequence.set(requestId, receivedSeq + 1);
    }

    private checkForLateMessages(requestId: string, sequenceNumber: number) {
        const missing = this.missingMessages.get(requestId);
        if (missing && missing.has(sequenceNumber)) {
            missing.delete(sequenceNumber);
            console.log(`延迟消息到达: requestId=${requestId}, sequence=${sequenceNumber}`);
        }
    }

    private calculateMD5(content: string): string {
        // 在实际应用中，使用crypto库计算MD5
        // 这里简化实现
        return btoa(content).substring(0, 32);
    }

    getMissingMessages(requestId: string): number[] {
        const missing = this.missingMessages.get(requestId);
        return missing ? Array.from(missing) : [];
    }

    cleanup(requestId: string) {
        this.expectedSequence.delete(requestId);
        this.receivedMessages.delete(requestId);
        this.missingMessages.delete(requestId);
    }
}
```

## 并发控制与资源管理

### 连接池管理

```java
@Configuration
public class SSEConnectionPoolConfig {
    
    @Bean
    public SSEConnectionPool sseConnectionPool() {
        return new SSEConnectionPool(
            1000,    // 最大连接数
            60000,   // 连接超时时间
            300000   // 连接最大生存时间
        );
    }
}

@Component
public class SSEConnectionPool {
    private final int maxConnections;
    private final long connectionTimeout;
    private final long maxConnectionAge;
    private final Map<String, SSEConnectionInfo> activeConnections = new ConcurrentHashMap<>();
    private final AtomicInteger connectionCount = new AtomicInteger(0);

    public SSEConnectionPool(int maxConnections, long connectionTimeout, long maxConnectionAge) {
        this.maxConnections = maxConnections;
        this.connectionTimeout = connectionTimeout;
        this.maxConnectionAge = maxConnectionAge;
        
        // 启动清理任务
        startCleanupTask();
    }

    public boolean canCreateConnection(String requestId) {
        // 检查是否达到最大连接数
        if (connectionCount.get() >= maxConnections) {
            log.warn("连接池已满，当前连接数: {}", connectionCount.get());
            return false;
        }

        // 检查是否已存在相同的连接
        if (activeConnections.containsKey(requestId)) {
            log.warn("连接已存在: {}", requestId);
            return false;
        }

        return true;
    }

    public void registerConnection(String requestId, SseEmitter emitter) {
        if (canCreateConnection(requestId)) {
            SSEConnectionInfo info = new SSEConnectionInfo(
                requestId, emitter, System.currentTimeMillis()
            );
            
            activeConnections.put(requestId, info);
            connectionCount.incrementAndGet();
            
            log.info("注册SSE连接: {}, 当前连接数: {}", requestId, connectionCount.get());
            
            // 设置连接关闭回调
            emitter.onCompletion(() -> removeConnection(requestId));
            emitter.onTimeout(() -> removeConnection(requestId));
            emitter.onError((ex) -> removeConnection(requestId));
        }
    }

    public void removeConnection(String requestId) {
        SSEConnectionInfo info = activeConnections.remove(requestId);
        if (info != null) {
            connectionCount.decrementAndGet();
            log.info("移除SSE连接: {}, 当前连接数: {}", requestId, connectionCount.get());
        }
    }

    private void startCleanupTask() {
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(() -> {
            cleanupExpiredConnections();
        }, 60, 60, TimeUnit.SECONDS); // 每分钟清理一次
    }

    private void cleanupExpiredConnections() {
        long now = System.currentTimeMillis();
        
        activeConnections.entrySet().removeIf(entry -> {
            SSEConnectionInfo info = entry.getValue();
            
            // 检查连接年龄
            if (now - info.getCreateTime() > maxConnectionAge) {
                log.info("清理过期连接: {}", entry.getKey());
                info.getEmitter().complete();
                connectionCount.decrementAndGet();
                return true;
            }
            
            return false;
        });
    }

    public int getActiveConnectionCount() {
        return connectionCount.get();
    }

    public Set<String> getActiveConnectionIds() {
        return new HashSet<>(activeConnections.keySet());
    }
}

@Data
class SSEConnectionInfo {
    private final String requestId;
    private final SseEmitter emitter;
    private final long createTime;
    private volatile long lastActivityTime;

    public SSEConnectionInfo(String requestId, SseEmitter emitter, long createTime) {
        this.requestId = requestId;
        this.emitter = emitter;
        this.createTime = createTime;
        this.lastActivityTime = createTime;
    }

    public void updateActivity() {
        this.lastActivityTime = System.currentTimeMillis();
    }
}
```

### 资源隔离与限流

```java
@Component
public class StreamingResourceManager {
    private final Map<String, Semaphore> userSemaphores = new ConcurrentHashMap<>();
    private final RateLimiter globalRateLimiter;
    private final Map<String, RateLimiter> userRateLimiters = new ConcurrentHashMap<>();

    public StreamingResourceManager() {
        // 全局限流：每秒最多100个连接
        this.globalRateLimiter = RateLimiter.create(100.0);
    }

    public boolean acquireConnection(String userId) {
        // 全局限流检查
        if (!globalRateLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
            log.warn("全局连接限流触发");
            return false;
        }

        // 用户级别限流检查
        RateLimiter userLimiter = userRateLimiters.computeIfAbsent(userId, 
            k -> RateLimiter.create(5.0)); // 每个用户每秒最多5个连接

        if (!userLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
            log.warn("用户连接限流触发: {}", userId);
            return false;
        }

        // 用户并发连接数限制
        Semaphore userSemaphore = userSemaphores.computeIfAbsent(userId, 
            k -> new Semaphore(3)); // 每个用户最多3个并发连接

        if (!userSemaphore.tryAcquire()) {
            log.warn("用户并发连接数超限: {}", userId);
            return false;
        }

        return true;
    }

    public void releaseConnection(String userId) {
        Semaphore userSemaphore = userSemaphores.get(userId);
        if (userSemaphore != null) {
            userSemaphore.release();
        }
    }

    // 内存使用监控
    @Scheduled(fixedRate = 30000) // 30秒检查一次
    public void monitorMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        double memoryUsagePercent = (double) usedMemory / totalMemory * 100;
        
        if (memoryUsagePercent > 80) {
            log.warn("内存使用率过高: {}%", memoryUsagePercent);
            // 触发一些保护措施，比如拒绝新连接或清理缓存
            triggerMemoryProtection();
        }
    }

    private void triggerMemoryProtection() {
        // 强制垃圾回收
        System.gc();
        
        // 清理过期的用户限制器
        cleanupExpiredRateLimiters();
        
        // 可以考虑临时降低连接限制等措施
    }

    private void cleanupExpiredRateLimiters() {
        // 清理长时间未使用的限流器
        // 实际实现中需要记录最后使用时间
    }
}
```

## 小结

流式通信的可靠性保障是一个多层次的工程问题：

1. **心跳机制**：保证连接活性检测和及时发现断线
2. **重连策略**：智能化的断线重连，适应不同的失败场景
3. **超时处理**：分层的超时策略，避免资源无限等待
4. **完整性校验**：确保数据的完整性和顺序性
5. **资源管理**：连接池和限流机制，防止资源耗尽

这些机制需要在服务端和客户端协同工作，形成完整的可靠性保障体系。在下一节中，我们将重点探讨AI Agent场景下的特殊流式交互模式。

---

**本节关键要点：**
- 心跳机制的设计原理和双向实现
- 指数退避重连算法和智能重连策略
- 分层超时处理和客户端超时管理
- 流式数据的完整性校验和序号机制
- 并发控制、资源隔离和限流策略
