# 2.1.7 企业级部署与运维

**学习目标：** 掌握流式通信应用的企业级部署方案，学会运维管理的最佳实践

## 负载均衡器的流式通信支持配置

### Nginx流式代理配置

在企业级部署中，Nginx是最常用的反向代理服务器。针对流式通信（SSE），需要特别的配置来确保连接的稳定性和性能：

```nginx
# nginx.conf
http {
    # 全局配置
    upstream streaming_backend {
        # 使用IP哈希确保会话粘性
        ip_hash;
        server backend1.example.com:8080 max_fails=3 fail_timeout=30s;
        server backend2.example.com:8080 max_fails=3 fail_timeout=30s;
        server backend3.example.com:8080 max_fails=3 fail_timeout=30s;
        
        # 健康检查配置
        keepalive 32;
        keepalive_requests 1000;
        keepalive_timeout 60s;
    }

    # 流式通信专用配置
    server {
        listen 443 ssl http2;
        server_name api.example.com;
        
        # SSL配置
        ssl_certificate /path/to/certificate.crt;
        ssl_certificate_key /path/to/private.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        
        # 流式通信路径配置
        location /web/api/v1/gpt/queryAgentStreamIncr {
            proxy_pass http://streaming_backend;
            
            # SSE关键配置
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 禁用缓冲，确保实时传输
            proxy_buffering off;
            proxy_cache off;
            proxy_request_buffering off;
            
            # 超时配置
            proxy_connect_timeout 60s;
            proxy_send_timeout 3600s;      # 1小时
            proxy_read_timeout 3600s;      # 1小时
            
            # 保持连接
            proxy_set_header Connection "";
            
            # 添加CORS头（如果需要）
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
            add_header Access-Control-Allow-Headers 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
            
            # 处理预检请求
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Max-Age 1728000;
                add_header Content-Type 'text/plain; charset=utf-8';
                add_header Content-Length 0;
                return 204;
            }
        }
        
        # 静态资源和API请求
        location / {
            proxy_pass http://streaming_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 正常的代理缓冲设置
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;
            
            proxy_connect_timeout 30s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }
        
        # 健康检查端点
        location /health {
            access_log off;
            proxy_pass http://streaming_backend/actuator/health;
            proxy_connect_timeout 5s;
            proxy_send_timeout 5s;
            proxy_read_timeout 5s;
        }
    }
    
    # 监控和日志配置
    access_log /var/log/nginx/streaming_access.log combined buffer=32k flush=1m;
    error_log /var/log/nginx/streaming_error.log warn;
    
    # 性能优化
    worker_processes auto;
    worker_connections 4096;
    worker_rlimit_nofile 8192;
    
    # 连接池优化
    events {
        use epoll;
        multi_accept on;
    }
}
```

### HAProxy流式代理配置

HAProxy是另一个优秀的负载均衡器选择，特别适合处理长连接：

```haproxy
# haproxy.cfg
global
    daemon
    maxconn 4096
    log stdout local0
    
    # SSL配置
    ssl-default-bind-ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384
    ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets
    
defaults
    mode http
    timeout connect 10s
    timeout client 1h        # 客户端连接超时1小时
    timeout server 1h        # 服务器连接超时1小时
    timeout tunnel 1h        # 隧道超时1小时
    option httplog
    option dontlognull
    option log-health-checks
    
frontend streaming_frontend
    bind *:443 ssl crt /path/to/certificate.pem
    bind *:80
    redirect scheme https if !{ ssl_fc }
    
    # 根据路径分发
    acl is_streaming path_beg /web/api/v1/gpt/queryAgentStreamIncr
    acl is_health path /health
    
    use_backend streaming_backend if is_streaming
    use_backend health_backend if is_health
    default_backend default_backend
    
    # CORS处理
    http-response add-header Access-Control-Allow-Origin *
    http-response add-header Access-Control-Allow-Methods 'GET, POST, OPTIONS'
    http-response add-header Access-Control-Allow-Headers 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization'

backend streaming_backend
    balance source  # 使用源IP哈希，确保会话粘性
    
    # 服务器配置
    server backend1 backend1.example.com:8080 check inter 10s rise 3 fall 2 maxconn 500
    server backend2 backend2.example.com:8080 check inter 10s rise 3 fall 2 maxconn 500
    server backend3 backend3.example.com:8080 check inter 10s rise 3 fall 2 maxconn 500
    
    # 流式通信优化
    option http-server-close
    option prefer-last-server  # 优先使用最后一个服务器
    
    # 健康检查
    option httpchk GET /actuator/health HTTP/1.1\r\nHost:\ backend-health
    http-check expect status 200
    
backend health_backend
    balance roundrobin
    server backend1 backend1.example.com:8080 check
    server backend2 backend2.example.com:8080 check
    server backend3 backend3.example.com:8080 check

backend default_backend
    balance roundrobin
    server backend1 backend1.example.com:8080 check
    server backend2 backend2.example.com:8080 check
    server backend3 backend3.example.com:8080 check

# 统计页面
listen stats
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE
```

### 会话粘性策略

流式通信需要特殊的会话粘性处理：

```java
@Component
public class SessionAffinityManager {
    private final RedisTemplate<String, String> redisTemplate;
    private final ConsistentHash<String> consistentHash;

    public SessionAffinityManager(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
        this.consistentHash = new ConsistentHash<>(getBackendServers());
    }

    /**
     * 获取会话应该路由到的后端服务器
     */
    public String getBackendServer(String sessionId, String clientIP) {
        // 1. 首先检查Redis中是否已有会话绑定
        String existingServer = redisTemplate.opsForValue()
            .get("session:affinity:" + sessionId);
        
        if (existingServer != null && isServerHealthy(existingServer)) {
            return existingServer;
        }
        
        // 2. 使用一致性哈希选择服务器
        String selectedServer = consistentHash.get(clientIP);
        
        // 3. 将会话绑定到服务器
        redisTemplate.opsForValue().set(
            "session:affinity:" + sessionId, 
            selectedServer,
            Duration.ofHours(2) // 2小时过期
        );
        
        return selectedServer;
    }

    /**
     * 处理服务器故障转移
     */
    public String handleServerFailover(String sessionId, String failedServer) {
        // 1. 从可用服务器中选择新的服务器
        List<String> availableServers = getHealthyServers();
        availableServers.remove(failedServer);
        
        if (availableServers.isEmpty()) {
            throw new RuntimeException("没有可用的后端服务器");
        }
        
        // 2. 使用负载最低的服务器
        String newServer = selectLeastLoadedServer(availableServers);
        
        // 3. 更新会话绑定
        redisTemplate.opsForValue().set(
            "session:affinity:" + sessionId,
            newServer,
            Duration.ofHours(2)
        );
        
        // 4. 记录故障转移日志
        log.info("会话故障转移: sessionId={}, from={}, to={}", 
                sessionId, failedServer, newServer);
        
        return newServer;
    }

    private boolean isServerHealthy(String server) {
        // 实现服务器健康检查逻辑
        try {
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.getForEntity(
                "http://" + server + "/actuator/health", 
                String.class
            );
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            return false;
        }
    }

    private String selectLeastLoadedServer(List<String> servers) {
        // 实现负载检测逻辑，返回负载最低的服务器
        return servers.stream()
            .min(Comparator.comparing(this::getServerLoad))
            .orElse(servers.get(0));
    }

    private Double getServerLoad(String server) {
        // 从监控系统获取服务器负载
        try {
            String loadInfo = redisTemplate.opsForValue()
                .get("server:load:" + server);
            return loadInfo != null ? Double.parseDouble(loadInfo) : 100.0;
        } catch (Exception e) {
            return 100.0; // 默认高负载
        }
    }
}
```

## 网关层面的流式代理处理

### Spring Cloud Gateway配置

```yaml
# application.yml
spring:
  cloud:
    gateway:
      routes:
        # 流式通信路由
        - id: streaming-route
          uri: lb://streaming-service
          predicates:
            - Path=/web/api/v1/gpt/queryAgentStreamIncr
          filters:
            - name: CircuitBreaker
              args:
                name: streaming-circuit-breaker
                fallback-uri: forward:/streaming-fallback
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,GATEWAY_TIMEOUT
                methods: POST
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenish-rate: 100  # 每秒补充令牌数
                  burst-capacity: 200  # 令牌桶容量
                key-resolver: "#{@ipKeyResolver}"
            - name: ModifyRequestBody
              args:
                content-type: application/json
        
        # 普通API路由
        - id: api-route
          uri: lb://streaming-service
          predicates:
            - Path=/web/api/**
            - "!Path=/web/api/v1/gpt/queryAgentStreamIncr"
          filters:
            - name: CircuitBreaker
              args:
                name: api-circuit-breaker
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenish-rate: 500
                  burst-capacity: 1000

  # 超时配置
  cloud:
    gateway:
      httpclient:
        connect-timeout: 10000
        response-timeout: 3600s  # 流式接口需要长时间超时
        pool:
          type: elastic
          max-idle-time: 15s
          max-life-time: 60s

# 监控配置  
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,gateway
  endpoint:
    gateway:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# 日志配置
logging:
  level:
    org.springframework.cloud.gateway: INFO
    reactor.netty: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

### 自定义网关过滤器

```java
@Component
public class StreamingGatewayFilterFactory extends AbstractGatewayFilterFactory<StreamingGatewayFilterFactory.Config> {

    public StreamingGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            
            // 检查是否为流式请求
            if (isStreamingRequest(request)) {
                return handleStreamingRequest(exchange, chain, config);
            }
            
            return chain.filter(exchange);
        };
    }

    private Mono<Void> handleStreamingRequest(ServerWebExchange exchange, 
                                            GatewayFilterChain chain, 
                                            Config config) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();
        
        // 设置流式响应头
        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, "text/event-stream");
        response.getHeaders().set(HttpHeaders.CACHE_CONTROL, "no-cache");
        response.getHeaders().set(HttpHeaders.CONNECTION, "keep-alive");
        response.getHeaders().set("X-Accel-Buffering", "no"); // Nginx禁用缓冲
        
        // 添加会话跟踪
        String sessionId = extractSessionId(request);
        if (sessionId != null) {
            response.getHeaders().set("X-Session-ID", sessionId);
        }
        
        // 记录流式请求开始
        long startTime = System.currentTimeMillis();
        logStreamingStart(request, sessionId);
        
        return chain.filter(exchange)
            .doFinally(signalType -> {
                // 记录流式请求结束
                long duration = System.currentTimeMillis() - startTime;
                logStreamingEnd(request, sessionId, duration, signalType);
            });
    }

    private boolean isStreamingRequest(ServerHttpRequest request) {
        return request.getPath().value().contains("StreamIncr") ||
               request.getHeaders().getFirst("Accept").contains("text/event-stream");
    }

    private String extractSessionId(ServerHttpRequest request) {
        // 从请求头或请求体中提取会话ID
        String sessionId = request.getHeaders().getFirst("X-Session-ID");
        if (sessionId == null) {
            sessionId = request.getQueryParams().getFirst("sessionId");
        }
        return sessionId;
    }

    private void logStreamingStart(ServerHttpRequest request, String sessionId) {
        log.info("流式请求开始: path={}, sessionId={}, clientIP={}", 
                request.getPath().value(), 
                sessionId, 
                getClientIP(request));
    }

    private void logStreamingEnd(ServerHttpRequest request, String sessionId, 
                                long duration, SignalType signalType) {
        log.info("流式请求结束: path={}, sessionId={}, duration={}ms, signalType={}", 
                request.getPath().value(), 
                sessionId, 
                duration, 
                signalType);
    }

    private String getClientIP(ServerHttpRequest request) {
        String xForwardedFor = request.getHeaders().getFirst("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIP = request.getHeaders().getFirst("X-Real-IP");
        if (xRealIP != null && !xRealIP.isEmpty()) {
            return xRealIP;
        }
        
        return request.getRemoteAddress() != null ? 
               request.getRemoteAddress().getAddress().getHostAddress() : "unknown";
    }

    @Data
    public static class Config {
        private boolean enableSessionTracking = true;
        private boolean enableMetrics = true;
        private long maxStreamingDuration = 3600000; // 1小时
    }
}

@Component
public class IpKeyResolver implements KeyResolver {
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        return Mono.just(getClientIP(exchange.getRequest()));
    }

    private String getClientIP(ServerHttpRequest request) {
        String xForwardedFor = request.getHeaders().getFirst("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddress().getAddress().getHostAddress();
    }
}
```

## 容器化环境下的连接管理

### Docker容器配置

```dockerfile
# Dockerfile
FROM openjdk:17-jdk-slim

# 安装必要的系统工具
RUN apt-get update && apt-get install -y \
    curl \
    netcat-openbsd \
    procps \
    && rm -rf /var/lib/apt/lists/*

# 创建应用用户
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# 设置工作目录
WORKDIR /app

# 复制应用文件
COPY target/streaming-app.jar app.jar
COPY docker-entrypoint.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/docker-entrypoint.sh

# 设置JVM参数
ENV JAVA_OPTS="-Xms512m -Xmx2g \
    -XX:+UseG1GC \
    -XX:MaxGCPauseMillis=200 \
    -XX:+HeapDumpOnOutOfMemoryError \
    -XX:HeapDumpPath=/app/logs/ \
    -Dspring.profiles.active=docker"

# 暴露端口
EXPOSE 8080 8081

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 切换到非root用户
USER appuser

ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["java", "-jar", "app.jar"]
```

```bash
#!/bin/bash
# docker-entrypoint.sh

set -e

# 等待依赖服务启动
echo "等待Redis启动..."
while ! nc -z ${REDIS_HOST:-redis} ${REDIS_PORT:-6379}; do
  sleep 1
done

echo "等待数据库启动..."
while ! nc -z ${DB_HOST:-mysql} ${DB_PORT:-3306}; do
  sleep 1
done

# 设置JVM参数
export JAVA_OPTS="$JAVA_OPTS \
    -Dserver.port=8080 \
    -Dmanagement.server.port=8081 \
    -Dspring.redis.host=${REDIS_HOST:-redis} \
    -Dspring.redis.port=${REDIS_PORT:-6379} \
    -Dspring.datasource.url=jdbc:mysql://${DB_HOST:-mysql}:${DB_PORT:-3306}/${DB_NAME:-streaming_app} \
    -Dspring.datasource.username=${DB_USERNAME:-app} \
    -Dspring.datasource.password=${DB_PASSWORD:-password}"

echo "启动应用，JVM参数: $JAVA_OPTS"
exec "$@"
```

### Kubernetes部署配置

```yaml
# streaming-app-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: streaming-app
  labels:
    app: streaming-app
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: streaming-app
      version: v1
  template:
    metadata:
      labels:
        app: streaming-app
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8081"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      affinity:
        # Pod反亲和性，确保Pod分布在不同节点
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - streaming-app
              topologyKey: kubernetes.io/hostname
      containers:
      - name: streaming-app
        image: streaming-app:latest
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 8081
          name: management
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: REDIS_HOST
          value: "redis-service"
        - name: DB_HOST
          value: "mysql-service"
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "3Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8081
          initialDelaySeconds: 120
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        lifecycle:
          preStop:
            exec:
              command:
              - sh
              - -c
              - "sleep 15" # 优雅关闭等待时间
        volumeMounts:
        - name: app-logs
          mountPath: /app/logs
        - name: app-config
          mountPath: /app/config
          readOnly: true
      volumes:
      - name: app-logs
        emptyDir: {}
      - name: app-config
        configMap:
          name: streaming-app-config
      terminationGracePeriodSeconds: 60

---
apiVersion: v1
kind: Service
metadata:
  name: streaming-app-service
  labels:
    app: streaming-app
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  - port: 8081
    targetPort: 8081
    protocol: TCP
    name: management
  selector:
    app: streaming-app

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: streaming-app-config
data:
  application-k8s.yml: |
    server:
      port: 8080
      tomcat:
        max-connections: 2000
        threads:
          max: 200
          min-spare: 20
    
    management:
      server:
        port: 8081
      endpoints:
        web:
          exposure:
            include: health,info,metrics,prometheus
      endpoint:
        health:
          show-details: always
      health:
        livenessstate:
          enabled: true
        readinessstate:
          enabled: true
    
    spring:
      redis:
        timeout: 5000ms
        lettuce:
          pool:
            max-active: 20
            max-idle: 10
            min-idle: 5
      
      datasource:
        hikari:
          maximum-pool-size: 20
          minimum-idle: 5
          connection-timeout: 30000
          idle-timeout: 600000
          max-lifetime: 1800000

---
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YXBw  # base64 encoded 'app'
  password: cGFzc3dvcmQ=  # base64 encoded 'password'
```

### 水平扩缩容配置

```yaml
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: streaming-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: streaming-app
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  # 自定义指标：活跃连接数
  - type: Pods
    pods:
      metric:
        name: streaming_connections_active
      target:
        type: AverageValue
        averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300  # 5分钟稳定窗口
      policies:
      - type: Percent
        value: 50  # 每次最多缩容50%
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60   # 1分钟稳定窗口
      policies:
      - type: Percent
        value: 100  # 每次最多扩容100%
        periodSeconds: 60

---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: streaming-app-pdb
spec:
  minAvailable: 2  # 始终保持至少2个Pod可用
  selector:
    matchLabels:
      app: streaming-app
```

## 流式服务的健康检查策略

### 多层次健康检查实现

```java
@Component
public class StreamingHealthIndicator implements HealthIndicator {
    private final SSEConnectionPool connectionPool;
    private final RedisTemplate<String, String> redisTemplate;
    private final MeterRegistry meterRegistry;

    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        try {
            // 1. 基础组件健康检查
            checkBasicHealth(builder);
            
            // 2. 连接池健康检查
            checkConnectionPoolHealth(builder);
            
            // 3. 业务指标健康检查
            checkBusinessMetricsHealth(builder);
            
            // 4. 依赖服务健康检查
            checkDependenciesHealth(builder);
            
            return builder.up().build();
            
        } catch (Exception e) {
            return builder.down()
                .withDetail("error", e.getMessage())
                .withException(e)
                .build();
        }
    }

    private void checkBasicHealth(Health.Builder builder) {
        // JVM健康检查
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        double memoryUsagePercent = (double) usedMemory / runtime.maxMemory() * 100;
        
        builder.withDetail("jvm.memory.used", usedMemory)
               .withDetail("jvm.memory.total", totalMemory)
               .withDetail("jvm.memory.usage.percent", String.format("%.2f%%", memoryUsagePercent));
        
        if (memoryUsagePercent > 90) {
            builder.down().withDetail("reason", "内存使用率过高");
            return;
        }
        
        // CPU健康检查
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        double cpuUsage = osBean.getProcessCpuLoad() * 100;
        builder.withDetail("system.cpu.usage.percent", String.format("%.2f%%", cpuUsage));
        
        if (cpuUsage > 95) {
            builder.down().withDetail("reason", "CPU使用率过高");
        }
    }

    private void checkConnectionPoolHealth(Health.Builder builder) {
        PoolStatistics stats = connectionPool.getStatistics();
        
        builder.withDetail("connections.active", stats.getActiveConnections())
               .withDetail("connections.max", stats.getMaxConnections())
               .withDetail("connections.reusable", stats.getReusableConnections());
        
        double connectionUsagePercent = (double) stats.getActiveConnections() / stats.getMaxConnections() * 100;
        builder.withDetail("connections.usage.percent", String.format("%.2f%%", connectionUsagePercent));
        
        if (connectionUsagePercent > 95) {
            builder.down().withDetail("reason", "连接池接近耗尽");
        }
    }

    private void checkBusinessMetricsHealth(Health.Builder builder) {
        // 检查消息处理能力
        Timer messageProcessingTimer = meterRegistry.get("streaming.message.processing.duration").timer();
        double averageProcessingTime = messageProcessingTimer.mean(TimeUnit.MILLISECONDS);
        
        builder.withDetail("message.processing.average.ms", averageProcessingTime);
        
        if (averageProcessingTime > 5000) { // 超过5秒
            builder.down().withDetail("reason", "消息处理延迟过高");
        }
        
        // 检查错误率
        Counter errorCounter = meterRegistry.get("streaming.messages.failed.total").counter();
        Counter successCounter = meterRegistry.get("streaming.messages.sent.total").counter();
        
        double totalMessages = errorCounter.count() + successCounter.count();
        double errorRate = totalMessages > 0 ? errorCounter.count() / totalMessages * 100 : 0;
        
        builder.withDetail("message.error.rate.percent", String.format("%.2f%%", errorRate));
        
        if (errorRate > 5) { // 错误率超过5%
            builder.down().withDetail("reason", "消息错误率过高");
        }
    }

    private void checkDependenciesHealth(Health.Builder builder) {
        // Redis健康检查
        try {
            redisTemplate.opsForValue().get("health-check");
            builder.withDetail("redis.status", "UP");
        } catch (Exception e) {
            builder.down()
                   .withDetail("redis.status", "DOWN")
                   .withDetail("redis.error", e.getMessage());
            return;
        }
        
        // 数据库健康检查
        // AI服务健康检查等...
    }
}

@Component
public class DetailedHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        return Health.up()
            .withDetail("streaming", buildStreamingHealth())
            .withDetail("performance", buildPerformanceHealth())
            .withDetail("resources", buildResourceHealth())
            .build();
    }

    private Map<String, Object> buildStreamingHealth() {
        Map<String, Object> details = new HashMap<>();
        
        // 流式连接统计
        details.put("active_connections", getCurrentActiveConnections());
        details.put("total_sessions", getTotalSessions());
        details.put("average_session_duration", getAverageSessionDuration());
        
        // 消息统计
        details.put("messages_sent_per_minute", getMessagesPerMinute());
        details.put("message_success_rate", getMessageSuccessRate());
        
        return details;
    }

    private Map<String, Object> buildPerformanceHealth() {
        Map<String, Object> details = new HashMap<>();
        
        details.put("response_time_p95", getResponseTimeP95());
        details.put("throughput_per_second", getThroughputPerSecond());
        details.put("queue_size", getCurrentQueueSize());
        
        return details;
    }

    private Map<String, Object> buildResourceHealth() {
        Map<String, Object> details = new HashMap<>();
        
        // 线程池状态
        details.put("thread_pool_active", getActiveThreadCount());
        details.put("thread_pool_queue_size", getThreadPoolQueueSize());
        
        // 网络状态
        details.put("network_connections", getNetworkConnectionCount());
        details.put("network_bandwidth_usage", getNetworkBandwidthUsage());
        
        return details;
    }
}
```

### Kubernetes Probe配置

```yaml
# 增强的健康检查配置
spec:
  containers:
  - name: streaming-app
    livenessProbe:
      httpGet:
        path: /actuator/health/liveness
        port: 8081
        httpHeaders:
        - name: Accept
          value: application/json
      initialDelaySeconds: 120
      periodSeconds: 30
      timeoutSeconds: 10
      successThreshold: 1
      failureThreshold: 3
      
    readinessProbe:
      httpGet:
        path: /actuator/health/readiness
        port: 8081
        httpHeaders:
        - name: Accept
          value: application/json
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 3
      
    # 启动探针，用于慢启动应用
    startupProbe:
      httpGet:
        path: /actuator/health/startup
        port: 8081
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      successThreshold: 1
      failureThreshold: 30  # 最多等待5分钟启动
```

## 生产环境的故障排查与恢复

### 故障监控与告警系统

```java
@Component
public class StreamingFailureDetector {
    private final AlertService alertService;
    private final MetricsCollector metricsCollector;
    private final Map<String, CircuitBreaker> circuitBreakers = new ConcurrentHashMap<>();

    @EventListener
    public void handleStreamingFailure(StreamingFailureEvent event) {
        FailureType failureType = classifyFailure(event);
        
        switch (failureType) {
            case CONNECTION_FAILURE:
                handleConnectionFailure(event);
                break;
            case MESSAGE_PROCESSING_FAILURE:
                handleMessageProcessingFailure(event);
                break;
            case RESOURCE_EXHAUSTION:
                handleResourceExhaustion(event);
                break;
            case DEPENDENCY_FAILURE:
                handleDependencyFailure(event);
                break;
        }
    }

    private FailureType classifyFailure(StreamingFailureEvent event) {
        String errorMessage = event.getErrorMessage().toLowerCase();
        
        if (errorMessage.contains("connection") || errorMessage.contains("network")) {
            return FailureType.CONNECTION_FAILURE;
        } else if (errorMessage.contains("timeout") || errorMessage.contains("processing")) {
            return FailureType.MESSAGE_PROCESSING_FAILURE;
        } else if (errorMessage.contains("memory") || errorMessage.contains("cpu")) {
            return FailureType.RESOURCE_EXHAUSTION;
        } else if (errorMessage.contains("redis") || errorMessage.contains("database")) {
            return FailureType.DEPENDENCY_FAILURE;
        }
        
        return FailureType.UNKNOWN;
    }

    private void handleConnectionFailure(StreamingFailureEvent event) {
        log.error("连接故障: sessionId={}, error={}", 
                 event.getSessionId(), event.getErrorMessage());
        
        // 1. 记录故障指标
        metricsCollector.incrementConnectionFailures();
        
        // 2. 尝试重新建立连接
        attemptConnectionRecovery(event.getSessionId());
        
        // 3. 发送告警
        alertService.sendAlert(Alert.builder()
            .type("CONNECTION_FAILURE")
            .severity(AlertSeverity.WARNING)
            .message("流式连接故障")
            .details(Map.of(
                "sessionId", event.getSessionId(),
                "error", event.getErrorMessage(),
                "timestamp", event.getTimestamp()
            ))
            .build());
        
        // 4. 启用熔断器
        CircuitBreaker cb = getCircuitBreaker("connection");
        cb.recordFailure();
    }

    private void handleResourceExhaustion(StreamingFailureEvent event) {
        log.error("资源耗尽: {}", event.getErrorMessage());
        
        // 1. 立即触发紧急措施
        emergencyResourceManagement();
        
        // 2. 发送高优先级告警
        alertService.sendAlert(Alert.builder()
            .type("RESOURCE_EXHAUSTION")
            .severity(AlertSeverity.CRITICAL)
            .message("系统资源耗尽")
            .details(Map.of(
                "error", event.getErrorMessage(),
                "currentMemoryUsage", getCurrentMemoryUsage(),
                "currentCpuUsage", getCurrentCpuUsage()
            ))
            .build());
        
        // 3. 触发自动扩容（如果配置了）
        triggerAutoScaling();
    }

    private void emergencyResourceManagement() {
        // 1. 强制垃圾回收
        System.gc();
        
        // 2. 清理缓存
        clearNonEssentialCaches();
        
        // 3. 限制新连接
        temporarilyLimitNewConnections();
        
        // 4. 降低处理频率
        reduceProcessingRate();
    }

    private CircuitBreaker getCircuitBreaker(String name) {
        return circuitBreakers.computeIfAbsent(name, key -> 
            CircuitBreaker.ofDefaults(key));
    }
}

@Component  
public class StreamingRecoveryManager {
    
    public void executeRecoveryPlan(String failureType, Map<String, Object> context) {
        RecoveryPlan plan = getRecoveryPlan(failureType);
        
        for (RecoveryStep step : plan.getSteps()) {
            try {
                log.info("执行恢复步骤: {}", step.getDescription());
                step.execute(context);
                
                // 检查恢复效果
                if (step.isRecoverySuccessful(context)) {
                    log.info("恢复步骤成功: {}", step.getDescription());
                } else {
                    log.warn("恢复步骤失败: {}", step.getDescription());
                    // 继续执行下一步骤
                }
                
            } catch (Exception e) {
                log.error("恢复步骤异常: " + step.getDescription(), e);
            }
        }
    }

    private RecoveryPlan getRecoveryPlan(String failureType) {
        switch (failureType) {
            case "CONNECTION_FAILURE":
                return RecoveryPlan.builder()
                    .addStep(new ConnectionHealthCheckStep())
                    .addStep(new ConnectionPoolResetStep())
                    .addStep(new LoadBalancerUpdateStep())
                    .build();
                    
            case "MEMORY_EXHAUSTION":
                return RecoveryPlan.builder()
                    .addStep(new ForceGarbageCollectionStep())
                    .addStep(new CacheClearStep())
                    .addStep(new ConnectionLimitStep())
                    .addStep(new AutoScalingTriggerStep())
                    .build();
                    
            default:
                return RecoveryPlan.builder()
                    .addStep(new GenericHealthCheckStep())
                    .addStep(new ServiceRestartStep())
                    .build();
        }
    }
}

// 恢复步骤实现示例
public class ConnectionPoolResetStep implements RecoveryStep {
    
    @Override
    public void execute(Map<String, Object> context) {
        SSEConnectionPool pool = getConnectionPool();
        
        // 1. 关闭所有空闲连接
        pool.closeIdleConnections();
        
        // 2. 重置连接池统计
        pool.resetStatistics();
        
        // 3. 重新初始化连接池配置
        pool.reinitialize();
    }
    
    @Override
    public boolean isRecoverySuccessful(Map<String, Object> context) {
        SSEConnectionPool pool = getConnectionPool();
        return pool.getStatistics().getActiveConnections() < 
               pool.getStatistics().getMaxConnections() * 0.8;
    }
    
    @Override
    public String getDescription() {
        return "重置连接池";
    }
}
```

### 运维监控仪表板

```typescript
interface OperationalDashboardState {
  systemHealth: SystemHealth;
  activeAlerts: Alert[];
  performanceMetrics: PerformanceMetrics;
  connectionStats: ConnectionStats;
  recentEvents: OperationalEvent[];
  recoveryActions: RecoveryAction[];
}

export const OperationalDashboard: React.FC = () => {
  const [dashboardState, setDashboardState] = useState<OperationalDashboardState>({
    systemHealth: { status: 'unknown', components: [] },
    activeAlerts: [],
    performanceMetrics: { cpu: 0, memory: 0, connections: 0, throughput: 0 },
    connectionStats: { active: 0, total: 0, failed: 0, avgDuration: 0 },
    recentEvents: [],
    recoveryActions: []
  });

  useEffect(() => {
    // WebSocket连接用于实时监控数据
    const ws = new WebSocket('ws://monitoring-service/operations');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleOperationalData(data);
    };

    // 定期刷新数据
    const interval = setInterval(fetchDashboardData, 30000);

    return () => {
      ws.close();
      clearInterval(interval);
    };
  }, []);

  const handleOperationalData = (data: any) => {
    setDashboardState(prev => {
      switch (data.type) {
        case 'system_health':
          return { ...prev, systemHealth: data.health };
        
        case 'alert':
          return {
            ...prev,
            activeAlerts: [data.alert, ...prev.activeAlerts.slice(0, 9)]
          };
        
        case 'performance_metrics':
          return { ...prev, performanceMetrics: data.metrics };
        
        case 'operational_event':
          return {
            ...prev,
            recentEvents: [data.event, ...prev.recentEvents.slice(0, 19)]
          };
        
        default:
          return prev;
      }
    });
  };

  const executeRecoveryAction = async (action: RecoveryAction) => {
    try {
      const response = await fetch('/api/operations/recovery', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(action)
      });
      
      if (response.ok) {
        notification.success({
          message: '恢复操作已执行',
          description: `${action.name} 已成功触发`
        });
      }
    } catch (error) {
      notification.error({
        message: '恢复操作失败',
        description: error.message
      });
    }
  };

  return (
    <div className="operational-dashboard">
      {/* 系统健康状态 */}
      <div className="health-overview">
        <SystemHealthCard health={dashboardState.systemHealth} />
      </div>

      {/* 活跃告警 */}
      {dashboardState.activeAlerts.length > 0 && (
        <div className="alerts-section">
          <AlertPanel 
            alerts={dashboardState.activeAlerts}
            onAcknowledge={handleAlertAcknowledge}
            onResolve={handleAlertResolve}
          />
        </div>
      )}

      {/* 性能指标 */}
      <div className="metrics-grid">
        <PerformanceMetricsCards metrics={dashboardState.performanceMetrics} />
      </div>

      {/* 连接统计 */}
      <div className="connections-section">
        <ConnectionStatsPanel stats={dashboardState.connectionStats} />
      </div>

      {/* 恢复操作面板 */}
      <div className="recovery-actions">
        <RecoveryActionsPanel 
          actions={dashboardState.recoveryActions}
          onExecute={executeRecoveryAction}
        />
      </div>

      {/* 最近事件日志 */}
      <div className="events-log">
        <EventLogPanel events={dashboardState.recentEvents} />
      </div>
    </div>
  );
};
```

## 小结

企业级部署与运维是流式通信系统成功的关键：

1. **负载均衡配置**：Nginx、HAProxy等代理服务器的流式通信优化配置
2. **网关层处理**：Spring Cloud Gateway等API网关的流式代理配置
3. **容器化部署**：Docker和Kubernetes环境下的连接管理和扩缩容
4. **健康检查策略**：多层次的健康检查和服务状态监控
5. **故障恢复机制**：自动化的故障检测、告警和恢复流程

通过这些企业级的部署和运维实践，可以确保流式通信系统在生产环境中的高可用性、高性能和高稳定性。

---

**本节关键要点：**
- 负载均衡器针对流式通信的专门配置优化
- 网关层面的流式代理处理和会话粘性管理
- 容器化环境下的连接管理和水平扩缩容策略
- 多层次健康检查和服务监控体系
- 自动化的故障检测、告警和恢复机制

**全章总结：**
本章从理论基础到实践应用，全面介绍了AI应用中流式通信的完整技术体系。从基础原理、架构设计、客户端处理、可靠性保障，到AI Agent特有的交互模式、性能优化监控，最后到企业级部署运维，形成了一个完整的知识体系。读者通过学习本章内容，能够掌握构建高性能、高可用的AI应用流式通信系统的全部技能。
