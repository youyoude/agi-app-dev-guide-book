# 3.1.3 智能体的黑盒化架构

## 学习目标
掌握如何通过基类抽象设计可插拔的智能体系统，使不同推理模式（ReAct、Planning）成为可替换的黑盒组件。

## 智能体黑盒化架构概述

智能体（Agent）是AI应用的核心执行单元，负责理解任务、制定计划、调用工具并生成结果。不同的AI场景需要采用不同的推理模式，如反应式推理（ReAct）、计划式推理（Planning）、工作流式推理等。智能体的黑盒化架构旨在通过抽象基类和统一接口，将不同推理模式封装为可替换的黑盒组件，实现智能体系统的模块化和可扩展性。

智能体黑盒化的核心理念是将智能体的通用能力（如状态管理、记忆管理、工具调用）抽象为基础框架，将特定的推理逻辑封装为可插拔的推理策略。这种设计使得系统可以根据不同的应用场景动态选择合适的推理模式，而无需修改核心框架代码。

## 智能体基类抽象设计

### 核心抽象基类

首先设计智能体的抽象基类，定义所有智能体共同的接口和基础功能：

```java
/**
 * 智能体基类 - 定义所有智能体的通用接口和基础功能
 */
@Slf4j
@Data
@Accessors(chain = true)
public abstract class BaseAgent {
    
    // 核心属性
    private String name;                    // 智能体名称
    private String description;             // 智能体描述
    private String systemPrompt;            // 系统提示词
    private String nextStepPrompt;          // 下一步提示词
    public ToolCollection availableTools = new ToolCollection();  // 可用工具集合
    private Memory memory = new Memory();   // 智能体记忆
    protected LLM llm;                     // 语言模型接口
    protected AgentContext context;        // 执行上下文
    
    // 执行控制
    private AgentState state = AgentState.IDLE;  // 智能体状态
    private int maxSteps = 10;                   // 最大执行步数
    private int currentStep = 0;                 // 当前步数
    private int duplicateThreshold = 2;          // 重复阈值
    
    // 输出控制
    Printer printer;                        // 输出打印器
    
    /**
     * 执行单个推理步骤 - 抽象方法，由子类实现具体推理逻辑
     */
    public abstract String step();
    
    /**
     * 运行智能体主循环 - 通用执行框架
     */
    public String run(String query) {
        setState(AgentState.IDLE);
        
        if (!query.isEmpty()) {
            updateMemory(RoleType.USER, query, null);
        }
        
        List<String> results = new ArrayList<>();
        try {
            while (currentStep < maxSteps && state != AgentState.FINISHED) {
                currentStep++;
                log.info("{} {} Executing step {}/{}", 
                         context.getRequestId(), getName(), currentStep, maxSteps);
                
                String stepResult = step();  // 调用子类实现的推理逻辑
                results.add(stepResult);
            }
            
            if (currentStep >= maxSteps) {
                currentStep = 0;
                state = AgentState.IDLE;
                results.add("Terminated: Reached max steps (" + maxSteps + ")");
            }
        } catch (Exception e) {
            state = AgentState.ERROR;
            throw e;
        }
        
        return results.isEmpty() ? "No steps executed" : results.get(results.size() - 1);
    }
    
    /**
     * 更新智能体记忆
     */
    public void updateMemory(RoleType role, String content, String base64Image) {
        Message message = new Message();
        message.setRole(role);
        message.setContent(content);
        message.setBase64Image(base64Image);
        memory.addMessage(message);
    }
    
    /**
     * 获取记忆中的消息列表
     */
    public List<Message> getMemoryMessages() {
        return memory.getMessages();
    }
}
```

### 智能体状态管理

定义智能体的状态枚举，支持状态的标准化管理：

```java
/**
 * 智能体状态枚举
 */
public enum AgentState {
    IDLE,           // 空闲状态
    THINKING,       // 思考状态
    ACTING,         // 执行状态
    WAITING,        // 等待状态
    FINISHED,       // 完成状态
    ERROR;          // 错误状态
}
```

### 智能体类型定义

定义不同类型的智能体，支持类型化管理：

```java
/**
 * 智能体类型枚举
 */
public enum AgentType {
    COMPREHENSIVE(1),    // 综合型智能体
    WORKFLOW(2),         // 工作流智能体
    PLAN_SOLVE(3),       // 计划解决型智能体
    ROUTER(4),           // 路由型智能体
    REACT(5);            // 反应型智能体
    
    private final Integer value;
    
    AgentType(Integer value) {
        this.value = value;
    }
    
    public Integer getValue() {
        return value;
    }
    
    public static AgentType fromCode(int value) {
        for (AgentType type : AgentType.values()) {
            if (type.value == value) {
                return type;
            }
        }
        throw new IllegalArgumentException("Invalid AgentType code: " + value);
    }
}
```

## 推理模式的黑盒化实现

### ReAct推理模式

ReAct（Reasoning and Acting）是一种将推理和行动结合的推理模式：

```java
/**
 * ReAct智能体 - 基于ReAct推理模式的智能体实现
 */
@Data
@Slf4j
@EqualsAndHashCode(callSuper = true)
public abstract class ReActAgent extends BaseAgent {
    
    /**
     * 思考过程 - 分析当前情况并决定下一步行动
     */
    public abstract boolean think();
    
    /**
     * 执行行动 - 根据思考结果执行具体行动
     */
    public abstract String act();
    
    /**
     * 执行单个推理步骤 - 实现基类抽象方法
     */
    @Override
    public String step() {
        boolean shouldAct = think();    // 先思考
        if (!shouldAct) {
            return "Thinking complete - no action needed";
        }
        return act();                   // 再行动
    }
}
```

ReAct智能体的具体实现：

```java
/**
 * ReAct智能体具体实现
 */
@Data
@Slf4j
@EqualsAndHashCode(callSuper = true)
public class ReactImplAgent extends ReActAgent {
    
    @Override
    public boolean think() {
        try {
            setState(AgentState.THINKING);
            
            // 构建思考提示词
            List<Message> messages = buildThinkingMessages();
            
            // 调用LLM进行思考
            CompletableFuture<String> future = llm.ask(
                getContext(), messages, null, false, null);
            String thinkingResult = future.get();
            
            // 更新记忆
            updateMemory(RoleType.ASSISTANT, thinkingResult, null);
            
            // 判断是否需要进一步行动
            return analyzeNeedForAction(thinkingResult);
            
        } catch (Exception e) {
            log.error("{} Error in thinking process", getContext().getRequestId(), e);
            setState(AgentState.ERROR);
            return false;
        }
    }
    
    @Override
    public String act() {
        try {
            setState(AgentState.ACTING);
            
            // 构建行动提示词
            List<Message> messages = buildActionMessages();
            
            // 调用LLM生成行动计划
            CompletableFuture<String> future = llm.askWithTools(
                getContext(), messages, null, 
                availableTools.getAllTools(), 
                ToolChoice.AUTO, false, null);
                
            String actionResult = future.get();
            
            // 解析并执行工具调用
            return executeToolCalls(actionResult);
            
        } catch (Exception e) {
            log.error("{} Error in action process", getContext().getRequestId(), e);
            setState(AgentState.ERROR);
            return "Action execution failed: " + e.getMessage();
        }
    }
}
```

### Planning推理模式

Planning推理模式先制定完整计划，再逐步执行：

```java
/**
 * 计划式智能体 - 基于Planning推理模式的智能体实现
 */
@Data
@Slf4j
@EqualsAndHashCode(callSuper = true)
public class PlanningAgent extends BaseAgent {
    
    private List<Plan> executionPlan = new ArrayList<>();  // 执行计划
    private int currentPlanStep = 0;                       // 当前计划步骤
    
    /**
     * 制定执行计划
     */
    public List<Plan> makePlan(String query) {
        try {
            setState(AgentState.THINKING);
            
            // 构建计划制定提示词
            List<Message> messages = buildPlanningMessages(query);
            
            // 调用LLM制定计划
            CompletableFuture<String> future = llm.ask(
                getContext(), messages, null, false, null);
            String planResult = future.get();
            
            // 解析计划
            List<Plan> plans = parsePlans(planResult);
            this.executionPlan = plans;
            
            return plans;
            
        } catch (Exception e) {
            log.error("{} Error in planning process", getContext().getRequestId(), e);
            setState(AgentState.ERROR);
            return new ArrayList<>();
        }
    }
    
    /**
     * 执行单个推理步骤 - 按计划执行
     */
    @Override
    public String step() {
        if (executionPlan.isEmpty()) {
            // 如果没有计划，先制定计划
            String query = getContext().getQuery();
            makePlan(query);
        }
        
        if (currentPlanStep >= executionPlan.size()) {
            setState(AgentState.FINISHED);
            return "All planned steps completed";
        }
        
        // 执行当前计划步骤
        Plan currentPlan = executionPlan.get(currentPlanStep);
        String result = executePlanStep(currentPlan);
        
        currentPlanStep++;
        
        return result;
    }
    
    /**
     * 执行计划步骤
     */
    private String executePlanStep(Plan plan) {
        try {
            setState(AgentState.ACTING);
            
            log.info("Executing plan step: {}", plan.getDescription());
            
            // 根据计划调用相应工具
            if (plan.getToolName() != null) {
                Object result = availableTools.execute(
                    plan.getToolName(), plan.getParameters());
                return "Plan step completed: " + result.toString();
            } else {
                // 如果不需要调用工具，直接完成
                return "Plan step completed: " + plan.getDescription();
            }
            
        } catch (Exception e) {
            log.error("Error executing plan step: {}", plan.getDescription(), e);
            return "Plan step failed: " + e.getMessage();
        }
    }
}
```

## 智能体工厂模式

为了实现智能体的动态创建和管理，采用工厂模式：

```java
/**
 * 智能体处理器工厂 - 根据请求类型创建相应的智能体处理器
 */
@Component
public class AgentHandlerFactory {
    
    private final Map<String, AgentHandlerService> handlerMap = new ConcurrentHashMap<>();
    
    @Autowired
    public AgentHandlerFactory(List<AgentHandlerService> handlers) {
        // 初始化处理器映射
        for (AgentHandlerService handler : handlers) {
            handlerMap.put(handler.getClass().getSimpleName().toLowerCase(), handler);
        }
    }
    
    /**
     * 根据上下文和请求获取合适的智能体处理器
     */
    public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
        if (Objects.isNull(context) || Objects.isNull(request)) {
            return null;
        }
        
        // 通过支持性检查匹配合适的处理器
        for (AgentHandlerService handler : handlerMap.values()) {
            if (handler.support(context, request)) {
                return handler;
            }
        }
        
        return null;
    }
}
```

### 智能体处理器接口

定义智能体处理器的统一接口：

```java
/**
 * 智能体处理服务接口
 */
public interface AgentHandlerService {
    
    /**
     * 检查是否支持处理指定的请求
     */
    boolean support(AgentContext context, AgentRequest request);
    
    /**
     * 处理智能体请求
     */
    CompletableFuture<String> handle(AgentContext context, AgentRequest request);
}
```

### ReAct处理器实现

```java
/**
 * ReAct智能体处理器实现
 */
@Service
@Slf4j
public class ReactHandlerImpl implements AgentHandlerService {
    
    @Override
    public boolean support(AgentContext context, AgentRequest request) {
        return AgentType.REACT.equals(request.getAgentType());
    }
    
    @Override
    public CompletableFuture<String> handle(AgentContext context, AgentRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 创建ReAct智能体
                ReactImplAgent agent = new ReactImplAgent();
                agent.setContext(context);
                agent.setName("ReAct Agent");
                agent.setAvailableTools(buildToolCollection(context, request));
                agent.setLlm(createLLM(request));
                
                // 执行智能体任务
                return agent.run(request.getQuery());
                
            } catch (Exception e) {
                log.error("ReAct agent execution failed", e);
                throw new RuntimeException("ReAct agent execution failed", e);
            }
        });
    }
}
```

### Planning处理器实现

```java
/**
 * Planning智能体处理器实现
 */
@Service
@Slf4j
public class PlanSolveHandlerImpl implements AgentHandlerService {
    
    @Override
    public boolean support(AgentContext context, AgentRequest request) {
        return AgentType.PLAN_SOLVE.equals(request.getAgentType());
    }
    
    @Override
    public CompletableFuture<String> handle(AgentContext context, AgentRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 创建Planning智能体
                PlanningAgent agent = new PlanningAgent();
                agent.setContext(context);
                agent.setName("Planning Agent");
                agent.setAvailableTools(buildToolCollection(context, request));
                agent.setLlm(createLLM(request));
                
                // 执行智能体任务
                return agent.run(request.getQuery());
                
            } catch (Exception e) {
                log.error("Planning agent execution failed", e);
                throw new RuntimeException("Planning agent execution failed", e);
            }
        });
    }
}
```

## 智能体黑盒化的优势

### 1. 推理模式可替换
通过抽象基类和策略模式，可以轻松切换不同的推理模式，满足不同场景需求。

### 2. 代码复用性高
通用功能（状态管理、记忆管理、工具调用等）在基类中实现，避免代码重复。

### 3. 扩展性强
新增推理模式只需继承基类并实现特定方法，无需修改现有代码。

### 4. 测试友好
每种推理模式都是独立的黑盒组件，可以独立进行单元测试。

### 5. 配置驱动
通过配置可以动态选择智能体类型，提升系统灵活性。

## 实践建议

### 1. 基类设计原则
- 将通用功能抽象到基类
- 定义清晰的抽象方法
- 提供合理的默认实现
- 支持配置和扩展

### 2. 状态管理
- 定义明确的状态转换规则
- 实现状态持久化机制
- 提供状态恢复能力
- 支持状态监控

### 3. 错误处理
- 建立统一的异常处理机制
- 提供错误恢复策略
- 实现详细的错误日志
- 支持错误通知

### 4. 性能优化
- 实现智能体池化管理
- 支持异步执行
- 实现缓存机制
- 监控性能指标

## 小结

智能体的黑盒化架构通过抽象基类、策略模式、工厂模式等设计模式，实现了不同推理模式的可插拔和可替换。这种架构设计不仅提升了代码的复用性和可维护性，还为AI应用的智能体系统提供了灵活的扩展能力。

在实际应用中，智能体黑盒化架构需要考虑状态管理、错误处理、性能优化等多个方面。通过合理的抽象设计和规范的实现方式，可以构建出高效、稳定、易扩展的智能体系统，为复杂的AI应用场景提供强有力的支撑。
