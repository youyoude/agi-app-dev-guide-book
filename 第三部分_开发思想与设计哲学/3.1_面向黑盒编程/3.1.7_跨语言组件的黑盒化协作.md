# 3.1.7 跨语言组件的黑盒化协作

## 学习目标
理解如何在多语言系统中通过HTTP/RPC实现黑盒化的服务间通信，构建松耦合的分布式架构。

## 跨语言组件协作的必要性

现代AGI应用系统往往需要结合多种编程语言的优势：Java的企业级稳定性、Python的AGI生态丰富性、JavaScript的前端交互能力等。跨语言黑盒化协作能够：

1. **语言无关性**：各组件独立选择最适合的技术栈
2. **松耦合架构**：通过标准化接口实现组件解耦  
3. **独立部署**：每个组件可独立开发、测试、部署
4. **技术栈灵活性**：便于引入新技术或替换现有技术

## joyagent-jdgenie系统架构

### 系统架构

```
┌─────────────────┐    HTTP/SSE    ┌─────────────────┐    HTTP    ┌─────────────────┐
│   React前端     │ ◄─────────────► │   Java后端      │ ◄─────────► │  Python工具服务  │
│   (UI层)        │                │  (业务逻辑层)    │             │   (AI能力层)     │
└─────────────────┘                └─────────────────┘             └─────────────────┘
```

- **React前端**：用户界面、交互体验
- **Java后端**：业务逻辑、智能体管理  
- **Python工具服务**：AGI模型调用、代码执行

## HTTP通信实现

### 统一API调用

```java
/**
 * 跨语言服务调用接口
 */
@RestController
@Slf4j
public class CrossLanguageApiController {
    
    private final OkHttpClient httpClient;
    
    @PostMapping("/tools/code-interpreter")
    public CompletableFuture<ResponseEntity<Object>> callCodeInterpreter(
            @RequestBody CodeInterpreterRequest request) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                String url = genieConfig.getCodeInterpreterUrl() + "/v1/tool/code_interpreter";
                
                RequestBody body = RequestBody.create(
                    MediaType.parse("application/json"),
                    JSON.toJSONString(request)
                );
                
                Request httpRequest = new Request.Builder()
                    .url(url)
                    .post(body)
                    .addHeader("Content-Type", "application/json")
                    .build();
                
                try (Response response = httpClient.newCall(httpRequest).execute()) {
                    if (response.isSuccessful()) {
                        return ResponseEntity.ok(JSON.parseObject(response.body().string()));
                    } else {
                        return ResponseEntity.status(response.code())
                            .body(Collections.singletonMap("error", response.message()));
                    }
                }
                
            } catch (Exception e) {
                log.error("Service call failed", e);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Collections.singletonMap("error", e.getMessage()));
            }
        });
    }
}
```

### 流式通信

```java
/**
 * SSE流式通信
 */
@PostMapping(value = "/stream/chat", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public SseEmitter streamResponse(@RequestBody AgentRequest request) {
    
    SseEmitter emitter = new SseEmitter(300000L);
    
    CompletableFuture.runAsync(() -> {
        try {
            String url = pythonServiceUrl + "/v1/stream/process";
            // 调用Python流式服务并转发结果
            callPythonStreamService(url, request, emitter);
        } catch (Exception e) {
            emitter.completeWithError(e);
        }
    });
    
    return emitter;
}
```

## 服务注册与发现

### 服务注册中心

```java
/**
 * 服务注册中心
 */
@Component
@Slf4j
public class ServiceRegistry {
    
    private final Map<String, ServiceInstance> services = new ConcurrentHashMap<>();
    
    /**
     * 注册服务
     */
    public void registerService(String name, String url, String language) {
        ServiceInstance instance = ServiceInstance.builder()
            .serviceName(name)
            .serviceUrl(url)
            .language(language)
            .status(ServiceStatus.UNKNOWN)
            .build();
            
        services.put(name, instance);
        log.info("Registered service: {} ({})", name, language);
    }
    
    /**
     * 获取健康的服务实例
     */
    public ServiceInstance getService(String name) {
        ServiceInstance instance = services.get(name);
        return (instance != null && instance.getStatus() == ServiceStatus.HEALTHY) 
            ? instance : null;
    }
    
    /**
     * 健康检查
     */
    @Scheduled(fixedRate = 30000)
    public void healthCheck() {
        services.values().forEach(this::checkHealth);
    }
    
    private void checkHealth(ServiceInstance instance) {
        try {
            Request request = new Request.Builder()
                .url(instance.getServiceUrl() + "/health")
                .get()
                .build();
                
            try (Response response = httpClient.newCall(request).execute()) {
                ServiceStatus status = response.isSuccessful() 
                    ? ServiceStatus.HEALTHY : ServiceStatus.UNHEALTHY;
                instance.setStatus(status);
            }
        } catch (Exception e) {
            instance.setStatus(ServiceStatus.UNHEALTHY);
        }
    }
}
```

### 服务实例模型

```java
@Data
@Builder
public class ServiceInstance {
    private String serviceName;
    private String serviceUrl;
    private String language;
    private ServiceStatus status;
    private long registeredAt;
}

public enum ServiceStatus {
    UNKNOWN, HEALTHY, UNHEALTHY
}
```

## 错误处理与重试

### 重试机制

```java
/**
 * 服务调用重试处理
 */
@Component
public class RetryHandler {
    
    private final int maxRetries = 3;
    private final int baseDelay = 1000;
    
    public <T> CompletableFuture<T> callWithRetry(
            String serviceName,
            Supplier<CompletableFuture<T>> serviceCall) {
        
        return callWithRetry(serviceCall, 0);
    }
    
    private <T> CompletableFuture<T> callWithRetry(
            Supplier<CompletableFuture<T>> serviceCall, 
            int attempt) {
        
        return serviceCall.get()
            .handle((result, error) -> {
                if (error != null && attempt < maxRetries) {
                    // 指数退避重试
                    int delay = baseDelay * (int) Math.pow(2, attempt);
                    try {
                        Thread.sleep(delay);
                        return callWithRetry(serviceCall, attempt + 1).join();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException(e);
                    }
                }
                
                if (error != null) {
                    throw new RuntimeException("Service call failed after retries", error);
                }
                
                return result;
            });
    }
}
```

## Python服务示例

### FastAPI服务

```python
"""Python工具服务示例"""
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional, List

app = FastAPI()

class ToolRequest(BaseModel):
    requestId: str
    task: str
    parameters: Optional[dict] = None

@app.post("/v1/tool/code_interpreter")
async def code_interpreter(request: ToolRequest):
    """代码解释器接口"""
    try:
        # 执行代码解释逻辑
        result = await execute_code_task(request.task)
        return {
            "success": True,
            "data": result
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy"}
```

## 实践建议

### 1. 接口标准化
- 定义统一的请求/响应格式
- 使用版本化的API接口  
- 实现标准的错误码体系

### 2. 通信协议选择
- HTTP/REST：适合同步调用
- WebSocket/SSE：适合流式数据
- gRPC：适合高性能通信

### 3. 服务治理
- 实现服务注册发现
- 建立健康检查机制
- 提供负载均衡功能

### 4. 安全认证
- 实施API认证
- 使用HTTPS加密
- 参数验证和清理

## 小结

跨语言组件的黑盒化协作通过HTTP/REST API、流式通信、服务注册发现等技术，实现了多语言系统的松耦合集成。这种架构充分发挥不同语言优势，提供灵活部署和良好可维护性，为AGI应用构建奠定技术基础。