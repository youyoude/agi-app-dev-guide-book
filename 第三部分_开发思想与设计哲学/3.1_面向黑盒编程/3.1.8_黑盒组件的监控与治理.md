# 3.1.8 黑盒组件的监控与治理

## 学习目标
- 掌握黑盒组件的全面监控策略和实现方法
- 学会建立完善的健康检查、错误处理和性能监控机制
- 理解可观测性工程在AI应用中的实践要点
- 掌握故障诊断、自动恢复和容量规划的方法

## 监控治理的重要性与挑战

面向黑盒编程的AI应用系统中，各组件通过接口解耦，虽然提升了系统的灵活性，但也带来了新的挑战：

### 主要挑战
1. **可见性缺失**：黑盒组件内部状态不可直接观察
2. **故障传播**：单个组件故障可能引发连锁反应
3. **性能瓶颈定位**：分布式调用链中的性能问题难以定位
4. **资源使用优化**：缺乏细粒度的资源使用监控
5. **SLA保障**：需要端到端的服务质量监控

### 核心价值
1. **全方位可观测性**：提供系统运行状态的完整视图
2. **主动故障预警**：在问题影响用户前及时发现和处理
3. **数据驱动优化**：基于监控数据进行性能优化和容量规划
4. **智能运维支撑**：为自动化运维和决策提供数据基础
5. **合规性保障**：满足企业级应用的审计和合规要求

## 健康检查机制

### 分层健康检查体系

黑盒组件的健康检查需要建立多层次的检查体系：

```
┌─────────────────────────────────────────┐
│            健康检查体系                  │
├─────────────────────────────────────────┤
│  应用层健康检查                          │
│  ├─ 业务逻辑健康状态                     │
│  ├─ 智能体状态检查                       │
│  └─ 工具可用性检查                       │
├─────────────────────────────────────────┤
│  服务层健康检查                          │
│  ├─ HTTP接口响应检查                     │
│  ├─ 数据库连接检查                       │
│  └─ 外部服务依赖检查                     │
├─────────────────────────────────────────┤
│  基础设施健康检查                        │
│  ├─ CPU/内存使用率                       │
│  ├─ 磁盘空间检查                         │
│  └─ 网络连通性检查                       │
└─────────────────────────────────────────┘
```

### 健康检查接口标准

```java
/**
 * 健康检查接口
 */
public interface HealthCheckable {
    /**
     * 基础健康检查
     */
    HealthStatus checkHealth();
    
    /**
     * 详细健康检查
     */
    DetailedHealthStatus checkDetailedHealth();
    
    /**
     * 依赖服务检查
     */
    Map<String, HealthStatus> checkDependencies();
}

/**
 * 健康状态枚举
 */
public enum HealthStatus {
    HEALTHY("健康"),
    DEGRADED("降级"),
    UNHEALTHY("不健康"), 
    UNKNOWN("未知");
    
    private final String description;
    
    HealthStatus(String description) {
        this.description = description;
    }
}

/**
 * 详细健康状态
 */
@Data
@Builder
public class DetailedHealthStatus {
    private HealthStatus status;
    private String message;
    private Map<String, Object> details;
    private long timestamp;
    private Map<String, HealthStatus> dependencies;
}
```

### 智能健康检查实现

```java
/**
 * AI应用健康检查器
 */
@Component
@Slf4j
public class AIHealthChecker implements HealthCheckable {
    
    @Autowired
    private LLMService llmService;
    
    @Autowired
    private ToolCollection toolCollection;
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public HealthStatus checkHealth() {
        try {
            // 快速健康检查
            if (!checkBasicConnectivity()) {
                return HealthStatus.UNHEALTHY;
            }
            
            if (!checkCriticalServices()) {
                return HealthStatus.DEGRADED;
            }
            
            return HealthStatus.HEALTHY;
        } catch (Exception e) {
            log.error("Health check failed", e);
            return HealthStatus.UNKNOWN;
        }
    }
    
    @Override
    public DetailedHealthStatus checkDetailedHealth() {
        Map<String, Object> details = new HashMap<>();
        Map<String, HealthStatus> dependencies = new HashMap<>();
        
        // 检查LLM服务
        HealthStatus llmStatus = checkLLMService();
        dependencies.put("llm_service", llmStatus);
        details.put("llm_models", getLLMModelsStatus());
        
        // 检查工具系统
        HealthStatus toolStatus = checkToolSystem();
        dependencies.put("tool_system", toolStatus);
        details.put("available_tools", getAvailableToolsCount());
        
        // 检查数据库
        HealthStatus dbStatus = checkDatabase();
        dependencies.put("database", dbStatus);
        details.put("db_connections", getDbConnectionPoolStatus());
        
        // 检查系统资源
        details.put("memory_usage", getMemoryUsage());
        details.put("cpu_usage", getCpuUsage());
        details.put("disk_usage", getDiskUsage());
        
        // 综合评估整体状态
        HealthStatus overallStatus = evaluateOverallStatus(dependencies);
        
        return DetailedHealthStatus.builder()
            .status(overallStatus)
            .message(generateHealthMessage(overallStatus, dependencies))
            .details(details)
            .dependencies(dependencies)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    private HealthStatus checkLLMService() {
        try {
            // 发送简单的测试请求
            CompletableFuture<String> testResult = llmService.ask(
                createTestContext(), 
                Arrays.asList(createTestMessage()),
                null, false, 0.1
            );
            
            String result = testResult.get(5, TimeUnit.SECONDS);
            return result != null ? HealthStatus.HEALTHY : HealthStatus.DEGRADED;
        } catch (Exception e) {
            log.warn("LLM service health check failed", e);
            return HealthStatus.UNHEALTHY;
        }
    }
    
    private HealthStatus checkToolSystem() {
        try {
            int availableTools = toolCollection.getAvailableToolsCount();
            if (availableTools == 0) {
                return HealthStatus.UNHEALTHY;
            }
            
            // 测试关键工具
            boolean criticalToolsWorking = testCriticalTools();
            return criticalToolsWorking ? HealthStatus.HEALTHY : HealthStatus.DEGRADED;
        } catch (Exception e) {
            return HealthStatus.UNHEALTHY;
        }
    }
}
```

### HTTP健康检查端点

```java
/**
 * 健康检查REST接口
 */
@RestController
@RequestMapping("/health")
@Slf4j
public class HealthController {
    
    @Autowired
    private AIHealthChecker healthChecker;
    
    /**
     * 基础健康检查端点
     */
    @GetMapping
    public ResponseEntity<Map<String, Object>> health() {
        try {
            HealthStatus status = healthChecker.checkHealth();
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", status.name().toLowerCase());
            response.put("timestamp", System.currentTimeMillis());
            
            HttpStatus httpStatus = mapToHttpStatus(status);
            return ResponseEntity.status(httpStatus).body(response);
        } catch (Exception e) {
            log.error("Health check endpoint error", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Collections.singletonMap("status", "error"));
        }
    }
    
    /**
     * 详细健康检查端点
     */
    @GetMapping("/detailed")
    public ResponseEntity<DetailedHealthStatus> detailedHealth() {
        try {
            DetailedHealthStatus status = healthChecker.checkDetailedHealth();
            HttpStatus httpStatus = mapToHttpStatus(status.getStatus());
            return ResponseEntity.status(httpStatus).body(status);
        } catch (Exception e) {
            log.error("Detailed health check error", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * 就绪检查端点（Kubernetes）
     */
    @GetMapping("/ready")
    public ResponseEntity<Map<String, Object>> readiness() {
        DetailedHealthStatus status = healthChecker.checkDetailedHealth();
        boolean ready = status.getStatus() != HealthStatus.UNHEALTHY;
        
        Map<String, Object> response = new HashMap<>();
        response.put("ready", ready);
        response.put("status", status.getStatus().name().toLowerCase());
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * 存活检查端点（Kubernetes）
     */
    @GetMapping("/live")
    public ResponseEntity<Map<String, Object>> liveness() {
        // 简单的存活检查，只要进程在运行就返回成功
        Map<String, Object> response = new HashMap<>();
        response.put("alive", true);
        response.put("timestamp", System.currentTimeMillis());
        
        return ResponseEntity.ok(response);
    }
    
    private HttpStatus mapToHttpStatus(HealthStatus status) {
        switch (status) {
            case HEALTHY:
                return HttpStatus.OK;
            case DEGRADED:
                return HttpStatus.OK; // 降级状态仍返回200，但在响应体中标明
            case UNHEALTHY:
                return HttpStatus.SERVICE_UNAVAILABLE;
            case UNKNOWN:
            default:
                return HttpStatus.INTERNAL_SERVER_ERROR;
        }
    }
}
```

## 性能监控体系

### 多维度指标收集

AI应用的性能监控需要覆盖多个维度：

```java
/**
 * AI应用性能指标收集器
 */
@Component
@Slf4j
public class AIMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Timer.Sample sample;
    
    /**
     * 记录智能体执行时间
     */
    public void recordAgentExecution(String agentType, String operation, long duration, boolean success) {
        Timer.builder("agi.agent.execution.time")
            .tag("agent_type", agentType)
            .tag("operation", operation)
            .tag("success", String.valueOf(success))
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 记录LLM调用指标
     */
    public void recordLLMCall(String provider, String model, int inputTokens, int outputTokens, long duration) {
        // 调用次数
        Counter.builder("agi.llm.calls.total")
            .tag("provider", provider)
            .tag("model", model)
            .register(meterRegistry)
            .increment();
            
        // Token使用量
        Counter.builder("agi.llm.tokens.total")
            .tag("provider", provider)
            .tag("model", model)
            .tag("type", "input")
            .register(meterRegistry)
            .increment(inputTokens);
            
        Counter.builder("agi.llm.tokens.total")
            .tag("provider", provider)
            .tag("model", model)
            .tag("type", "output")
            .register(meterRegistry)
            .increment(outputTokens);
            
        // 响应时间
        Timer.builder("agi.llm.response.time")
            .tag("provider", provider)
            .tag("model", model)
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 记录工具调用指标
     */
    public void recordToolExecution(String toolName, long duration, boolean success, String errorType) {
        Timer.builder("agi.tool.execution.time")
            .tag("tool", toolName)
            .tag("success", String.valueOf(success))
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
            
        if (!success && errorType != null) {
            Counter.builder("agi.tool.errors.total")
                .tag("tool", toolName)
                .tag("error_type", errorType)
                .register(meterRegistry)
                .increment();
        }
    }
    
    /**
     * 记录业务指标
     */
    public void recordBusinessMetrics(String requestType, int userCount, double satisfaction) {
        // 用户请求类型分布
        Counter.builder("agi.requests.total")
            .tag("type", requestType)
            .register(meterRegistry)
            .increment();
            
        // 用户满意度
        Gauge.builder("agi.user.satisfaction")
            .tag("type", requestType)
            .register(meterRegistry, satisfaction, Double::doubleValue);
    }
}
```

### AOP性能监控

```java
/**
 * 性能监控切面
 */
@Aspect
@Component
@Slf4j
public class PerformanceMonitoringAspect {
    
    @Autowired
    private AIMetricsCollector metricsCollector;
    
    /**
     * 监控智能体执行
     */
    @Around("@annotation(MonitorAgent)")
    public Object monitorAgent(ProceedingJoinPoint joinPoint, MonitorAgent annotation) throws Throwable {
        long startTime = System.currentTimeMillis();
        String agentType = annotation.agentType();
        String operation = joinPoint.getSignature().getName();
        boolean success = false;
        
        try {
            Object result = joinPoint.proceed();
            success = true;
            return result;
        } catch (Exception e) {
            log.error("Agent execution failed: {}.{}", agentType, operation, e);
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordAgentExecution(agentType, operation, duration, success);
        }
    }
    
    /**
     * 监控工具调用
     */
    @Around("execution(* com.agi.tools.*.execute(..))")
    public Object monitorToolExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        String toolName = joinPoint.getTarget().getClass().getSimpleName();
        boolean success = false;
        String errorType = null;
        
        try {
            Object result = joinPoint.proceed();
            success = true;
            return result;
        } catch (Exception e) {
            errorType = e.getClass().getSimpleName();
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordToolExecution(toolName, duration, success, errorType);
        }
    }
}

/**
 * 智能体监控注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MonitorAgent {
    String agentType();
}
```

## 分布式链路追踪

### 链路追踪实现

```java
/**
 * AI应用链路追踪
 */
@Component
@Slf4j
public class AITracing {
    
    private final Tracer tracer;
    
    /**
     * 创建智能体执行Span
     */
    public Span createAgentSpan(String agentName, String operation, AgentContext context) {
        return tracer.nextSpan()
            .name("agent." + agentName + "." + operation)
            .tag("agent.name", agentName)
            .tag("agent.operation", operation)
            .tag("request.id", context.getRequestId())
            .tag("session.id", context.getSessionId())
            .start();
    }
    
    /**
     * 创建LLM调用Span
     */
    public Span createLLMSpan(String provider, String model, String operation) {
        return tracer.nextSpan()
            .name("llm." + provider + "." + operation)
            .tag("llm.provider", provider)
            .tag("llm.model", model)
            .tag("llm.operation", operation)
            .start();
    }
    
    /**
     * 创建工具调用Span
     */
    public Span createToolSpan(String toolName, String operation) {
        return tracer.nextSpan()
            .name("tool." + toolName + "." + operation)
            .tag("tool.name", toolName)
            .tag("tool.operation", operation)
            .start();
    }
}
```

## 结构化日志与审计

### 结构化日志实现

```java
/**
 * AI应用结构化日志
 */
@Component
@Slf4j
public class AIStructuredLogger {
    
    private final ObjectMapper objectMapper;
    
    /**
     * 记录智能体执行日志
     */
    public void logAgentExecution(String agentName, String operation, AgentContext context, 
                                 Object result, long duration, Exception error) {
        Map<String, Object> logEntry = new HashMap<>();
        logEntry.put("timestamp", Instant.now().toString());
        logEntry.put("level", error == null ? "INFO" : "ERROR");
        logEntry.put("category", "agent_execution");
        logEntry.put("agent_name", agentName);
        logEntry.put("operation", operation);
        logEntry.put("request_id", context.getRequestId());
        logEntry.put("session_id", context.getSessionId());
        logEntry.put("duration_ms", duration);
        
        if (result != null) {
            logEntry.put("result_type", result.getClass().getSimpleName());
        }
        
        if (error != null) {
            logEntry.put("error_type", error.getClass().getSimpleName());
            logEntry.put("error_message", error.getMessage());
        }
        
        try {
            String jsonLog = objectMapper.writeValueAsString(logEntry);
            if (error == null) {
                log.info(jsonLog);
            } else {
                log.error(jsonLog);
            }
        } catch (Exception e) {
            log.error("Failed to write structured log", e);
        }
    }
    
    /**
     * 记录LLM调用日志
     */
    public void logLLMCall(String provider, String model, String prompt, String response, 
                          int inputTokens, int outputTokens, long duration) {
        Map<String, Object> logEntry = new HashMap<>();
        logEntry.put("timestamp", Instant.now().toString());
        logEntry.put("level", "INFO");
        logEntry.put("category", "llm_call");
        logEntry.put("provider", provider);
        logEntry.put("model", model);
        logEntry.put("input_tokens", inputTokens);
        logEntry.put("output_tokens", outputTokens);
        logEntry.put("duration_ms", duration);
        logEntry.put("prompt_hash", hashContent(prompt));
        logEntry.put("response_hash", hashContent(response));
        
        try {
            log.info(objectMapper.writeValueAsString(logEntry));
        } catch (Exception e) {
            log.error("Failed to write LLM call log", e);
        }
    }
    
    /**
     * 记录安全审计日志
     */
    public void logSecurityEvent(String eventType, String userId, String operation, 
                                Map<String, Object> details, boolean success) {
        Map<String, Object> logEntry = new HashMap<>();
        logEntry.put("timestamp", Instant.now().toString());
        logEntry.put("level", success ? "INFO" : "WARN");
        logEntry.put("category", "security_audit");
        logEntry.put("event_type", eventType);
        logEntry.put("user_id", userId);
        logEntry.put("operation", operation);
        logEntry.put("success", success);
        logEntry.put("details", details);
        
        try {
            log.info(objectMapper.writeValueAsString(logEntry));
        } catch (Exception e) {
            log.error("Failed to write security audit log", e);
        }
    }
    
    private String hashContent(String content) {
        if (content == null) return null;
        return Integer.toHexString(content.hashCode());
    }
}
```

## 智能告警机制

### 告警规则引擎

```java
/**
 * AI应用告警规则引擎
 */
@Component
@Slf4j
public class AIAlertEngine {
    
    private final List<AlertRule> alertRules = new ArrayList<>();
    private final NotificationService notificationService;
    private final MeterRegistry meterRegistry;
    
    @PostConstruct
    public void initializeAlertRules() {
        // LLM服务异常告警
        alertRules.add(new ThresholdAlertRule(
            "llm_error_rate",
            "LLM调用错误率过高",
            () -> getLLMErrorRate(),
            0.05, // 5%错误率阈值
            Duration.ofMinutes(5)
        ));
        
        // 智能体执行超时告警
        alertRules.add(new ThresholdAlertRule(
            "agent_timeout_rate", 
            "智能体执行超时率过高",
            () -> getAgentTimeoutRate(),
            0.1, // 10%超时率阈值
            Duration.ofMinutes(3)
        ));
        
        // 系统资源告警
        alertRules.add(new ThresholdAlertRule(
            "memory_usage",
            "内存使用率过高", 
            () -> getMemoryUsage(),
            0.85, // 85%内存使用率阈值
            Duration.ofMinutes(2)
        ));
        
        // 用户满意度告警
        alertRules.add(new ThresholdAlertRule(
            "user_satisfaction",
            "用户满意度下降",
            () -> getUserSatisfaction(),
            0.7, // 70%满意度阈值（低于此值告警）
            Duration.ofMinutes(10),
            true // 反向告警（低于阈值时告警）
        ));
    }
    
    @Scheduled(fixedRate = 30000) // 每30秒检查一次
    public void checkAlerts() {
        for (AlertRule rule : alertRules) {
            try {
                if (rule.shouldAlert()) {
                    Alert alert = rule.createAlert();
                    sendAlert(alert);
                    
                    // 记录告警指标
                    Counter.builder("agi.alerts.triggered")
                        .tag("rule", rule.getName())
                        .tag("severity", alert.getSeverity().name())
                        .register(meterRegistry)
                        .increment();
                }
            } catch (Exception e) {
                log.error("Alert rule check failed: {}", rule.getName(), e);
            }
        }
    }
    
    private void sendAlert(Alert alert) {
        try {
            notificationService.sendAlert(alert);
            log.warn("Alert triggered: {} - {}", alert.getTitle(), alert.getMessage());
        } catch (Exception e) {
            log.error("Failed to send alert: {}", alert.getTitle(), e);
        }
    }
    
    // 指标计算方法
    private double getLLMErrorRate() {
        // 从metrics中计算LLM错误率
        return calculateErrorRate("agi.llm.calls.total", "agi.llm.errors.total");
    }
    
    private double getAgentTimeoutRate() {
        // 计算智能体超时率
        return calculateTimeoutRate("agi.agent.execution.time");
    }
    
    private double getMemoryUsage() {
        // 获取JVM内存使用率
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        return (double) heapUsage.getUsed() / heapUsage.getMax();
    }
    
    private double getUserSatisfaction() {
        // 计算用户满意度
        return calculateAverageGaugeValue("agi.user.satisfaction");
    }
}

/**
 * 告警规则接口
 */
public interface AlertRule {
    String getName();
    boolean shouldAlert();
    Alert createAlert();
}

/**
 * 阈值告警规则
 */
public class ThresholdAlertRule implements AlertRule {
    private final String name;
    private final String description;
    private final Supplier<Double> metricSupplier;
    private final double threshold;
    private final Duration checkWindow;
    private final boolean reverse; // 是否反向告警
    
    // 构造方法和实现...
}
```

## 自动化运维与故障恢复

### 自愈机制

```java
/**
 * AI应用自愈系统
 */
@Component
@Slf4j
public class AISelfHealingSystem {
    
    @Autowired
    private AIHealthChecker healthChecker;
    
    @Autowired
    private ServiceRegistry serviceRegistry;
    
    @EventListener
    public void handleHealthDegradation(HealthDegradationEvent event) {
        String componentName = event.getComponentName();
        HealthStatus status = event.getStatus();
        
        log.warn("Health degradation detected for component: {} - {}", componentName, status);
        
        switch (status) {
            case DEGRADED:
                attemptGracefulRecovery(componentName);
                break;
            case UNHEALTHY:
                attemptForceRecovery(componentName);
                break;
            default:
                log.info("No recovery action needed for status: {}", status);
        }
    }
    
    private void attemptGracefulRecovery(String componentName) {
        try {
            // 清理缓存
            clearComponentCache(componentName);
            
            // 重置连接池
            resetConnectionPool(componentName);
            
            // 等待一段时间后重新检查
            Thread.sleep(5000);
            
            if (isComponentHealthy(componentName)) {
                log.info("Graceful recovery successful for component: {}", componentName);
            } else {
                log.warn("Graceful recovery failed, escalating to force recovery");
                attemptForceRecovery(componentName);
            }
        } catch (Exception e) {
            log.error("Graceful recovery failed for component: {}", componentName, e);
        }
    }
    
    private void attemptForceRecovery(String componentName) {
        try {
            // 重启组件服务
            restartComponentService(componentName);
            
            // 切换到备用服务
            switchToBackupService(componentName);
            
            // 通知运维团队
            notifyOperationsTeam(componentName, "Force recovery executed");
            
        } catch (Exception e) {
            log.error("Force recovery failed for component: {}", componentName, e);
        }
    }
}
```

## 实践建议与最佳实践

### 1. 监控策略制定

**分层监控原则**
- **基础设施层**：CPU、内存、磁盘、网络等系统资源
- **应用层**：业务逻辑执行、API响应时间、错误率等
- **业务层**：用户行为、业务指标、满意度等

**监控指标选择**
```yaml
# 核心监控指标配置示例
monitoring:
  metrics:
    system:
      - cpu_usage_percent
      - memory_usage_percent  
      - disk_usage_percent
      - network_io_bytes
    application:
      - http_request_duration
      - http_request_count
      - error_rate_percent
    business:
      - agent_success_rate
      - user_satisfaction_score
      - llm_cost_per_request
```

### 2. 告警阈值设置

**动态阈值调整**
- 基于历史数据设置基线
- 考虑业务周期性变化
- 实施渐进式告警（警告→严重→紧急）

**告警收敛策略**
- 设置告警频率限制
- 实施告警分组合并
- 建立告警升级机制

### 3. 日志管理最佳实践

**日志级别规范**
```java
// 日志级别使用指南
log.trace("详细调试信息"); // 开发阶段使用
log.debug("调试信息");     // 问题排查使用
log.info("关键业务流程");  // 正常业务记录
log.warn("潜在问题");      // 需要关注但不影响功能
log.error("错误信息");     // 需要立即处理的错误
```

**结构化日志格式**
```json
{
  "timestamp": "2024-01-15T10:30:00.000Z",
  "level": "INFO",
  "service": "agi-agent-service",
  "category": "agent_execution",
  "request_id": "req-12345",
  "agent_type": "react",
  "operation": "process_query",
  "duration_ms": 1500,
  "success": true,
  "metadata": {
    "user_id": "user-789",
    "session_id": "session-456"
  }
}
```

### 4. 容量规划与性能优化

**性能基线建立**
- 定期进行性能测试
- 建立性能基线数据库
- 监控性能趋势变化

**自动扩缩容策略**
```yaml
# 自动扩缩容配置示例
autoscaling:
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          averageUtilization: 70
    - type: Custom
      custom:
        metric:
          name: agi_requests_per_second
        target:
          value: "100"
  minReplicas: 2
  maxReplicas: 10
```

### 5. 故障处理与恢复

**故障响应流程**
1. **检测**：自动监控系统发现异常
2. **分类**：根据影响程度和紧急性分类
3. **响应**：自动或人工介入处理
4. **恢复**：执行恢复操作并验证
5. **总结**：事后分析和改进

**灾难恢复准备**
- 建立多地域备份
- 定期进行灾难恢复演练
- 制定详细的恢复手册

## 小结

黑盒组件的监控与治理是AI应用系统稳定运行的重要保障。通过建立完善的健康检查机制、全方位的性能监控体系、智能化的告警系统和自动化的故障恢复机制，我们能够：

1. **提升系统可观测性**：全面了解系统运行状态和性能表现
2. **实现主动运维**：在问题影响用户前及时发现和处理
3. **优化资源配置**：基于监控数据进行精准的容量规划
4. **保障服务质量**：确保系统稳定性和用户体验

在实际项目中，应根据业务特点和技术栈选择合适的监控工具和策略，并建立持续改进的运维文化，不断提升系统的可靠性和可维护性。监控治理不是一次性工作，而是需要持续投入和优化的长期过程。
