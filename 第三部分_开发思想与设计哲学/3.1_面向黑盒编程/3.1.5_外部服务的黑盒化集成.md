# 3.1.5 外部服务的黑盒化集成

## 学习目标
学习通过协议标准（如MCP）将第三方服务封装为黑盒组件，实现系统的可扩展性和互操作性。

## 外部服务黑盒化集成的价值

AI应用系统往往需要集成各种外部服务，如第三方API、数据库服务、云服务等。这些外部服务具有协议差异性、认证方式多样、数据格式不统一等特征。外部服务的黑盒化集成通过统一接口抽象，将这些差异封装在实现层，实现系统与外部服务的解耦。

主要价值体现在：
1. **降低耦合度**：系统与外部服务具体实现解耦
2. **提升可维护性**：外部服务变更时减少对系统影响  
3. **增强可扩展性**：便于集成新的外部服务
4. **统一管理**：提供统一的服务管理和监控接口

## MCP协议：外部服务集成标准

### MCP协议概述

MCP（Model Context Protocol）是一个开放的协议标准，旨在为AI应用与外部工具和服务建立标准化通信接口。MCP协议将外部服务抽象为标准化的工具提供者，通过统一接口规范实现服务的发现、调用和管理。

### MCP工具信息模型

```java
/**
 * MCP工具信息模型
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class McpToolInfo {
    private String name;           // 工具名称
    private String desc;           // 工具描述  
    private String parameters;     // 参数结构（JSON Schema格式）
    private String mcpServerUrl;   // MCP服务器地址
}
```

## MCP工具实现

### MCP工具类设计

```java
/**
 * MCP工具类 - 实现与MCP服务器的通信
 */
@Slf4j
@Data
public class McpTool implements BaseTool {
    private AgentContext agentContext;
    
    @Override
    public String getName() {
        return "mcp_tool";
    }
    
    @Override
    public String getDescription() {
        return "MCP协议工具，用于调用外部MCP服务";
    }
    
    @Override
    public Object execute(Object input) {
        Map<String, Object> params = (Map<String, Object>) input;
        String serverUrl = (String) params.get("server_url");
        String toolName = (String) params.get("name");
        Map<String, Object> arguments = (Map<String, Object>) params.get("arguments");
        
        return callTool(serverUrl, toolName, arguments);
    }
    
    /**
     * 获取MCP服务器的工具列表
     */
    public String listTools(String mcpServerUrl) {
        try {
            GenieConfig genieConfig = SpringContextHolder.getApplicationContext().getBean(GenieConfig.class);
            String mcpClientUrl = genieConfig.getMcpClientUrl() + "/v1/tool/list";
            
            McpToolRequest request = McpToolRequest.builder()
                    .server_url(mcpServerUrl)
                    .build();
                    
            String response = OkHttpUtil.postJson(mcpClientUrl, JSON.toJSONString(request), null, 30L);
            log.info("list tools request: {} response: {}", JSON.toJSONString(request), response);
            
            return response;
        } catch (Exception e) {
            log.error("{} list tools error", agentContext.getRequestId(), e);
        }
        return "";
    }
    
    /**
     * 调用MCP工具
     */
    public String callTool(String mcpServerUrl, String toolName, Object input) {
        try {
            GenieConfig genieConfig = SpringContextHolder.getApplicationContext().getBean(GenieConfig.class);
            String mcpClientUrl = genieConfig.getMcpClientUrl() + "/v1/tool/call";
            
            Map<String, Object> params = (Map<String, Object>) input;
            McpToolRequest request = McpToolRequest.builder()
                    .name(toolName)
                    .server_url(mcpServerUrl)
                    .arguments(params)
                    .build();
                    
            String response = OkHttpUtil.postJson(mcpClientUrl, JSON.toJSONString(request), null, 30L);
            log.info("call tool request: {} response: {}", JSON.toJSONString(request), response);
            
            return response;
        } catch (Exception e) {
            log.error("{} call tool error", agentContext.getRequestId(), e);
        }
        return "";
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class McpToolRequest {
        private String server_url;
        private String name;
        private Map<String, Object> arguments;
    }
}
```

### MCP客户端服务

基于Python实现MCP客户端服务：

```python
"""
MCP客户端服务 - 提供MCP协议的HTTP接口封装
"""
from fastapi import FastAPI, Body, Request
from app.client import SseClient
from app.header import HeaderEntity

app = FastAPI(title="MCP Client Service")

@app.post("/v1/tool/list")
async def list_tools(
    request: Request,
    server_url: str = Body(..., embed=True, alias="server_url"),
):
    """获取MCP服务器的工具列表"""
    entity = HeaderEntity(request.headers)
    mcp_client = SseClient(server_url=server_url, entity=entity)
    
    try:
        result = await mcp_client.list_tools()
        return {
            "code": 200,
            "message": "success", 
            "data": result,
        }
    except Exception as e:
        return {
            "code": 500,
            "message": f"Error listing tools: {str(e)}",
            "data": None,
        }

@app.post("/v1/tool/call")
async def call_tool(
    request: Request,
    server_url: str = Body(..., alias="server_url"),
    name: str = Body(..., alias="name"),
    arguments: dict = Body(..., alias="arguments"),
):
    """调用MCP工具"""
    entity = HeaderEntity(request.headers)
    if arguments and arguments.get("Cookie"):
        entity.append_cookie(arguments.get("Cookie"))
        
    mcp_client = SseClient(server_url=server_url, entity=entity)
    
    try:
        result = await mcp_client.call_tool(name, arguments)
        return {
            "code": 200,
            "message": "success",
            "data": result,
        }
    except Exception as e:
        return {
            "code": 500,
            "message": f"Error calling tool {name}: {str(e)}",
            "data": None,
        }
```

## 外部服务适配器

### 统一服务接口

```java
/**
 * 外部服务适配器接口
 */
public interface ExternalServiceAdapter {
    String getServiceName();
    String getServiceDescription();
    List<String> getSupportedOperations();
    CompletableFuture<Object> execute(String operation, Map<String, Object> parameters);
    CompletableFuture<Boolean> healthCheck();
    ServiceStatus getStatus();
}
```

### REST API适配器

```java
/**
 * REST API服务适配器
 */
@Component
@Slf4j
public class RestApiAdapter implements ExternalServiceAdapter {
    
    private final String serviceName;
    private final String baseUrl;
    private final String apiKey;
    private final Map<String, ApiEndpoint> endpoints;
    private final OkHttpClient httpClient;
    
    @Override
    public CompletableFuture<Object> execute(String operation, Map<String, Object> parameters) {
        CompletableFuture<Object> future = new CompletableFuture<>();
        
        ApiEndpoint endpoint = endpoints.get(operation);
        if (endpoint == null) {
            future.completeExceptionally(new IllegalArgumentException("Unknown operation: " + operation));
            return future;
        }
        
        try {
            Request request = buildRequest(endpoint, parameters);
            
            httpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    try {
                        if (response.isSuccessful()) {
                            String responseBody = response.body().string();
                            Object result = parseResponse(responseBody, endpoint.getResponseType());
                            future.complete(result);
                        } else {
                            future.completeExceptionally(
                                new IOException("HTTP " + response.code() + ": " + response.message())
                            );
                        }
                    } finally {
                        response.close();
                    }
                }
                
                @Override
                public void onFailure(Call call, IOException e) {
                    future.completeExceptionally(e);
                }
            });
            
        } catch (Exception e) {
            future.completeExceptionally(e);
        }
        
        return future;
    }
    
    private Request buildRequest(ApiEndpoint endpoint, Map<String, Object> parameters) throws Exception {
        String url = baseUrl + endpoint.getPath();
        Request.Builder builder = new Request.Builder();
        
        if (apiKey != null) {
            builder.addHeader("Authorization", "Bearer " + apiKey);
        }
        
        switch (endpoint.getMethod().toUpperCase()) {
            case "GET":
                url = buildUrlWithParams(url, parameters);
                builder.url(url).get();
                break;
            case "POST":
                RequestBody body = RequestBody.create(
                    MediaType.parse("application/json"),
                    JSON.toJSONString(parameters)
                );
                builder.url(url).post(body);
                builder.addHeader("Content-Type", "application/json");
                break;
        }
        
        return builder.build();
    }
}
```

## 动态工具集成

### 动态MCP工具加载

```java
/**
 * 动态构建工具集合，包含MCP工具
 */
private ToolCollection buildToolCollection(AgentContext agentContext, AgentRequest request) {
    ToolCollection toolCollection = new ToolCollection();
    toolCollection.setAgentContext(agentContext);
    
    // 动态加载MCP工具
    try {
        McpTool mcpTool = new McpTool();
        mcpTool.setAgentContext(agentContext);
        
        for (String mcpServer : genieConfig.getMcpServerUrlArr()) {
            String listToolResult = mcpTool.listTools(mcpServer);
            if (listToolResult.isEmpty()) {
                continue;
            }
            
            JSONObject resp = JSON.parseObject(listToolResult);
            if (resp.getIntValue("code") != 200) {
                continue;
            }
            
            JSONArray data = resp.getJSONArray("data");
            for (int i = 0; i < data.size(); i++) {
                JSONObject tool = data.getJSONObject(i);
                String method = tool.getString("name");
                String description = tool.getString("description");
                String inputSchema = tool.getString("inputSchema");
                
                toolCollection.addMcpTool(method, description, inputSchema, mcpServer);
            }
        }
    } catch (Exception e) {
        log.error("Failed to add MCP tools", e);
    }
    
    return toolCollection;
}
```

## 服务注册与发现

### 服务注册中心

```java
/**
 * 外部服务注册中心
 */
@Component
@Slf4j
public class ExternalServiceRegistry {
    
    private final Map<String, ExternalServiceAdapter> services = new ConcurrentHashMap<>();
    private final Map<String, ServiceStatus> serviceStatuses = new ConcurrentHashMap<>();
    
    /**
     * 注册外部服务
     */
    public void registerService(ExternalServiceAdapter service) {
        services.put(service.getServiceName(), service);
        serviceStatuses.put(service.getServiceName(), ServiceStatus.UNKNOWN);
        log.info("Registered external service: {}", service.getServiceName());
    }
    
    /**
     * 获取服务
     */
    public ExternalServiceAdapter getService(String serviceName) {
        return services.get(serviceName);
    }
    
    /**
     * 获取所有可用服务
     */
    public List<ExternalServiceAdapter> getAvailableServices() {
        return services.values().stream()
            .filter(service -> serviceStatuses.get(service.getServiceName()) == ServiceStatus.HEALTHY)
            .collect(Collectors.toList());
    }
}
```

## 实践建议

### 1. 协议标准化
- 优先使用行业标准协议（如MCP、OpenAPI）
- 建立统一的接口规范
- 支持协议版本管理

### 2. 错误处理与重试
- 实现指数退避重试机制
- 建立熔断保护机制
- 提供降级策略

### 3. 安全性保障
- 实现安全的认证机制
- 支持加密传输
- 进行输入验证和清理

### 4. 性能优化
- 实现连接池管理
- 支持并发调用
- 提供缓存机制

## 小结

外部服务的黑盒化集成通过MCP协议、适配器模式、服务注册发现等技术手段，实现了第三方服务的统一封装和管理。这种设计模式降低了系统与外部服务的耦合度，提供了动态扩展、故障恢复、性能监控等功能，为AI应用的服务集成提供了可靠的架构基础。