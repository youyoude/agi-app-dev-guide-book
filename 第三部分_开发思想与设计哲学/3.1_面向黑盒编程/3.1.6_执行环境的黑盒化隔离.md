# 3.1.6 执行环境的黑盒化隔离

## 学习目标
掌握如何将代码执行、文件处理等计算环境封装为安全的黑盒服务，确保系统稳定性。

## 执行环境黑盒化隔离的价值

在AI应用开发中，经常需要执行用户提供的代码、处理各种格式的文件、运行数据分析脚本等操作。这些执行环境面临安全风险和稳定性挑战：

### 主要风险
1. **恶意代码执行**：用户可能提交包含恶意逻辑的代码
2. **资源滥用**：无限循环、大量内存占用、磁盘空间耗尽
3. **系统访问**：未授权访问系统文件、网络资源
4. **数据泄露**：访问敏感数据或其他用户文件

### 黑盒化价值
1. **安全隔离**：将不可信代码与主系统隔离
2. **资源控制**：限制执行环境的资源使用
3. **环境一致性**：提供标准化的执行环境
4. **易于管理**：统一的环境管理和监控

## 容器化执行环境

### Docker执行环境

```dockerfile
# Python代码执行环境镜像
FROM python:3.9-slim

# 创建非root用户
RUN groupadd -r coderunner && useradd -r -g coderunner coderunner

# 安装科学计算包
RUN pip install --no-cache-dir pandas numpy matplotlib seaborn scikit-learn

# 设置工作目录
WORKDIR /workspace
RUN chown coderunner:coderunner /workspace

# 切换到非特权用户
USER coderunner

ENTRYPOINT ["python"]
```

### 执行环境管理器

```java
/**
 * 执行环境管理器
 */
@Component
@Slf4j
public class ExecutionEnvironmentManager {
    
    private final DockerClient dockerClient;
    private final String executionImage = "ai-code-executor:latest";
    private final Map<String, String> runningContainers = new ConcurrentHashMap<>();
    
    /**
     * 创建执行环境
     */
    public String createExecutionEnvironment(String sessionId) throws Exception {
        try {
            HostConfig hostConfig = HostConfig.builder()
                .memory(512L * 1024 * 1024)        // 限制内存512MB
                .cpuQuota(50000L)                  // 限制CPU使用率50%
                .networkMode("none")               // 禁用网络访问
                .readonlyRootfs(true)              // 只读文件系统
                .tmpfs(ImmutableMap.of("/tmp", "rw,size=100m"))
                .build();
            
            ContainerConfig containerConfig = ContainerConfig.builder()
                .image(executionImage)
                .workingDir("/workspace")
                .user("coderunner")
                .hostConfig(hostConfig)
                .cmd("tail", "-f", "/dev/null")
                .build();
            
            ContainerCreation container = dockerClient.createContainer(containerConfig);
            String containerId = container.id();
            
            dockerClient.startContainer(containerId);
            runningContainers.put(sessionId, containerId);
            
            log.info("Created execution environment for session: {}", sessionId);
            return containerId;
        } catch (Exception e) {
            log.error("Failed to create execution environment", e);
            throw e;
        }
    }
    
    /**
     * 执行代码
     */
    public ExecutionResult executeCode(String sessionId, String code, int timeoutSeconds) {
        try {
            String containerId = runningContainers.get(sessionId);
            if (containerId == null) {
                containerId = createExecutionEnvironment(sessionId);
            }
            
            // 将代码写入容器
            String codeFile = "/tmp/code_" + System.currentTimeMillis() + ".py";
            dockerClient.copyToContainer(
                Paths.get(createTempFile(code)), containerId, codeFile);
            
            // 执行代码
            ExecCreation execCreation = dockerClient.execCreate(
                containerId,
                new String[]{"python", codeFile},
                ExecCreateParam.attachStdout(),
                ExecCreateParam.attachStderr()
            );
            
            LogStream output = dockerClient.execStart(execCreation.id());
            
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return output.readFully();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });
            
            String result = future.get(timeoutSeconds, TimeUnit.SECONDS);
            
            return ExecutionResult.builder()
                .success(true)
                .output(result)
                .build();
                
        } catch (TimeoutException e) {
            return ExecutionResult.builder()
                .success(false)
                .error("Execution timeout")
                .build();
        } catch (Exception e) {
            return ExecutionResult.builder()
                .success(false)
                .error(e.getMessage())
                .build();
        }
    }
    
    /**
     * 清理执行环境
     */
    public void cleanupEnvironment(String sessionId) {
        try {
            String containerId = runningContainers.remove(sessionId);
            if (containerId != null) {
                dockerClient.killContainer(containerId);
                dockerClient.removeContainer(containerId);
                log.info("Cleaned up execution environment for session: {}", sessionId);
            }
        } catch (Exception e) {
            log.error("Failed to cleanup execution environment", e);
        }
    }
}
```

## 代码解释器黑盒服务

### Python代码解释器

```python
"""
代码解释器Agent - 安全执行用户代码
"""
import tempfile
from smolagents import LiteLLMModel, PythonInterpreterTool

class CIAgent:
    def __init__(self, model_name: str):
        self.model = LiteLLMModel(model_id=model_name)
        self.work_dir = tempfile.mkdtemp()
        self.interpreter = PythonInterpreterTool()
        
    async def execute_task(self, task: str, file_names=None, request_id=""):
        """执行代码解释任务"""
        try:
            # 构建提示词
            prompt = f"""
请完成以下任务：{task}

要求：
1. 使用pandas、numpy、matplotlib等库
2. 包含适当的错误处理
3. 生成清晰的输出结果
"""
            
            # 调用LLM生成代码
            messages = [{"role": "user", "content": prompt}]
            
            response = await self.model.async_chat(
                messages=messages,
                max_tokens=32000,
                temperature=0.1,
                tools=[self.interpreter]
            )
            
            # 执行生成的代码
            if response.tool_calls:
                for tool_call in response.tool_calls:
                    if tool_call.function.name == "python_interpreter":
                        code = tool_call.function.arguments.get("code", "")
                        result = self.interpreter.execute(code)
                        
                        if result.success:
                            return {
                                "success": True,
                                "output": result.output,
                                "plots": getattr(result, 'plots', None)
                            }
                        else:
                            return {"success": False, "error": result.error}
                            
            return {"error": "No executable code generated"}
            
        except Exception as e:
            return {"error": f"Execution failed: {str(e)}"}
```

### 代码解释器HTTP接口

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI(title="Code Interpreter Service")

class CodeInterpreterRequest(BaseModel):
    requestId: str
    task: str
    fileNames: Optional[List[str]] = None

@app.post("/v1/tool/code_interpreter")
async def code_interpreter(request: CodeInterpreterRequest):
    """代码解释器接口"""
    try:
        agent = CIAgent(model_name="gpt-4")
        result = await agent.execute_task(
            task=request.task,
            file_names=request.fileNames,
            request_id=request.requestId
        )
        return result
    except Exception as e:
        return {"success": False, "error": str(e)}
```

## 文件处理环境隔离

### 安全文件处理

```java
/**
 * 文件处理服务
 */
@Service
@Slf4j
public class FileProcessingService {
    
    private final ExecutionEnvironmentManager environmentManager;
    
    /**
     * 安全处理上传文件
     */
    public FileProcessingResult processFile(String sessionId, MultipartFile file) {
        try {
            // 验证文件
            validateFile(file);
            
            // 创建隔离环境
            String containerId = environmentManager.createExecutionEnvironment(sessionId);
            
            // 处理文件
            String containerPath = "/workspace/" + file.getOriginalFilename();
            copyFileToContainer(containerId, file, containerPath);
            
            return processFileInContainer(containerId, containerPath, file.getContentType());
            
        } catch (Exception e) {
            log.error("File processing failed", e);
            return FileProcessingResult.builder()
                .success(false)
                .error(e.getMessage())
                .build();
        }
    }
    
    private void validateFile(MultipartFile file) throws Exception {
        // 文件大小限制
        if (file.getSize() > 100 * 1024 * 1024) {
            throw new IllegalArgumentException("File too large");
        }
        
        // 文件类型检查
        String contentType = file.getContentType();
        List<String> allowedTypes = Arrays.asList(
            "text/plain", "text/csv", "application/json", "application/pdf"
        );
        
        if (!allowedTypes.contains(contentType)) {
            throw new IllegalArgumentException("Unsupported file type");
        }
    }
    
    private FileProcessingResult processFileInContainer(String containerId, String filePath, String contentType) {
        try {
            String script = buildProcessingScript(filePath, contentType);
            ExecutionResult result = executeInContainer(containerId, script);
            
            return FileProcessingResult.builder()
                .success(result.isSuccess())
                .analysis(parseAnalysisResult(result.getOutput()))
                .error(result.getError())
                .build();
        } catch (Exception e) {
            return FileProcessingResult.builder()
                .success(false)
                .error("Processing failed: " + e.getMessage())
                .build();
        }
    }
}
```

## 资源监控与控制

### 资源监控器

```java
/**
 * 资源监控器
 */
@Component
@Slf4j
public class ResourceMonitor {
    
    private final DockerClient dockerClient;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    
    @PostConstruct
    public void startMonitoring() {
        scheduler.scheduleAtFixedRate(this::monitorResources, 0, 10, TimeUnit.SECONDS);
    }
    
    private void monitorResources() {
        try {
            List<Container> containers = dockerClient.listContainers();
            
            for (Container container : containers) {
                if (isExecutionContainer(container)) {
                    ContainerStats stats = dockerClient.stats(container.id());
                    
                    double memoryUsage = getMemoryUsagePercentage(stats);
                    if (memoryUsage > 90) {
                        log.warn("High memory usage: {}%", memoryUsage);
                        handleHighMemoryUsage(container.id());
                    }
                    
                    double cpuUsage = getCpuUsagePercentage(stats);
                    if (cpuUsage > 80) {
                        log.warn("High CPU usage: {}%", cpuUsage);
                        handleHighCpuUsage(container.id());
                    }
                }
            }
        } catch (Exception e) {
            log.error("Resource monitoring failed", e);
        }
    }
    
    private void handleHighMemoryUsage(String containerId) {
        try {
            dockerClient.restartContainer(containerId);
        } catch (Exception e) {
            log.error("Failed to handle high memory usage", e);
        }
    }
}
```

## 实践建议

### 1. 安全隔离策略
- 使用容器技术实现进程隔离
- 禁用网络访问或限制网络权限
- 使用只读文件系统防止恶意修改
- 实施严格的用户权限控制

### 2. 资源控制机制
- 设置内存和CPU使用限制
- 实施磁盘空间配额
- 配置执行超时机制
- 监控资源使用情况

### 3. 错误处理与恢复
- 实现完善的异常捕获机制
- 提供快速环境重置功能
- 建立环境健康检查
- 支持自动故障恢复

## 小结

执行环境的黑盒化隔离通过容器技术、资源限制、安全控制等手段，将代码执行和文件处理封装为安全的黑盒服务。这种设计保障了系统安全性和稳定性，提供了标准化的执行环境和统一的管理接口，为AI应用的计算需求提供了可靠支撑。