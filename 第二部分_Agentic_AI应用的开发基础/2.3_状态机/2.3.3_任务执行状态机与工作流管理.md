# 2.3.3 ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºä¸å·¥ä½œæµç®¡ç†

## å­¦ä¹ ç›®æ ‡

ğŸ—ï¸ **æ¶æ„è®¾è®¡å±‚é¢**
- å­¦ä¼šè®¾è®¡ä»»åŠ¡åˆ†è§£ä¸æ‰§è¡Œçš„çŠ¶æ€æœºæ¨¡å‹
- ç†è§£ä»»åŠ¡ä¾èµ–å›¾ä¸çŠ¶æ€è½¬æ¢å›¾çš„æ˜ å°„å…³ç³»
- æŒæ¡å¤šä»»åŠ¡åè°ƒçš„çŠ¶æ€ç®¡ç†æ¶æ„

âš™ï¸ **å·¥ç¨‹å®ç°å±‚é¢**
- æŒæ¡ReActæ¡†æ¶ä¸­Thought-Action-Observationå¾ªç¯çš„çŠ¶æ€è½¬æ¢
- å­¦ä¼šå®ç°ä»»åŠ¡å¤±è´¥æ¢å¤ä¸çŠ¶æ€å›æ»šæœºåˆ¶
- æŒæ¡ä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡çš„çŠ¶æ€ç»´æŠ¤æŠ€æœ¯

ğŸš€ **ä¼ä¸šçº§åº”ç”¨**
- ç†è§£å·¥ä½œæµç®¡ç†ä¸­çš„çŠ¶æ€åè°ƒæœºåˆ¶
- æŒæ¡ä»»åŠ¡æ‰§è¡Œç›‘æ§ä¸æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

## å¼•è¨€

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å»ºç«‹äº†çŠ¶æ€æœºçš„ç†è®ºåŸºç¡€ï¼ˆ2.3.1ï¼‰å¹¶å­¦ä¹ äº†Agentçº§çŠ¶æ€æœºçš„è®¾è®¡åŸåˆ™ï¼ˆ2.3.2ï¼‰ã€‚ç°åœ¨æˆ‘ä»¬å°†è¿™äº›åŸåˆ™åº”ç”¨åˆ°æ›´å¤æ‚çš„åœºæ™¯â€”â€”**ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºä¸å·¥ä½œæµç®¡ç†**ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºï¼Ÿ

åœ¨Agentic AIåº”ç”¨ä¸­ï¼Œä¸€ä¸ªå¤æ‚çš„ç”¨æˆ·è¯·æ±‚å¾€å¾€éœ€è¦åˆ†è§£ä¸ºå¤šä¸ªå­ä»»åŠ¡ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·è¯¢é—®"å¸®æˆ‘åˆ†æè¿™ä¸ªæœˆçš„é”€å”®æ•°æ®å¹¶ç”ŸæˆæŠ¥å‘Š"ï¼Œç³»ç»Ÿå¯èƒ½éœ€è¦ï¼š
1. ä»æ•°æ®åº“æŸ¥è¯¢é”€å”®æ•°æ®
2. å¯¹æ•°æ®è¿›è¡Œæ¸…æ´—å’Œé¢„å¤„ç†
3. è¿›è¡Œç»Ÿè®¡åˆ†æ
4. ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
5. æ’°å†™åˆ†ææŠ¥å‘Š

æ¯ä¸ªå­ä»»åŠ¡éƒ½æœ‰è‡ªå·±çš„æ‰§è¡ŒçŠ¶æ€ï¼ˆå¾…æ‰§è¡Œã€æ‰§è¡Œä¸­ã€å·²å®Œæˆã€å¤±è´¥ç­‰ï¼‰ï¼Œè€Œä¸”ä»»åŠ¡ä¹‹é—´å­˜åœ¨ä¾èµ–å…³ç³»ï¼ˆå¦‚å¿…é¡»å…ˆæŸ¥è¯¢æ•°æ®æ‰èƒ½åˆ†æï¼‰ã€‚**ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºå°±æ˜¯ç”¨æ¥ç®¡ç†è¿™äº›ä»»åŠ¡çš„çŠ¶æ€è½¬æ¢å’Œåè°ƒæ‰§è¡Œçš„æ ¸å¿ƒæœºåˆ¶**ã€‚

æœ¬èŠ‚å°†æ·±å…¥åˆ†æä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºçš„è®¾è®¡ï¼Œå±•ç¤ºå¦‚ä½•å°†è®¾è®¡åŸåˆ™åº”ç”¨åˆ°ä»»åŠ¡è§„åˆ’ã€åˆ†è§£ã€æ‰§è¡Œå’Œç›‘æ§çš„å®Œæ•´æµç¨‹ä¸­ã€‚

## 1. ä»»åŠ¡çŠ¶æ€æ¨¡å‹è®¾è®¡

åœ¨è®¾è®¡ä»»åŠ¡çŠ¶æ€æ¨¡å‹æ—¶ï¼Œæˆ‘ä»¬å°†ä¸¥æ ¼éµå¾ª2.3.1ç« èŠ‚ä¸­å»ºç«‹çš„è®¾è®¡åŸåˆ™ï¼šçŠ¶æ€çš„å®Œæ•´æ€§ã€äº’æ–¥æ€§å’Œå¯è§‚æµ‹æ€§ã€‚åŒæ—¶åº”ç”¨SOLIDåŸåˆ™ä¸­çš„å•ä¸€èŒè´£åŸåˆ™ï¼Œç¡®ä¿æ¯ä¸ªçŠ¶æ€éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œã€‚

### 1.1 ä»»åŠ¡çŠ¶æ€æšä¸¾å®šä¹‰

å‚è€ƒä»£ç ç¤ºä¾‹ï¼š**[CODE-001] TaskStateæšä¸¾å®šä¹‰**

ä»»åŠ¡çŠ¶æ€æšä¸¾æ˜¯ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºçš„æ ¸å¿ƒï¼Œå®ƒä¸¥æ ¼éµå¾ªäº†2.3.1èŠ‚ä¸­æåˆ°çš„**çŠ¶æ€å®Œæ•´æ€§ã€äº’æ–¥æ€§å’Œè¯­ä¹‰æ˜ç¡®æ€§**åŸåˆ™ã€‚ä¸AgentçŠ¶æ€ä¸åŒï¼Œä»»åŠ¡çŠ¶æ€éœ€è¦æ›´ç»†ç²’åº¦çš„æ§åˆ¶ï¼Œä»¥æ”¯æŒå¤æ‚çš„å·¥ä½œæµç®¡ç†ã€‚

### 1.2 ä»»åŠ¡æ•°æ®æ¨¡å‹

**è®¾è®¡è¯´æ˜**ï¼šä»»åŠ¡è®¡åˆ’æ•°æ®æ¨¡å‹(`Plan`)ç”¨äºå­˜å‚¨ä»»åŠ¡çš„æ•´ä½“è§„åˆ’ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ­¥éª¤åˆ—è¡¨ã€çŠ¶æ€è¿½è¸ªå’Œè¿›åº¦ç®¡ç†ã€‚å®ƒæä¾›äº†åŒæ­¥çš„çŠ¶æ€æ›´æ–°æ–¹æ³•ï¼Œç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„æ•°æ®ä¸€è‡´æ€§ã€‚

```java
/**
 * ä»»åŠ¡è®¡åˆ’æ•°æ®æ¨¡å‹ - ç®¡ç†ä»»åŠ¡æ­¥éª¤å’Œæ‰§è¡ŒçŠ¶æ€
 */
@Data
@Builder
public class Plan {
    private List<String> steps;           // ä»»åŠ¡æ­¥éª¤åˆ—è¡¨
    private List<String> stepStatus;      // æ¯ä¸ªæ­¥éª¤çš„çŠ¶æ€ï¼ˆpending/running/completedï¼‰
    private String currentStep;           // å½“å‰æ‰§è¡Œæ­¥éª¤
    private int currentIndex;             // å½“å‰æ­¥éª¤ç´¢å¼•
    
    /**
     * è·å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œçš„ä»»åŠ¡
     */
    public String getNextPendingTask() {
        for (int i = 0; i < steps.size(); i++) {
            if ("pending".equals(stepStatus.get(i))) {
                return steps.get(i);
            }
        }
        return null;
    }
    
    /**
     * æ›´æ–°ä»»åŠ¡çŠ¶æ€ - ä½¿ç”¨synchronizedä¿è¯çº¿ç¨‹å®‰å…¨
     */
    public synchronized void updateTaskStatus(int index, String status) {
        if (index >= 0 && index < stepStatus.size()) {
            stepStatus.set(index, status);
            if ("running".equals(status)) {
                currentIndex = index;
                currentStep = steps.get(index);
            }
        }
    }
    
    /**
     * è·å–æ‰§è¡Œè¿›åº¦ç™¾åˆ†æ¯”
     */
    public double getProgress() {
        long completedCount = stepStatus.stream()
            .filter("completed"::equals)
            .count();
        return (double) completedCount / steps.size() * 100;
    }
}
```

### 1.3 ä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡

**è®¾è®¡è¯´æ˜**ï¼šä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡(`TaskExecutionContext`)å°è£…äº†å•ä¸ªä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ‰€æœ‰çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä»»åŠ¡æ ‡è¯†ã€çŠ¶æ€ã€é‡è¯•æœºåˆ¶ã€ä¾èµ–å…³ç³»å’Œæ—¶é—´è¿½è¸ªã€‚å®ƒæ˜¯ä»»åŠ¡çŠ¶æ€æœºçš„æ ¸å¿ƒæ•°æ®ç»“æ„ã€‚

```java
/**
 * ä»»åŠ¡æ‰§è¡Œä¸Šä¸‹æ–‡ - ç»´æŠ¤ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­çš„çŠ¶æ€ä¿¡æ¯
 */
@Data
@Builder
public class TaskExecutionContext {
    // ä»»åŠ¡æ ‡è¯†
    private String taskId;
    private String taskDescription;
    
    // çŠ¶æ€ç®¡ç†
    private TaskState currentState;
    private int retryCount;
    private int maxRetries = 3;
    
    // æ‰§è¡Œç»“æœ
    private String result;
    private String errorMessage;
    private List<String> intermediateResults = new ArrayList<>();
    
    // ä¾èµ–å…³ç³»
    private List<String> dependencies = new ArrayList<>();
    
    // æ—¶é—´è¿½è¸ª
    private long startTime;
    private long endTime;
    
    /**
     * æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³ - æ‰€æœ‰ä¾èµ–ä»»åŠ¡å¿…é¡»å®Œæˆ
     */
    public boolean areDependenciesSatisfied(Map<String, TaskState> taskStates) {
        return dependencies.stream()
            .allMatch(depId -> taskStates.get(depId) == TaskState.COMPLETED);
    }
    
    /**
     * æ›´æ–°ä»»åŠ¡çŠ¶æ€ - è‡ªåŠ¨è¿½è¸ªæ—¶é—´ä¿¡æ¯
     */
    public void updateState(TaskState newState) {
        this.currentState = newState;
        
        // ä»»åŠ¡å¼€å§‹æ—¶è®°å½•å¼€å§‹æ—¶é—´
        if (newState == TaskState.RUNNING && startTime == 0) {
            this.startTime = System.currentTimeMillis();
        } 
        // ä»»åŠ¡ç»“æŸæ—¶è®°å½•ç»“æŸæ—¶é—´
        else if (newState == TaskState.COMPLETED || newState == TaskState.FAILED) {
            this.endTime = System.currentTimeMillis();
        }
    }
}
```

## 2. ReActæ¡†æ¶çš„ä»»åŠ¡çŠ¶æ€å¾ªç¯

### 2.1 æ€è€ƒ-è¡ŒåŠ¨-è§‚å¯ŸçŠ¶æ€æœº

```java
/**
 * ReActä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœº
 */
public class ReActTaskStateMachine {
    
    public enum ReActState {
        THINKING,    // æ€è€ƒé˜¶æ®µï¼šåˆ†æé—®é¢˜ï¼Œåˆ¶å®šè¡ŒåŠ¨è®¡åˆ’
        ACTING,      // è¡ŒåŠ¨é˜¶æ®µï¼šæ‰§è¡Œå·¥å…·è°ƒç”¨æˆ–ç”Ÿæˆè¾“å‡º
        OBSERVING,   // è§‚å¯Ÿé˜¶æ®µï¼šåˆ†æè¡ŒåŠ¨ç»“æœï¼Œå†³å®šä¸‹ä¸€æ­¥
        REFLECTING   // åæ€é˜¶æ®µï¼šè¯„ä¼°æ•´ä½“è¿›å±•ï¼Œè°ƒæ•´ç­–ç•¥
    }
    
    private ReActState currentState = ReActState.THINKING;
    private TaskExecutionContext taskContext;
    private int maxIterations = 10;
    private int currentIteration = 0;
    
    /**
     * æ‰§è¡ŒReActå¾ªç¯çš„å•æ¬¡è¿­ä»£
     */
    public TaskExecutionResult executeIteration() {
        currentIteration++;
        
        try {
            switch (currentState) {
                case THINKING:
                    return executeThinking();
                case ACTING:
                    return executeActing();
                case OBSERVING:
                    return executeObserving();
                case REFLECTING:
                    return executeReflecting();
                default:
                    throw new IllegalStateException("Unknown ReAct state: " + currentState);
            }
        } catch (Exception e) {
            taskContext.updateState(TaskState.FAILED);
            taskContext.setErrorMessage(e.getMessage());
            return TaskExecutionResult.failure(e.getMessage());
        }
    }
    
    /**
     * æ€è€ƒé˜¶æ®µ - åˆ†æå½“å‰æƒ…å†µå¹¶åˆ¶å®šè¡ŒåŠ¨è®¡åˆ’
     */
    private TaskExecutionResult executeThinking() {
        log.info("ReAct Thinking phase for task: {}", taskContext.getTaskId());
        
        // æ„å»ºæ€è€ƒprompt
        String thinkingPrompt = buildThinkingPrompt(taskContext);
        
        // è°ƒç”¨LLMè¿›è¡Œæ€è€ƒ
        LLMResponse thinkingResult = llm.chat(thinkingPrompt);
        
        // è§£ææ€è€ƒç»“æœ
        ThoughtAnalysis analysis = parseThinkingResult(thinkingResult.getContent());
        
        // å†³å®šä¸‹ä¸€æ­¥çŠ¶æ€
        if (analysis.shouldAct()) {
            transitionTo(ReActState.ACTING);
            return TaskExecutionResult.intermediate("Thinking completed, moving to action");
        } else if (analysis.isTaskComplete()) {
            taskContext.updateState(TaskState.COMPLETED);
            taskContext.setResult(analysis.getFinalAnswer());
            return TaskExecutionResult.success(analysis.getFinalAnswer());
        } else {
            transitionTo(ReActState.REFLECTING);
            return TaskExecutionResult.intermediate("Need more information, moving to reflection");
        }
    }
    
    /**
     * è¡ŒåŠ¨é˜¶æ®µ - æ‰§è¡Œå…·ä½“çš„å·¥å…·è°ƒç”¨æˆ–ç”Ÿæˆè¾“å‡º
     */
    private TaskExecutionResult executeActing() {
        log.info("ReAct Acting phase for task: {}", taskContext.getTaskId());
        
        // è§£æéœ€è¦æ‰§è¡Œçš„å·¥å…·è°ƒç”¨
        List<ToolCall> toolCalls = parseToolCallsFromContext();
        
        if (toolCalls.isEmpty()) {
            // æ— å·¥å…·è°ƒç”¨ï¼Œç›´æ¥è¾“å‡ºç»“æœ
            transitionTo(ReActState.OBSERVING);
            return TaskExecutionResult.intermediate("No tool calls needed");
        }
        
        // æ‰§è¡Œå·¥å…·è°ƒç”¨
        List<String> actionResults = new ArrayList<>();
        for (ToolCall toolCall : toolCalls) {
            try {
                String result = executeToolCall(toolCall);
                actionResults.add(result);
                
                // ä¿å­˜ä¸­é—´ç»“æœ
                taskContext.getIntermediateResults().add(
                    String.format("Tool: %s, Result: %s", toolCall.getName(), result)
                );
                
            } catch (ToolExecutionException e) {
                log.error("Tool execution failed: {}", toolCall.getName(), e);
                
                if (taskContext.getRetryCount() < taskContext.getMaxRetries()) {
                    taskContext.setRetryCount(taskContext.getRetryCount() + 1);
                    transitionTo(ReActState.THINKING); // é‡æ–°æ€è€ƒ
                    return TaskExecutionResult.retry("Tool execution failed, retrying");
                } else {
                    taskContext.updateState(TaskState.FAILED);
                    return TaskExecutionResult.failure("Tool execution failed after retries");
                }
            }
        }
        
        // è½¬æ¢åˆ°è§‚å¯Ÿé˜¶æ®µ
        transitionTo(ReActState.OBSERVING);
        return TaskExecutionResult.intermediate(String.join("\n", actionResults));
    }
    
    /**
     * è§‚å¯Ÿé˜¶æ®µ - åˆ†æè¡ŒåŠ¨ç»“æœ
     */
    private TaskExecutionResult executeObserving() {
        log.info("ReAct Observing phase for task: {}", taskContext.getTaskId());
        
        // åˆ†æè¡ŒåŠ¨ç»“æœ
        String lastResult = taskContext.getIntermediateResults().isEmpty() 
            ? "" : taskContext.getIntermediateResults().get(
                taskContext.getIntermediateResults().size() - 1);
        
        ObservationAnalysis analysis = analyzeActionResult(lastResult);
        
        // æ ¹æ®åˆ†æç»“æœå†³å®šä¸‹ä¸€æ­¥
        if (analysis.isTaskComplete()) {
            taskContext.updateState(TaskState.COMPLETED);
            taskContext.setResult(analysis.getFinalResult());
            return TaskExecutionResult.success(analysis.getFinalResult());
        } else if (analysis.needsMoreAction()) {
            transitionTo(ReActState.THINKING);
            return TaskExecutionResult.intermediate("Need more actions");
        } else if (currentIteration >= maxIterations) {
            transitionTo(ReActState.REFLECTING);
            return TaskExecutionResult.intermediate("Max iterations reached, reflecting");
        } else {
            transitionTo(ReActState.THINKING);
            return TaskExecutionResult.intermediate("Continue thinking");
        }
    }
    
    /**
     * åæ€é˜¶æ®µ - è¯„ä¼°æ•´ä½“æ‰§è¡Œæƒ…å†µ
     */
    private TaskExecutionResult executeReflecting() {
        log.info("ReAct Reflecting phase for task: {}", taskContext.getTaskId());
        
        // æ„å»ºåæ€prompt
        String reflectionPrompt = buildReflectionPrompt(taskContext);
        
        // è¿›è¡Œåæ€
        LLMResponse reflectionResult = llm.chat(reflectionPrompt);
        ReflectionAnalysis analysis = parseReflectionResult(reflectionResult.getContent());
        
        if (analysis.shouldContinue() && currentIteration < maxIterations) {
            transitionTo(ReActState.THINKING);
            return TaskExecutionResult.intermediate("Reflection suggests continuing");
        } else {
            // ä»»åŠ¡ç»“æŸï¼Œè¾“å‡ºæœ€ä½³ç»“æœ
            taskContext.updateState(TaskState.COMPLETED);
            String finalResult = analysis.getBestResult();
            taskContext.setResult(finalResult);
            return TaskExecutionResult.success(finalResult);
        }
    }
    
    /**
     * çŠ¶æ€è½¬æ¢
     */
    private void transitionTo(ReActState newState) {
        log.debug("ReAct state transition: {} -> {}", currentState, newState);
        this.currentState = newState;
        taskContext.setLastUpdateTime(System.currentTimeMillis());
    }
}
```

### 2.2 ä»»åŠ¡çŠ¶æ€è½¬æ¢å›¾

```mermaid
stateDiagram-v2
    [*] --> THINKING: Start Task
    
    THINKING --> ACTING: Need Action
    THINKING --> REFLECTING: Need Info
    THINKING --> COMPLETED: Task Done
    
    ACTING --> OBSERVING: Action Done
    ACTING --> THINKING: Retry
    ACTING --> FAILED: Tool Error
    
    OBSERVING --> THINKING: Continue
    OBSERVING --> REFLECTING: Max Iterations
    OBSERVING --> COMPLETED: Task Done
    
    REFLECTING --> THINKING: Continue
    REFLECTING --> COMPLETED: Best Result
    
    COMPLETED --> [*]
    FAILED --> [*]
```

## 3. ä»»åŠ¡ä¾èµ–å›¾ä¸å·¥ä½œæµç®¡ç†

### 3.1 ä»»åŠ¡ä¾èµ–å›¾æ„å»º

```java
/**
 * ä»»åŠ¡ä¾èµ–å›¾ç®¡ç†å™¨
 */
@Component
public class TaskDependencyManager {
    
    /**
     * ä»»åŠ¡ä¾èµ–å›¾èŠ‚ç‚¹
     */
    @Data
    @Builder
    public static class TaskNode {
        private String taskId;
        private String description;
        private TaskState state;
        private Set<String> dependencies = new HashSet<>();
        private Set<String> dependents = new HashSet<>();
        private TaskExecutionContext context;
        
        /**
         * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ
         */
        public boolean isReadyToExecute(Map<String, TaskNode> allTasks) {
            return dependencies.stream()
                .allMatch(depId -> {
                    TaskNode dep = allTasks.get(depId);
                    return dep != null && dep.getState() == TaskState.COMPLETED;
                });
        }
    }
    
    private final Map<String, TaskNode> taskGraph = new ConcurrentHashMap<>();
    private final ExecutorService taskExecutor = Executors.newFixedThreadPool(10);
    
    /**
     * æ„å»ºä»»åŠ¡ä¾èµ–å›¾
     */
    public void buildDependencyGraph(Plan plan) {
        // è§£æä»»åŠ¡å’Œä¾èµ–å…³ç³»
        for (int i = 0; i < plan.getSteps().size(); i++) {
            String taskDescription = plan.getSteps().get(i);
            String taskId = "task_" + i;
            
            TaskNode node = TaskNode.builder()
                .taskId(taskId)
                .description(taskDescription)
                .state(TaskState.PLANNED)
                .context(TaskExecutionContext.builder()
                    .taskId(taskId)
                    .taskDescription(taskDescription)
                    .currentState(TaskState.PLANNED)
                    .build())
                .build();
            
            // åˆ†æä¾èµ–å…³ç³»ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
            if (i > 0) {
                node.getDependencies().add("task_" + (i - 1));
                TaskNode prevNode = taskGraph.get("task_" + (i - 1));
                if (prevNode != null) {
                    prevNode.getDependents().add(taskId);
                }
            }
            
            taskGraph.put(taskId, node);
        }
    }
    
    /**
     * è·å–å¯æ‰§è¡Œçš„ä»»åŠ¡åˆ—è¡¨
     */
    public List<TaskNode> getReadyTasks() {
        return taskGraph.values().stream()
            .filter(node -> node.getState() == TaskState.PLANNED || 
                          node.getState() == TaskState.PENDING)
            .filter(node -> node.isReadyToExecute(taskGraph))
            .collect(Collectors.toList());
    }
    
    /**
     * æ›´æ–°ä»»åŠ¡çŠ¶æ€å¹¶è§¦å‘ä¾èµ–æ£€æŸ¥
     */
    public void updateTaskState(String taskId, TaskState newState) {
        TaskNode node = taskGraph.get(taskId);
        if (node != null) {
            TaskState oldState = node.getState();
            node.setState(newState);
            node.getContext().updateState(newState);
            
            log.info("Task {} state updated: {} -> {}", taskId, oldState, newState);
            
            // å¦‚æœä»»åŠ¡å®Œæˆï¼Œæ£€æŸ¥å…¶ä¾èµ–ä»»åŠ¡
            if (newState == TaskState.COMPLETED) {
                checkDependentTasks(taskId);
            }
            
            // å¦‚æœä»»åŠ¡å¤±è´¥ï¼Œå¤„ç†ä¾èµ–ä»»åŠ¡
            if (newState == TaskState.FAILED) {
                handleFailedTaskDependencies(taskId);
            }
        }
    }
    
    /**
     * æ£€æŸ¥ä¾èµ–ä»»åŠ¡æ˜¯å¦å¯ä»¥å¼€å§‹æ‰§è¡Œ
     */
    private void checkDependentTasks(String completedTaskId) {
        TaskNode completedTask = taskGraph.get(completedTaskId);
        if (completedTask != null) {
            completedTask.getDependents().forEach(dependentId -> {
                TaskNode dependent = taskGraph.get(dependentId);
                if (dependent != null && 
                    dependent.getState() == TaskState.PLANNED &&
                    dependent.isReadyToExecute(taskGraph)) {
                    
                    // å°†ä¾èµ–ä»»åŠ¡æ ‡è®°ä¸ºå¾…æ‰§è¡Œ
                    updateTaskState(dependentId, TaskState.PENDING);
                }
            });
        }
    }
    
    /**
     * å¤„ç†å¤±è´¥ä»»åŠ¡çš„ä¾èµ–å…³ç³»
     */
    private void handleFailedTaskDependencies(String failedTaskId) {
        TaskNode failedTask = taskGraph.get(failedTaskId);
        if (failedTask != null) {
            // é€’å½’æ ‡è®°æ‰€æœ‰ä¾èµ–ä»»åŠ¡ä¸ºè·³è¿‡çŠ¶æ€
            markDependentsAsSkipped(failedTaskId);
        }
    }
    
    private void markDependentsAsSkipped(String taskId) {
        TaskNode task = taskGraph.get(taskId);
        if (task != null) {
            task.getDependents().forEach(dependentId -> {
                TaskNode dependent = taskGraph.get(dependentId);
                if (dependent != null && 
                    (dependent.getState() == TaskState.PLANNED || 
                     dependent.getState() == TaskState.PENDING)) {
                    
                    updateTaskState(dependentId, TaskState.SKIPPED);
                    markDependentsAsSkipped(dependentId); // é€’å½’å¤„ç†
                }
            });
        }
    }
}
```

### 3.2 å·¥ä½œæµæ‰§è¡Œå¼•æ“

```java
/**
 * å·¥ä½œæµæ‰§è¡Œå¼•æ“ - åè°ƒä»»åŠ¡æ‰§è¡Œå’ŒçŠ¶æ€ç®¡ç†
 */
@Component
public class WorkflowExecutionEngine {
    
    @Autowired
    private TaskDependencyManager dependencyManager;
    
    @Autowired
    private ExecutorAgent executorAgent;
    
    private final ScheduledExecutorService scheduler = 
        Executors.newScheduledThreadPool(5);
    
    /**
     * æ‰§è¡Œå·¥ä½œæµ
     */
    public CompletableFuture<WorkflowResult> executeWorkflow(Plan plan) {
        String workflowId = UUID.randomUUID().toString();
        log.info("Starting workflow execution: {}", workflowId);
        
        // æ„å»ºä»»åŠ¡ä¾èµ–å›¾
        dependencyManager.buildDependencyGraph(plan);
        
        // åˆ›å»ºå·¥ä½œæµæ‰§è¡Œä¸Šä¸‹æ–‡
        WorkflowExecutionContext context = WorkflowExecutionContext.builder()
            .workflowId(workflowId)
            .plan(plan)
            .startTime(System.currentTimeMillis())
            .state(WorkflowState.RUNNING)
            .build();
        
        // å¼‚æ­¥æ‰§è¡Œå·¥ä½œæµ
        return CompletableFuture.supplyAsync(() -> {
            try {
                return executeWorkflowInternal(context);
            } catch (Exception e) {
                log.error("Workflow execution failed: {}", workflowId, e);
                context.setState(WorkflowState.FAILED);
                context.setErrorMessage(e.getMessage());
                return WorkflowResult.failure(workflowId, e.getMessage());
            }
        });
    }
    
    /**
     * å†…éƒ¨å·¥ä½œæµæ‰§è¡Œé€»è¾‘
     */
    private WorkflowResult executeWorkflowInternal(WorkflowExecutionContext context) {
        while (context.getState() == WorkflowState.RUNNING) {
            // è·å–å¯æ‰§è¡Œçš„ä»»åŠ¡
            List<TaskDependencyManager.TaskNode> readyTasks = 
                dependencyManager.getReadyTasks();
            
            if (readyTasks.isEmpty()) {
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
                if (isWorkflowComplete()) {
                    context.setState(WorkflowState.COMPLETED);
                    break;
                } else {
                    // ç­‰å¾…æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡å®Œæˆ
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                    continue;
                }
            }
            
            // å¹¶è¡Œæ‰§è¡Œå¯æ‰§è¡Œçš„ä»»åŠ¡
            List<CompletableFuture<Void>> taskFutures = readyTasks.stream()
                .map(this::executeTaskAsync)
                .collect(Collectors.toList());
            
            // ç­‰å¾…å½“å‰æ‰¹æ¬¡ä»»åŠ¡å®Œæˆ
            CompletableFuture.allOf(taskFutures.toArray(new CompletableFuture[0]))
                .join();
        }
        
        // ç”Ÿæˆæ‰§è¡Œç»“æœ
        context.setEndTime(System.currentTimeMillis());
        return generateWorkflowResult(context);
    }
    
    /**
     * å¼‚æ­¥æ‰§è¡Œå•ä¸ªä»»åŠ¡
     */
    private CompletableFuture<Void> executeTaskAsync(TaskDependencyManager.TaskNode taskNode) {
        return CompletableFuture.runAsync(() -> {
            try {
                log.info("Executing task: {}", taskNode.getTaskId());
                
                // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºæ‰§è¡Œä¸­
                dependencyManager.updateTaskState(taskNode.getTaskId(), TaskState.RUNNING);
                
                // åˆ›å»ºReActæ‰§è¡Œå™¨
                ReActTaskStateMachine reactMachine = new ReActTaskStateMachine();
                reactMachine.setTaskContext(taskNode.getContext());
                
                // æ‰§è¡Œä»»åŠ¡
                TaskExecutionResult result = null;
                while (result == null || result.isIntermediate()) {
                    result = reactMachine.executeIteration();
                    
                    if (result.isFailure()) {
                        dependencyManager.updateTaskState(taskNode.getTaskId(), TaskState.FAILED);
                        taskNode.getContext().setErrorMessage(result.getMessage());
                        return;
                    }
                }
                
                // ä»»åŠ¡æˆåŠŸå®Œæˆ
                dependencyManager.updateTaskState(taskNode.getTaskId(), TaskState.COMPLETED);
                taskNode.getContext().setResult(result.getMessage());
                
                log.info("Task completed successfully: {}", taskNode.getTaskId());
                
            } catch (Exception e) {
                log.error("Task execution failed: {}", taskNode.getTaskId(), e);
                dependencyManager.updateTaskState(taskNode.getTaskId(), TaskState.FAILED);
                taskNode.getContext().setErrorMessage(e.getMessage());
            }
        });
    }
    
    /**
     * æ£€æŸ¥å·¥ä½œæµæ˜¯å¦å®Œæˆ
     */
    private boolean isWorkflowComplete() {
        return dependencyManager.getAllTasks().stream()
            .allMatch(task -> task.getState() == TaskState.COMPLETED ||
                             task.getState() == TaskState.FAILED ||
                             task.getState() == TaskState.SKIPPED);
    }
}
```

## 4. ä»»åŠ¡å¤±è´¥æ¢å¤ä¸çŠ¶æ€å›æ»š

### 4.1 ä»»åŠ¡å¤±è´¥æ¢å¤ç­–ç•¥

```java
/**
 * ä»»åŠ¡æ¢å¤ç­–ç•¥ç®¡ç†å™¨
 */
@Component
public class TaskRecoveryManager {
    
    public enum RecoveryStrategy {
        RETRY,           // é‡è¯•ç­–ç•¥ï¼šé‡æ–°æ‰§è¡Œå¤±è´¥çš„ä»»åŠ¡
        SKIP,            // è·³è¿‡ç­–ç•¥ï¼šè·³è¿‡å¤±è´¥ä»»åŠ¡ï¼Œç»§ç»­æ‰§è¡Œåç»­ä»»åŠ¡
        FALLBACK,        // é™çº§ç­–ç•¥ï¼šä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆæ‰§è¡Œä»»åŠ¡
        RESTART,         // é‡å¯ç­–ç•¥ï¼šä»æ£€æŸ¥ç‚¹é‡æ–°å¼€å§‹æ‰§è¡Œ
        MANUAL          // æ‰‹åŠ¨ç­–ç•¥ï¼šéœ€è¦äººå·¥ä»‹å…¥å¤„ç†
    }
    
    /**
     * å¤„ç†ä»»åŠ¡å¤±è´¥
     */
    public void handleTaskFailure(TaskDependencyManager.TaskNode failedTask, Exception error) {
        TaskExecutionContext context = failedTask.getContext();
        RecoveryStrategy strategy = determineRecoveryStrategy(failedTask, error);
        
        log.info("Handling task failure for {}, strategy: {}", 
            failedTask.getTaskId(), strategy);
        
        switch (strategy) {
            case RETRY:
                handleRetryStrategy(failedTask);
                break;
            case SKIP:
                handleSkipStrategy(failedTask);
                break;
            case FALLBACK:
                handleFallbackStrategy(failedTask);
                break;
            case RESTART:
                handleRestartStrategy(failedTask);
                break;
            case MANUAL:
                handleManualStrategy(failedTask);
                break;
            default:
                log.warn("Unknown recovery strategy: {}", strategy);
        }
    }
    
    /**
     * ç¡®å®šæ¢å¤ç­–ç•¥
     */
    private RecoveryStrategy determineRecoveryStrategy(
            TaskDependencyManager.TaskNode task, Exception error) {
        
        TaskExecutionContext context = task.getContext();
        
        // æ ¹æ®é”™è¯¯ç±»å‹å’Œé‡è¯•æ¬¡æ•°ç¡®å®šç­–ç•¥
        if (error instanceof ToolExecutionException) {
            ToolExecutionException toolError = (ToolExecutionException) error;
            if (toolError.isRetryable() && context.getRetryCount() < context.getMaxRetries()) {
                return RecoveryStrategy.RETRY;
            } else if (toolError.hasFallback()) {
                return RecoveryStrategy.FALLBACK;
            }
        } else if (error instanceof NetworkException) {
            if (context.getRetryCount() < 2) {
                return RecoveryStrategy.RETRY;
            }
        } else if (error instanceof TokenLimitExceeded) {
            return RecoveryStrategy.RESTART; // ä»æ£€æŸ¥ç‚¹é‡æ–°å¼€å§‹
        }
        
        // æ ¹æ®ä»»åŠ¡é‡è¦æ€§å†³å®š
        if (isTaskCritical(task)) {
            return RecoveryStrategy.MANUAL;
        } else {
            return RecoveryStrategy.SKIP;
        }
    }
    
    /**
     * é‡è¯•ç­–ç•¥å¤„ç†
     */
    private void handleRetryStrategy(TaskDependencyManager.TaskNode task) {
        TaskExecutionContext context = task.getContext();
        context.setRetryCount(context.getRetryCount() + 1);
        
        // æ¸…ç†ä¹‹å‰çš„å¤±è´¥çŠ¶æ€
        context.setErrorMessage(null);
        context.getIntermediateResults().clear();
        
        // å»¶è¿Ÿé‡è¯•
        long delay = calculateRetryDelay(context.getRetryCount());
        scheduler.schedule(() -> {
            // é‡ç½®ä»»åŠ¡çŠ¶æ€ä¸ºå¾…æ‰§è¡Œ
            dependencyManager.updateTaskState(task.getTaskId(), TaskState.PENDING);
            log.info("Retrying task {} (attempt {})", 
                task.getTaskId(), context.getRetryCount());
        }, delay, TimeUnit.SECONDS);
    }
    
    /**
     * é™çº§ç­–ç•¥å¤„ç†
     */
    private void handleFallbackStrategy(TaskDependencyManager.TaskNode task) {
        log.info("Applying fallback strategy for task: {}", task.getTaskId());
        
        // ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬çš„ä»»åŠ¡æè¿°
        String fallbackDescription = generateFallbackTask(task.getDescription());
        task.setDescription(fallbackDescription);
        
        // é‡ç½®ä»»åŠ¡çŠ¶æ€
        task.getContext().setRetryCount(0);
        dependencyManager.updateTaskState(task.getTaskId(), TaskState.PENDING);
    }
    
    /**
     * æ£€æŸ¥ç‚¹é‡å¯ç­–ç•¥
     */
    private void handleRestartStrategy(TaskDependencyManager.TaskNode task) {
        log.info("Restarting task from checkpoint: {}", task.getTaskId());
        
        // åŠ è½½æœ€è¿‘çš„æ£€æŸ¥ç‚¹
        TaskCheckpoint checkpoint = loadLastCheckpoint(task.getTaskId());
        if (checkpoint != null) {
            // æ¢å¤åˆ°æ£€æŸ¥ç‚¹çŠ¶æ€
            restoreFromCheckpoint(task, checkpoint);
            dependencyManager.updateTaskState(task.getTaskId(), TaskState.PENDING);
        } else {
            // æ— æ£€æŸ¥ç‚¹ï¼Œå®Œå…¨é‡æ–°å¼€å§‹
            task.getContext().setRetryCount(0);
            task.getContext().getIntermediateResults().clear();
            dependencyManager.updateTaskState(task.getTaskId(), TaskState.PENDING);
        }
    }
    
    /**
     * è®¡ç®—é‡è¯•å»¶è¿Ÿï¼ˆæŒ‡æ•°é€€é¿ï¼‰
     */
    private long calculateRetryDelay(int retryCount) {
        return Math.min(60, (long) Math.pow(2, retryCount - 1));
    }
}
```

### 4.2 çŠ¶æ€å¿«ç…§ä¸å›æ»šæœºåˆ¶

```java
/**
 * ä»»åŠ¡çŠ¶æ€å¿«ç…§ç®¡ç†
 */
@Component
public class TaskSnapshotManager {
    
    /**
     * ä»»åŠ¡æ£€æŸ¥ç‚¹æ•°æ®
     */
    @Data
    @Builder
    public static class TaskCheckpoint {
        private String taskId;
        private String checkpointId;
        private TaskState state;
        private List<String> intermediateResults;
        private Map<String, Object> contextData;
        private long timestamp;
        private String description;
    }
    
    private final Map<String, List<TaskCheckpoint>> checkpointStore = 
        new ConcurrentHashMap<>();
    
    /**
     * åˆ›å»ºä»»åŠ¡æ£€æŸ¥ç‚¹
     */
    public void createCheckpoint(TaskDependencyManager.TaskNode task) {
        String checkpointId = UUID.randomUUID().toString();
        
        TaskCheckpoint checkpoint = TaskCheckpoint.builder()
            .taskId(task.getTaskId())
            .checkpointId(checkpointId)
            .state(task.getState())
            .intermediateResults(new ArrayList<>(
                task.getContext().getIntermediateResults()))
            .contextData(new HashMap<>()) // å¤åˆ¶ä¸Šä¸‹æ–‡æ•°æ®
            .timestamp(System.currentTimeMillis())
            .description("Checkpoint at " + task.getState())
            .build();
        
        // å­˜å‚¨æ£€æŸ¥ç‚¹
        checkpointStore.computeIfAbsent(task.getTaskId(), k -> new ArrayList<>())
            .add(checkpoint);
        
        // åªä¿ç•™æœ€è¿‘çš„5ä¸ªæ£€æŸ¥ç‚¹
        List<TaskCheckpoint> checkpoints = checkpointStore.get(task.getTaskId());
        if (checkpoints.size() > 5) {
            checkpoints.remove(0);
        }
        
        log.debug("Created checkpoint {} for task {}", checkpointId, task.getTaskId());
    }
    
    /**
     * å›æ»šåˆ°æŒ‡å®šæ£€æŸ¥ç‚¹
     */
    public boolean rollbackToCheckpoint(TaskDependencyManager.TaskNode task, 
                                       String checkpointId) {
        List<TaskCheckpoint> checkpoints = checkpointStore.get(task.getTaskId());
        if (checkpoints == null) {
            log.warn("No checkpoints found for task: {}", task.getTaskId());
            return false;
        }
        
        TaskCheckpoint targetCheckpoint = checkpoints.stream()
            .filter(cp -> cp.getCheckpointId().equals(checkpointId))
            .findFirst()
            .orElse(null);
        
        if (targetCheckpoint == null) {
            log.warn("Checkpoint {} not found for task {}", checkpointId, task.getTaskId());
            return false;
        }
        
        // æ¢å¤ä»»åŠ¡çŠ¶æ€
        task.setState(targetCheckpoint.getState());
        task.getContext().updateState(targetCheckpoint.getState());
        task.getContext().getIntermediateResults().clear();
        task.getContext().getIntermediateResults()
            .addAll(targetCheckpoint.getIntermediateResults());
        
        log.info("Rolled back task {} to checkpoint {}", 
            task.getTaskId(), checkpointId);
        
        return true;
    }
    
    /**
     * è·å–ä»»åŠ¡çš„æ‰€æœ‰æ£€æŸ¥ç‚¹
     */
    public List<TaskCheckpoint> getTaskCheckpoints(String taskId) {
        return checkpointStore.getOrDefault(taskId, new ArrayList<>());
    }
    
    /**
     * æ¸…ç†è¿‡æœŸæ£€æŸ¥ç‚¹
     */
    @Scheduled(fixedRate = 3600000) // æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡
    public void cleanupExpiredCheckpoints() {
        long expireTime = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);
        
        checkpointStore.values().forEach(checkpoints -> {
            checkpoints.removeIf(checkpoint -> checkpoint.getTimestamp() < expireTime);
        });
        
        // ç§»é™¤ç©ºçš„æ£€æŸ¥ç‚¹åˆ—è¡¨
        checkpointStore.entrySet().removeIf(entry -> entry.getValue().isEmpty());
    }
}
```

## 5. ä»»åŠ¡çŠ¶æ€ç›‘æ§ä¸å¯è§†åŒ–

### 5.1 ä»»åŠ¡çŠ¶æ€ç›‘æ§å™¨

```java
/**
 * ä»»åŠ¡çŠ¶æ€ç›‘æ§å™¨
 */
@Component
public class TaskStateMonitor {
    
    /**
     * ä»»åŠ¡æ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
     */
    @Data
    @Builder
    public static class TaskStatistics {
        private int totalTasks;
        private int completedTasks;
        private int failedTasks;
        private int runningTasks;
        private int pendingTasks;
        private double completionRate;
        private long averageExecutionTime;
        private long totalExecutionTime;
    }
    
    private final Map<String, TaskStateListener> stateListeners = 
        new ConcurrentHashMap<>();
    
    /**
     * ç›‘å¬ä»»åŠ¡çŠ¶æ€å˜åŒ–
     */
    public interface TaskStateListener {
        void onStateChanged(String taskId, TaskState oldState, TaskState newState);
    }
    
    /**
     * æ³¨å†ŒçŠ¶æ€å˜åŒ–ç›‘å¬å™¨
     */
    public void addStateListener(String listenerId, TaskStateListener listener) {
        stateListeners.put(listenerId, listener);
    }
    
    /**
     * é€šçŸ¥çŠ¶æ€å˜åŒ–
     */
    public void notifyStateChange(String taskId, TaskState oldState, TaskState newState) {
        stateListeners.values().forEach(listener -> {
            try {
                listener.onStateChanged(taskId, oldState, newState);
            } catch (Exception e) {
                log.error("Error in state listener", e);
            }
        });
    }
    
    /**
     * è·å–ä»»åŠ¡æ‰§è¡Œç»Ÿè®¡
     */
    public TaskStatistics getTaskStatistics(String workflowId) {
        Map<String, TaskDependencyManager.TaskNode> tasks = 
            dependencyManager.getWorkflowTasks(workflowId);
        
        int total = tasks.size();
        int completed = 0;
        int failed = 0;
        int running = 0;
        int pending = 0;
        long totalExecTime = 0;
        
        for (TaskDependencyManager.TaskNode task : tasks.values()) {
            TaskExecutionContext context = task.getContext();
            
            switch (task.getState()) {
                case COMPLETED:
                    completed++;
                    if (context.getEndTime() > 0 && context.getStartTime() > 0) {
                        totalExecTime += (context.getEndTime() - context.getStartTime());
                    }
                    break;
                case FAILED:
                    failed++;
                    break;
                case RUNNING:
                    running++;
                    break;
                case PENDING:
                case PLANNED:
                    pending++;
                    break;
            }
        }
        
        return TaskStatistics.builder()
            .totalTasks(total)
            .completedTasks(completed)
            .failedTasks(failed)
            .runningTasks(running)
            .pendingTasks(pending)
            .completionRate(total > 0 ? (double) completed / total * 100 : 0)
            .averageExecutionTime(completed > 0 ? totalExecTime / completed : 0)
            .totalExecutionTime(totalExecTime)
            .build();
    }
}
```

## 6. å°ç»“

æœ¬èŠ‚è¯¦ç»†æ¢è®¨äº†ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºä¸å·¥ä½œæµç®¡ç†çš„å…³é”®æŠ€æœ¯ï¼š

1. **ä»»åŠ¡çŠ¶æ€æ¨¡å‹**ï¼šè®¾è®¡äº†å®Œæ•´çš„ä»»åŠ¡çŠ¶æ€æšä¸¾å’Œæ•°æ®æ¨¡å‹
2. **ReActå¾ªç¯**ï¼šå®ç°äº†æ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿ-åæ€çš„çŠ¶æ€æœºå¾ªç¯
3. **ä¾èµ–å›¾ç®¡ç†**ï¼šæ„å»ºäº†ä»»åŠ¡ä¾èµ–å…³ç³»çš„å›¾ç»“æ„å’Œæ‰§è¡Œå¼•æ“
4. **å¤±è´¥æ¢å¤**ï¼šæä¾›äº†å¤šç§ä»»åŠ¡å¤±è´¥æ¢å¤ç­–ç•¥å’ŒçŠ¶æ€å›æ»šæœºåˆ¶
5. **çŠ¶æ€ç›‘æ§**ï¼šå»ºç«‹äº†ä»»åŠ¡çŠ¶æ€çš„ç›‘æ§å’Œç»Ÿè®¡ä½“ç³»

è¿™äº›æŠ€æœ¯ç»„åˆèµ·æ¥ï¼Œå½¢æˆäº†ä¸€ä¸ªå¥å£®ã€å¯é çš„ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºç³»ç»Ÿï¼Œèƒ½å¤Ÿæœ‰æ•ˆå¤„ç†å¤æ‚AIåº”ç”¨ä¸­çš„å¤šä»»åŠ¡åè°ƒå’Œæ‰§è¡Œé—®é¢˜ã€‚

## å»¶ä¼¸æ€è€ƒ

1. å¦‚ä½•ä¼˜åŒ–å¤§è§„æ¨¡ä»»åŠ¡å›¾çš„æ‰§è¡Œæ€§èƒ½ï¼Ÿ
2. å¦‚ä½•å®ç°è·¨ä¼šè¯çš„ä»»åŠ¡çŠ¶æ€æŒä¹…åŒ–ï¼Ÿ
3. å¦‚ä½•è®¾è®¡æ›´æ™ºèƒ½çš„ä»»åŠ¡å¤±è´¥é¢„æµ‹å’Œé¢„é˜²æœºåˆ¶ï¼Ÿ
4. å¦‚ä½•åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­ä¿è¯ä»»åŠ¡æ‰§è¡Œçš„ä¸€è‡´æ€§ï¼Ÿ

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†æ¢è®¨å·¥å…·è°ƒç”¨çŠ¶æ€æœºä¸å¼‚æ­¥æ‰§è¡Œç®¡ç†çš„å…·ä½“å®ç°ã€‚
