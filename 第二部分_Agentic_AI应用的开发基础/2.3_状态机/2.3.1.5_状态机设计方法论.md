# 2.3.1.5 çŠ¶æ€æœºè®¾è®¡æ–¹æ³•è®º

## å­¦ä¹ ç›®æ ‡

ğŸ—ï¸ **æ¶æ„è®¾è®¡**
- æŒæ¡ä»éœ€æ±‚åˆ†æåˆ°çŠ¶æ€æœºè®¾è®¡çš„å®Œæ•´æµç¨‹
- å­¦ä¼šç³»ç»ŸåŒ–çš„çŠ¶æ€è¯†åˆ«ä¸å»ºæ¨¡æ–¹æ³•

âš™ï¸ **å®ç°æŠ€æœ¯**
- ç†Ÿæ‚‰çŠ¶æ€è½¬æ¢è§„åˆ™çš„è®¾è®¡åŸåˆ™å’ŒéªŒè¯æ–¹æ³•
- æŒæ¡çŠ¶æ€æœºçš„æµ‹è¯•å’Œè°ƒè¯•ç­–ç•¥

ğŸš€ **é«˜çº§åº”ç”¨**
- ç†è§£å¤æ‚åœºæ™¯ä¸‹çš„çŠ¶æ€æœºè®¾è®¡æ¨¡å¼
- å­¦ä¼šçŠ¶æ€æœºçš„é‡æ„å’Œä¼˜åŒ–æŠ€å·§

## å¼•è¨€

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å»ºç«‹äº†çŠ¶æ€æœºçš„ç†è®ºåŸºç¡€å’Œè®¾è®¡åŸåˆ™ã€‚ç„¶è€Œï¼Œä»å®é™…çš„ä¸šåŠ¡éœ€æ±‚å‡ºå‘ï¼Œå¦‚ä½•ç³»ç»Ÿæ€§åœ°è®¾è®¡å‡ºé«˜è´¨é‡çš„çŠ¶æ€æœºï¼Œè¿™éœ€è¦ä¸€å¥—å®Œæ•´çš„æ–¹æ³•è®ºæŒ‡å¯¼ã€‚

æœ¬èŠ‚å°†æä¾›ä¸€ä¸ªä»éœ€æ±‚åˆ†æåˆ°çŠ¶æ€æœºå®ç°çš„å®Œæ•´è®¾è®¡æµç¨‹ï¼Œå¸®åŠ©è¯»è€…æŒæ¡çŠ¶æ€æœºè®¾è®¡çš„ç³»ç»Ÿæ–¹æ³•ã€‚

## 1. éœ€æ±‚åˆ†æä¸çŠ¶æ€è¯†åˆ«

### 1.1 ä¸šåŠ¡åœºæ™¯åˆ†æ

ğŸ—ï¸ **æ¶æ„è®¾è®¡**

çŠ¶æ€æœºè®¾è®¡çš„ç¬¬ä¸€æ­¥æ˜¯æ·±å…¥ç†è§£ä¸šåŠ¡åœºæ™¯ã€‚ä»¥Agentic AIåº”ç”¨ä¸­çš„Agentæ‰§è¡Œä¸ºä¾‹ï¼š

**ä¸šåŠ¡åœºæ™¯æè¿°ï¼š**
ç”¨æˆ·å‘AI Agentæå‡ºä¸€ä¸ªå¤æ‚æŸ¥è¯¢ï¼ŒAgentéœ€è¦é€šè¿‡å¤šæ­¥æ¨ç†å’Œå·¥å…·è°ƒç”¨æ¥å®Œæˆä»»åŠ¡ã€‚

**å…³é”®ä¸šåŠ¡æ´»åŠ¨è¯†åˆ«ï¼š**
1. æ¥æ”¶ç”¨æˆ·æŸ¥è¯¢
2. åˆ†æä»»åŠ¡å¤æ‚åº¦
3. åˆ¶å®šæ‰§è¡Œè®¡åˆ’
4. æ‰§è¡Œæ¨ç†æ­¥éª¤
5. è°ƒç”¨å¤–éƒ¨å·¥å…·
6. æ•´åˆæ‰§è¡Œç»“æœ
7. è¿”å›æœ€ç»ˆç­”æ¡ˆ

### 1.2 çŠ¶æ€è¯†åˆ«æ–¹æ³•

#### æ–¹æ³•ä¸€ï¼šæ´»åŠ¨é©±åŠ¨è¯†åˆ«æ³•

åŸºäºä¸šåŠ¡æ´»åŠ¨æ¥è¯†åˆ«çŠ¶æ€ï¼š

```markdown
ä¸šåŠ¡æ´»åŠ¨ â†’ å¯¹åº”çŠ¶æ€
- ç­‰å¾…æŸ¥è¯¢ â†’ IDLE
- åˆ†æå’Œè§„åˆ’ â†’ PLANNING  
- æ‰§è¡Œæ¨ç† â†’ THINKING
- è°ƒç”¨å·¥å…· â†’ ACTING
- æ•´åˆç»“æœ â†’ INTEGRATING
- å®Œæˆä»»åŠ¡ â†’ FINISHED
- å¤„ç†é”™è¯¯ â†’ ERROR
```

#### æ–¹æ³•äºŒï¼šç”Ÿå‘½å‘¨æœŸè¯†åˆ«æ³•

åŸºäºå®ä½“çš„ç”Ÿå‘½å‘¨æœŸæ¥è¯†åˆ«çŠ¶æ€ï¼š

```java
/**
 * Agentç”Ÿå‘½å‘¨æœŸçŠ¶æ€è¯†åˆ«
 */
public class AgentLifecycleAnalysis {
    
    /**
     * åˆ†æAgentç”Ÿå‘½å‘¨æœŸé˜¶æ®µ
     */
    public List<StateCandidate> analyzeLifecycle() {
        return Arrays.asList(
            // åˆ›å»ºé˜¶æ®µ
            new StateCandidate("INITIALIZING", "Agentæ­£åœ¨åˆå§‹åŒ–"),
            
            // å°±ç»ªé˜¶æ®µ  
            new StateCandidate("IDLE", "Agentç­‰å¾…ä»»åŠ¡"),
            
            // æ‰§è¡Œé˜¶æ®µ
            new StateCandidate("RUNNING", "Agentæ‰§è¡Œä»»åŠ¡"),
            
            // å®Œæˆé˜¶æ®µ
            new StateCandidate("FINISHED", "Agentå®Œæˆä»»åŠ¡"),
            
            // å¼‚å¸¸é˜¶æ®µ
            new StateCandidate("ERROR", "Agenté‡åˆ°é”™è¯¯"),
            
            // é”€æ¯é˜¶æ®µ
            new StateCandidate("TERMINATING", "Agentæ­£åœ¨ç»ˆæ­¢")
        );
    }
}
```

#### æ–¹æ³•ä¸‰ï¼šäº‹ä»¶é©±åŠ¨è¯†åˆ«æ³•

åŸºäºç³»ç»Ÿäº‹ä»¶æ¥è¯†åˆ«çŠ¶æ€è½¬æ¢ï¼š

```java
/**
 * äº‹ä»¶é©±åŠ¨çŠ¶æ€è¯†åˆ«
 */
public class EventDrivenStateAnalysis {
    
    public Map<String, List<String>> analyzeEventStateMapping() {
        Map<String, List<String>> eventToStates = new HashMap<>();
        
        // ä»»åŠ¡å¼€å§‹äº‹ä»¶
        eventToStates.put("TASK_STARTED", Arrays.asList("IDLE", "RUNNING"));
        
        // ä»»åŠ¡å®Œæˆäº‹ä»¶
        eventToStates.put("TASK_COMPLETED", Arrays.asList("RUNNING", "FINISHED"));
        
        // é”™è¯¯å‘ç”Ÿäº‹ä»¶
        eventToStates.put("ERROR_OCCURRED", Arrays.asList("RUNNING", "ERROR"));
        
        // é‡ç½®äº‹ä»¶
        eventToStates.put("RESET_REQUESTED", Arrays.asList("FINISHED", "ERROR", "IDLE"));
        
        return eventToStates;
    }
}
```

### 1.3 çŠ¶æ€åˆå¹¶ä¸ç®€åŒ–

è¯†åˆ«å‡ºå€™é€‰çŠ¶æ€åï¼Œéœ€è¦è¿›è¡Œåˆå¹¶å’Œç®€åŒ–ï¼š

**åˆå¹¶åŸåˆ™ï¼š**
1. **è¯­ä¹‰ç›¸ä¼¼æ€§**ï¼šåŠŸèƒ½ç›¸ä¼¼çš„çŠ¶æ€å¯ä»¥åˆå¹¶
2. **è½¬æ¢é¢‘ç‡**ï¼šé¢‘ç¹åˆ‡æ¢çš„çŠ¶æ€å¯ä»¥è€ƒè™‘åˆå¹¶
3. **ä¸šåŠ¡ä»·å€¼**ï¼šå¯¹ä¸šåŠ¡å†³ç­–æ²¡æœ‰å½±å“çš„çŠ¶æ€å¯ä»¥çœç•¥

**ç®€åŒ–ç¤ºä¾‹ï¼š**
```
åŸå§‹çŠ¶æ€ï¼šINITIALIZING, IDLE, PLANNING, THINKING, ACTING, INTEGRATING, FINISHED, ERROR
â†“ åˆå¹¶PLANNING, THINKING, ACTING, INTEGRATINGä¸ºRUNNING
ç®€åŒ–çŠ¶æ€ï¼šIDLE, RUNNING, FINISHED, ERROR
```

## 2. çŠ¶æ€è½¬æ¢è§„åˆ™è®¾è®¡

### 2.1 è½¬æ¢è§„åˆ™å»ºæ¨¡

âš™ï¸ **å®ç°æŠ€æœ¯**

#### çŠ¶æ€è½¬æ¢è¡¨è®¾è®¡

```java
/**
 * çŠ¶æ€è½¬æ¢è§„åˆ™å®šä¹‰
 */
public class StateTransitionRules {
    
    // è½¬æ¢è§„åˆ™è¡¨
    private final Map<StateTransition, TransitionRule> rules = new HashMap<>();
    
    public StateTransitionRules() {
        initializeRules();
    }
    
    private void initializeRules() {
        // IDLE -> RUNNING: æ¥æ”¶åˆ°ä»»åŠ¡
        rules.put(
            new StateTransition(IDLE, RUNNING),
            TransitionRule.builder()
                .condition(ctx -> hasValidTask(ctx))
                .action(ctx -> initializeExecution(ctx))
                .guard(ctx -> hasAvailableResources(ctx))
                .build()
        );
        
        // RUNNING -> FINISHED: ä»»åŠ¡å®Œæˆ
        rules.put(
            new StateTransition(RUNNING, FINISHED),
            TransitionRule.builder()
                .condition(ctx -> isTaskCompleted(ctx))
                .action(ctx -> finalizeResults(ctx))
                .build()
        );
        
        // RUNNING -> ERROR: å‘ç”Ÿé”™è¯¯
        rules.put(
            new StateTransition(RUNNING, ERROR),
            TransitionRule.builder()
                .condition(ctx -> hasError(ctx))
                .action(ctx -> handleError(ctx))
                .build()
        );
    }
    
    /**
     * éªŒè¯è½¬æ¢æ˜¯å¦æœ‰æ•ˆ
     */
    public boolean isValidTransition(AgentState from, AgentState to, AgentContext context) {
        StateTransition transition = new StateTransition(from, to);
        TransitionRule rule = rules.get(transition);
        
        if (rule == null) {
            return false; // æ²¡æœ‰å®šä¹‰çš„è½¬æ¢
        }
        
        // æ£€æŸ¥å‰ç½®æ¡ä»¶
        if (!rule.getCondition().test(context)) {
            return false;
        }
        
        // æ£€æŸ¥å®ˆå«æ¡ä»¶
        if (rule.getGuard() != null && !rule.getGuard().test(context)) {
            return false;
        }
        
        return true;
    }
}
```

### 2.2 è½¬æ¢æ¡ä»¶è®¾è®¡

#### æ¡ä»¶åˆ†ç±»ä½“ç³»

```java
/**
 * è½¬æ¢æ¡ä»¶åˆ†ç±»
 */
public abstract class TransitionCondition {
    
    /**
     * æ•°æ®æ¡ä»¶ï¼šåŸºäºçŠ¶æ€æ•°æ®çš„åˆ¤æ–­
     */
    public static class DataCondition extends TransitionCondition {
        public boolean evaluate(AgentContext context) {
            // æ£€æŸ¥ä¸Šä¸‹æ–‡æ•°æ®
            return context.getContextData().containsKey("task") &&
                   context.getContextData().get("task") != null;
        }
    }
    
    /**
     * æ—¶é—´æ¡ä»¶ï¼šåŸºäºæ—¶é—´çš„åˆ¤æ–­
     */
    public static class TimeCondition extends TransitionCondition {
        private final Duration timeout;
        
        public boolean evaluate(AgentContext context) {
            long elapsed = System.currentTimeMillis() - context.getLastUpdateTime();
            return elapsed < timeout.toMillis();
        }
    }
    
    /**
     * èµ„æºæ¡ä»¶ï¼šåŸºäºç³»ç»Ÿèµ„æºçš„åˆ¤æ–­
     */
    public static class ResourceCondition extends TransitionCondition {
        public boolean evaluate(AgentContext context) {
            return hasAvailableMemory() && hasAvailableCPU() && hasNetworkAccess();
        }
    }
    
    /**
     * ä¸šåŠ¡æ¡ä»¶ï¼šåŸºäºä¸šåŠ¡è§„åˆ™çš„åˆ¤æ–­
     */
    public static class BusinessCondition extends TransitionCondition {
        public boolean evaluate(AgentContext context) {
            // æ£€æŸ¥ä¸šåŠ¡è§„åˆ™ï¼Œå¦‚ç”¨æˆ·æƒé™ã€é…é¢é™åˆ¶ç­‰
            return checkUserPermissions(context) && checkQuotaLimits(context);
        }
    }
}
```

### 2.3 è½¬æ¢åŠ¨ä½œè®¾è®¡

```java
/**
 * è½¬æ¢åŠ¨ä½œå®šä¹‰
 */
public interface TransitionAction {
    void execute(AgentContext context);
}

/**
 * å…·ä½“è½¬æ¢åŠ¨ä½œå®ç°
 */
public class StateTransitionActions {
    
    /**
     * åˆå§‹åŒ–æ‰§è¡ŒåŠ¨ä½œ
     */
    public static class InitializeExecutionAction implements TransitionAction {
        @Override
        public void execute(AgentContext context) {
            // åˆå§‹åŒ–æ‰§è¡Œç¯å¢ƒ
            context.getContextData().put("startTime", System.currentTimeMillis());
            context.getContextData().put("stepCount", 0);
            
            // åˆ†é…èµ„æº
            allocateResources(context);
            
            // è®°å½•æ—¥å¿—
            log.info("Agent execution initialized for session: {}", context.getSessionId());
        }
    }
    
    /**
     * å®Œæˆä»»åŠ¡åŠ¨ä½œ
     */
    public static class FinalizeResultsAction implements TransitionAction {
        @Override
        public void execute(AgentContext context) {
            // æ•´ç†ç»“æœ
            Object result = context.getContextData().get("result");
            context.getContextData().put("finalResult", processResult(result));
            
            // æ¸…ç†èµ„æº
            releaseResources(context);
            
            // æ›´æ–°ç»Ÿè®¡
            updateExecutionStatistics(context);
        }
    }
    
    /**
     * é”™è¯¯å¤„ç†åŠ¨ä½œ
     */
    public static class HandleErrorAction implements TransitionAction {
        @Override
        public void execute(AgentContext context) {
            // è®°å½•é”™è¯¯ä¿¡æ¯
            Exception error = (Exception) context.getContextData().get("error");
            log.error("Agent execution failed: {}", error.getMessage(), error);
            
            // ä¿å­˜é”™è¯¯å¿«ç…§
            saveErrorSnapshot(context, error);
            
            // æ¸…ç†èµ„æº
            releaseResources(context);
            
            // å‘é€å‘Šè­¦
            sendErrorAlert(context, error);
        }
    }
}
```

## 3. çŠ¶æ€æœºéªŒè¯ä¸æµ‹è¯•

### 3.1 è®¾è®¡éªŒè¯æ–¹æ³•

âš™ï¸ **å®ç°æŠ€æœ¯**

#### çŠ¶æ€å®Œå¤‡æ€§éªŒè¯

```java
/**
 * çŠ¶æ€æœºè®¾è®¡éªŒè¯å™¨
 */
public class StateMachineValidator {
    
    /**
     * éªŒè¯çŠ¶æ€å®Œå¤‡æ€§
     */
    public ValidationResult validateCompleteness(StateMachineDefinition definition) {
        List<String> issues = new ArrayList<>();
        
        // æ£€æŸ¥æ˜¯å¦æœ‰åˆå§‹çŠ¶æ€
        if (definition.getInitialState() == null) {
            issues.add("Missing initial state");
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç»ˆæ­¢çŠ¶æ€
        if (definition.getFinalStates().isEmpty()) {
            issues.add("No final states defined");
        }
        
        // æ£€æŸ¥çŠ¶æ€å¯è¾¾æ€§
        Set<AgentState> reachableStates = findReachableStates(definition);
        Set<AgentState> allStates = definition.getAllStates();
        
        for (AgentState state : allStates) {
            if (!reachableStates.contains(state)) {
                issues.add("Unreachable state: " + state);
            }
        }
        
        return new ValidationResult(issues.isEmpty(), issues);
    }
    
    /**
     * éªŒè¯è½¬æ¢ä¸€è‡´æ€§
     */
    public ValidationResult validateConsistency(StateMachineDefinition definition) {
        List<String> issues = new ArrayList<>();
        
        // æ£€æŸ¥è½¬æ¢è§„åˆ™çš„ä¸€è‡´æ€§
        for (StateTransition transition : definition.getTransitions()) {
            if (!isTransitionConsistent(transition)) {
                issues.add("Inconsistent transition: " + transition);
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ­»é”çŠ¶æ€
        Set<AgentState> deadlockStates = findDeadlockStates(definition);
        if (!deadlockStates.isEmpty()) {
            issues.add("Deadlock states found: " + deadlockStates);
        }
        
        return new ValidationResult(issues.isEmpty(), issues);
    }
}
```

### 3.2 å•å…ƒæµ‹è¯•ç­–ç•¥

```java
/**
 * çŠ¶æ€æœºå•å…ƒæµ‹è¯•
 */
@Test
public class StateMachineTest {
    
    private StateMachine stateMachine;
    private AgentContext testContext;
    
    @BeforeEach
    void setUp() {
        stateMachine = new AgentStateMachine();
        testContext = createTestContext();
    }
    
    /**
     * æµ‹è¯•æ­£å¸¸æ‰§è¡Œæµç¨‹
     */
    @Test
    void testNormalExecutionFlow() {
        // åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯IDLE
        assertEquals(AgentState.IDLE, stateMachine.getCurrentState());
        
        // å¼€å§‹æ‰§è¡Œ
        assertTrue(stateMachine.transition(AgentState.RUNNING, testContext));
        assertEquals(AgentState.RUNNING, stateMachine.getCurrentState());
        
        // å®Œæˆæ‰§è¡Œ
        testContext.getContextData().put("taskCompleted", true);
        assertTrue(stateMachine.transition(AgentState.FINISHED, testContext));
        assertEquals(AgentState.FINISHED, stateMachine.getCurrentState());
        
        // é‡ç½®çŠ¶æ€
        assertTrue(stateMachine.transition(AgentState.IDLE, testContext));
        assertEquals(AgentState.IDLE, stateMachine.getCurrentState());
    }
    
    /**
     * æµ‹è¯•é”™è¯¯å¤„ç†æµç¨‹
     */
    @Test
    void testErrorHandlingFlow() {
        // è½¬æ¢åˆ°è¿è¡ŒçŠ¶æ€
        stateMachine.transition(AgentState.RUNNING, testContext);
        
        // æ¨¡æ‹Ÿé”™è¯¯å‘ç”Ÿ
        testContext.getContextData().put("error", new RuntimeException("Test error"));
        assertTrue(stateMachine.transition(AgentState.ERROR, testContext));
        assertEquals(AgentState.ERROR, stateMachine.getCurrentState());
        
        // ä»é”™è¯¯çŠ¶æ€æ¢å¤
        testContext.getContextData().remove("error");
        assertTrue(stateMachine.transition(AgentState.IDLE, testContext));
        assertEquals(AgentState.IDLE, stateMachine.getCurrentState());
    }
    
    /**
     * æµ‹è¯•æ— æ•ˆè½¬æ¢
     */
    @Test
    void testInvalidTransitions() {
        // å°è¯•æ— æ•ˆè½¬æ¢ï¼šIDLE -> FINISHED
        assertFalse(stateMachine.transition(AgentState.FINISHED, testContext));
        assertEquals(AgentState.IDLE, stateMachine.getCurrentState());
        
        // å°è¯•æ— æ•ˆè½¬æ¢ï¼šFINISHED -> RUNNING
        stateMachine.forceSetState(AgentState.FINISHED);
        assertFalse(stateMachine.transition(AgentState.RUNNING, testContext));
        assertEquals(AgentState.FINISHED, stateMachine.getCurrentState());
    }
}
```

### 3.3 é›†æˆæµ‹è¯•ç­–ç•¥

```java
/**
 * çŠ¶æ€æœºé›†æˆæµ‹è¯•
 */
@SpringBootTest
public class StateMachineIntegrationTest {
    
    @Autowired
    private AgentService agentService;
    
    /**
     * æµ‹è¯•ç«¯åˆ°ç«¯æ‰§è¡Œæµç¨‹
     */
    @Test
    void testEndToEndExecution() {
        // åˆ›å»ºAgent
        String agentId = agentService.createAgent("test-session");
        
        // æäº¤ä»»åŠ¡
        String taskResult = agentService.executeTask(agentId, "æµ‹è¯•ä»»åŠ¡");
        
        // éªŒè¯ç»“æœ
        assertNotNull(taskResult);
        assertEquals(AgentState.FINISHED, agentService.getAgentState(agentId));
        
        // æ¸…ç†
        agentService.destroyAgent(agentId);
    }
    
    /**
     * æµ‹è¯•å¹¶å‘æ‰§è¡Œ
     */
    @Test
    void testConcurrentExecution() throws InterruptedException {
        int threadCount = 10;
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<Future<String>> futures = new ArrayList<>();
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int taskId = i;
            futures.add(executor.submit(() -> {
                try {
                    String agentId = agentService.createAgent("concurrent-test-" + taskId);
                    String result = agentService.executeTask(agentId, "å¹¶å‘æµ‹è¯•ä»»åŠ¡ " + taskId);
                    agentService.destroyAgent(agentId);
                    return result;
                } finally {
                    latch.countDown();
                }
            }));
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        latch.await(30, TimeUnit.SECONDS);
        
        // éªŒè¯æ‰€æœ‰ä»»åŠ¡éƒ½æˆåŠŸå®Œæˆ
        for (Future<String> future : futures) {
            assertNotNull(future.get());
        }
        
        executor.shutdown();
    }
}
```

## 4. å¤æ‚åœºæ™¯çš„è®¾è®¡æ¨¡å¼

### 4.1 åˆ†å±‚çŠ¶æ€æœºæ¨¡å¼

ğŸš€ **é«˜çº§åº”ç”¨**

```java
/**
 * åˆ†å±‚çŠ¶æ€æœºè®¾è®¡
 */
public class HierarchicalStateMachine {
    
    // ä¸»çŠ¶æ€æœº
    private final StateMachine primaryStateMachine;
    
    // å­çŠ¶æ€æœºæ˜ å°„
    private final Map<AgentState, StateMachine> subStateMachines;
    
    public HierarchicalStateMachine() {
        this.primaryStateMachine = new PrimaryStateMachine();
        this.subStateMachines = new HashMap<>();
        
        // ä¸ºRUNNINGçŠ¶æ€åˆ›å»ºå­çŠ¶æ€æœº
        subStateMachines.put(AgentState.RUNNING, new ExecutionStateMachine());
    }
    
    /**
     * å¤„ç†çŠ¶æ€è½¬æ¢
     */
    public boolean transition(String event, AgentContext context) {
        AgentState currentState = primaryStateMachine.getCurrentState();
        
        // é¦–å…ˆå°è¯•å­çŠ¶æ€æœºå¤„ç†
        StateMachine subStateMachine = subStateMachines.get(currentState);
        if (subStateMachine != null && subStateMachine.canHandle(event)) {
            return subStateMachine.handleEvent(event, context);
        }
        
        // å¦åˆ™ç”±ä¸»çŠ¶æ€æœºå¤„ç†
        return primaryStateMachine.handleEvent(event, context);
    }
    
    /**
     * æ‰§è¡Œå­çŠ¶æ€æœº
     */
    private static class ExecutionStateMachine extends StateMachine {
        
        public enum ExecutionState {
            PLANNING, THINKING, ACTING, INTEGRATING
        }
        
        @Override
        public boolean handleEvent(String event, AgentContext context) {
            switch (event) {
                case "start_planning":
                    return transitionTo(ExecutionState.PLANNING);
                case "start_thinking":
                    return transitionTo(ExecutionState.THINKING);
                case "start_acting":
                    return transitionTo(ExecutionState.ACTING);
                case "start_integrating":
                    return transitionTo(ExecutionState.INTEGRATING);
                default:
                    return false;
            }
        }
    }
}
```

### 4.2 çŠ¶æ€æœºç»„åˆæ¨¡å¼

```java
/**
 * çŠ¶æ€æœºç»„åˆæ¨¡å¼
 */
public class CompositeStateMachine {
    
    private final List<StateMachine> stateMachines;
    private final StateMachineCoordinator coordinator;
    
    public CompositeStateMachine() {
        this.stateMachines = Arrays.asList(
            new AgentStateMachine(),
            new TaskStateMachine(), 
            new ToolStateMachine()
        );
        this.coordinator = new StateMachineCoordinator();
    }
    
    /**
     * åè°ƒå¤šä¸ªçŠ¶æ€æœº
     */
    public void handleEvent(String event, AgentContext context) {
        // å¹¶è¡Œå¤„ç†
        List<CompletableFuture<Boolean>> futures = stateMachines.stream()
            .map(sm -> CompletableFuture.supplyAsync(() -> sm.handleEvent(event, context)))
            .collect(Collectors.toList());
        
        // ç­‰å¾…æ‰€æœ‰çŠ¶æ€æœºå¤„ç†å®Œæˆ
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenRun(() -> coordinator.synchronizeStates(stateMachines, context));
    }
    
    /**
     * çŠ¶æ€æœºåè°ƒå™¨
     */
    private static class StateMachineCoordinator {
        
        public void synchronizeStates(List<StateMachine> stateMachines, AgentContext context) {
            // æ£€æŸ¥çŠ¶æ€ä¸€è‡´æ€§
            boolean consistent = checkConsistency(stateMachines);
            
            if (!consistent) {
                // è§£å†³çŠ¶æ€å†²çª
                resolveConflicts(stateMachines, context);
            }
        }
        
        private boolean checkConsistency(List<StateMachine> stateMachines) {
            // å®ç°çŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥é€»è¾‘
            return true;
        }
        
        private void resolveConflicts(List<StateMachine> stateMachines, AgentContext context) {
            // å®ç°å†²çªè§£å†³é€»è¾‘
        }
    }
}
```

## 5. çŠ¶æ€æœºé‡æ„ä¸ä¼˜åŒ–

### 5.1 é‡æ„è§¦å‘æ¡ä»¶

å½“çŠ¶æ€æœºå‡ºç°ä»¥ä¸‹æƒ…å†µæ—¶ï¼Œåº”è¯¥è€ƒè™‘é‡æ„ï¼š

1. **çŠ¶æ€æ•°é‡è¿‡å¤š**ï¼šè¶…è¿‡10ä¸ªçŠ¶æ€
2. **è½¬æ¢å¤æ‚åº¦é«˜**ï¼šè½¬æ¢æ¡ä»¶è¿‡äºå¤æ‚
3. **ç»´æŠ¤å›°éš¾**ï¼šé¢‘ç¹å‡ºç°bugæˆ–éš¾ä»¥ç†è§£
4. **æ€§èƒ½é—®é¢˜**ï¼šçŠ¶æ€è½¬æ¢è€—æ—¶è¿‡é•¿

### 5.2 é‡æ„ç­–ç•¥

```java
/**
 * çŠ¶æ€æœºé‡æ„å·¥å…·
 */
public class StateMachineRefactoring {
    
    /**
     * çŠ¶æ€åˆå¹¶é‡æ„
     */
    public StateMachineDefinition mergeStates(StateMachineDefinition original, 
                                            Set<AgentState> statesToMerge) {
        // åˆ›å»ºæ–°çš„çŠ¶æ€
        AgentState mergedState = createMergedState(statesToMerge);
        
        // æ›´æ–°è½¬æ¢è§„åˆ™
        Set<StateTransition> newTransitions = updateTransitions(
            original.getTransitions(), statesToMerge, mergedState);
        
        return StateMachineDefinition.builder()
            .states(updateStateSet(original.getStates(), statesToMerge, mergedState))
            .transitions(newTransitions)
            .initialState(original.getInitialState())
            .build();
    }
    
    /**
     * çŠ¶æ€åˆ†è§£é‡æ„
     */
    public StateMachineDefinition decomposeState(StateMachineDefinition original,
                                               AgentState stateToDecompose,
                                               List<AgentState> newStates) {
        // ç§»é™¤åŸçŠ¶æ€
        Set<AgentState> updatedStates = new HashSet<>(original.getStates());
        updatedStates.remove(stateToDecompose);
        updatedStates.addAll(newStates);
        
        // æ›´æ–°è½¬æ¢è§„åˆ™
        Set<StateTransition> newTransitions = redistributeTransitions(
            original.getTransitions(), stateToDecompose, newStates);
        
        return StateMachineDefinition.builder()
            .states(updatedStates)
            .transitions(newTransitions)
            .initialState(original.getInitialState())
            .build();
    }
}
```

## 6. å°ç»“

æœ¬èŠ‚å»ºç«‹äº†çŠ¶æ€æœºè®¾è®¡çš„ç³»ç»Ÿæ–¹æ³•è®ºï¼ŒåŒ…æ‹¬ï¼š

ğŸ—ï¸ **è®¾è®¡æµç¨‹**
- ä»ä¸šåŠ¡åœºæ™¯åˆ†æåˆ°çŠ¶æ€è¯†åˆ«çš„ç³»ç»Ÿæ–¹æ³•
- çŠ¶æ€è½¬æ¢è§„åˆ™çš„å»ºæ¨¡å’Œè®¾è®¡æŠ€æœ¯
- è®¾è®¡éªŒè¯å’Œæµ‹è¯•çš„å®Œæ•´ç­–ç•¥

âš™ï¸ **å®ç°æŠ€å·§**
- å¤šç§çŠ¶æ€è¯†åˆ«æ–¹æ³•çš„åº”ç”¨
- è½¬æ¢æ¡ä»¶å’ŒåŠ¨ä½œçš„åˆ†ç±»è®¾è®¡
- å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•çš„ç­–ç•¥

ğŸš€ **é«˜çº§æ¨¡å¼**
- åˆ†å±‚çŠ¶æ€æœºå’Œç»„åˆçŠ¶æ€æœºçš„è®¾è®¡æ¨¡å¼
- çŠ¶æ€æœºé‡æ„å’Œä¼˜åŒ–çš„ç­–ç•¥
- å¤æ‚åœºæ™¯ä¸‹çš„è®¾è®¡æŠ€å·§

è¿™å¥—æ–¹æ³•è®ºä¸ºåç»­ç« èŠ‚çš„å…·ä½“å®ç°æä¾›äº†ç†è®ºæŒ‡å¯¼ï¼Œç¡®ä¿æˆ‘ä»¬èƒ½å¤Ÿç³»ç»Ÿæ€§åœ°è®¾è®¡å‡ºé«˜è´¨é‡çš„çŠ¶æ€æœºç³»ç»Ÿã€‚

## å»¶ä¼¸æ€è€ƒ

1. å¦‚ä½•åœ¨æ•æ·å¼€å‘ä¸­åº”ç”¨çŠ¶æ€æœºè®¾è®¡æ–¹æ³•è®ºï¼Ÿ
2. å¦‚ä½•å°†çŠ¶æ€æœºè®¾è®¡ä¸é¢†åŸŸé©±åŠ¨è®¾è®¡(DDD)ç»“åˆï¼Ÿ
3. å¦‚ä½•è®¾è®¡æ”¯æŒåŠ¨æ€ä¿®æ”¹çš„çŠ¶æ€æœºï¼Ÿ
4. å¦‚ä½•åœ¨å¾®æœåŠ¡æ¶æ„ä¸­åº”ç”¨åˆ†å¸ƒå¼çŠ¶æ€æœºï¼Ÿ

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†åŸºäºè¿™å¥—æ–¹æ³•è®ºï¼Œæ·±å…¥æ¢è®¨Agentçº§çŠ¶æ€æœºçš„å…·ä½“è®¾è®¡ä¸å®ç°ã€‚
