# 2.3.6 å‰åç«¯çŠ¶æ€åŒæ­¥ä¸å®æ—¶é€šä¿¡çŠ¶æ€æœº

## å­¦ä¹ ç›®æ ‡

ğŸ—ï¸ **æ¶æ„è®¾è®¡å±‚é¢**
- ç†è§£å‰åç«¯çŠ¶æ€åŒæ­¥çš„æ•´ä½“æ¶æ„è®¾è®¡
- æŒæ¡å®æ—¶é€šä¿¡çŠ¶æ€æœºä¸ä¸šåŠ¡çŠ¶æ€æœºçš„åè°ƒæ¨¡å¼
- å­¦ä¼šè®¾è®¡çŠ¶æ€åŒæ­¥åè®®å’Œæ•°æ®æ ¼å¼

âš™ï¸ **å·¥ç¨‹å®ç°å±‚é¢**
- æŒæ¡WebSocketè¿æ¥çš„çŠ¶æ€æœºè®¾è®¡ï¼ˆè¿æ¥ã€æ–­å¼€ã€é‡è¿ã€å¿ƒè·³ï¼‰
- å­¦ä¼šå®ç°å‰ç«¯èŠå¤©çŠ¶æ€ä¸åç«¯æ‰§è¡ŒçŠ¶æ€çš„åŒå‘åŒæ­¥
- ç†è§£SSEï¼ˆServer-Sent Eventsï¼‰æµå¼å“åº”çš„çŠ¶æ€ç®¡ç†
- æŒæ¡å®æ—¶ä»»åŠ¡è¿›åº¦æ›´æ–°çš„çŠ¶æ€æœºå®ç°æ¨¡å¼

ğŸš€ **ä¼ä¸šçº§åº”ç”¨**
- æŒæ¡å¤§è§„æ¨¡å®æ—¶é€šä¿¡çš„çŠ¶æ€ç®¡ç†ç­–ç•¥
- ç†è§£çŠ¶æ€åŒæ­¥çš„æ€§èƒ½ä¼˜åŒ–å’Œå®¹é”™æœºåˆ¶

## å¼•è¨€

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†åç«¯å„ç§çŠ¶æ€æœºçš„è®¾è®¡ï¼šAgentçŠ¶æ€æœºï¼ˆ2.3.2ï¼‰ã€ä»»åŠ¡çŠ¶æ€æœºï¼ˆ2.3.3ï¼‰ã€å·¥å…·çŠ¶æ€æœºï¼ˆ2.3.4ï¼‰å’Œå¤šAgentåä½œçŠ¶æ€æœºï¼ˆ2.3.5ï¼‰ã€‚ç°åœ¨æˆ‘ä»¬éœ€è¦å°†è¿™äº›åç«¯çŠ¶æ€æœ‰æ•ˆåœ°åŒæ­¥åˆ°å‰ç«¯ï¼Œä¸ºç”¨æˆ·æä¾›å®æ—¶çš„çŠ¶æ€åé¦ˆã€‚

å‰åç«¯çŠ¶æ€åŒæ­¥æ˜¯AIåº”ç”¨ç”¨æˆ·ä½“éªŒçš„å…³é”®å› ç´ ï¼Œç‰¹åˆ«æ˜¯åœ¨é•¿æ—¶é—´æ‰§è¡Œçš„AIä»»åŠ¡ä¸­ï¼Œç”¨æˆ·éœ€è¦å®æ—¶äº†è§£ä»»åŠ¡è¿›åº¦ã€AgentçŠ¶æ€å’Œæ‰§è¡Œç»“æœã€‚è¿™ä¸ªåŒæ­¥è¿‡ç¨‹æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„çŠ¶æ€ç®¡ç†é—®é¢˜ï¼Œæ¶‰åŠç½‘ç»œè¿æ¥çŠ¶æ€ã€æ•°æ®ä¼ è¾“çŠ¶æ€ã€UIæ¸²æŸ“çŠ¶æ€ç­‰å¤šä¸ªå±‚é¢ã€‚

åœ¨JoyAgent-JDGenieé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†WebSocketå’ŒSSEæŠ€æœ¯æ¥å®ç°å®æ—¶é€šä¿¡ï¼Œå¹¶åº”ç”¨2.3.1ç« èŠ‚ä¸­çš„**çŠ¶æ€æœºåˆ†å±‚ä¸ç»„åˆ**åŸåˆ™ï¼šé€šä¿¡çŠ¶æ€æœºè´Ÿè´£è¿æ¥ç®¡ç†ï¼Œä¸šåŠ¡çŠ¶æ€æœºè´Ÿè´£æ•°æ®åŒæ­¥ï¼ŒUIçŠ¶æ€æœºè´Ÿè´£ç•Œé¢æ›´æ–°ã€‚æ¯ä¸ªå±‚é¢éƒ½éµå¾ªå‰é¢å­¦åˆ°çš„è®¾è®¡åŸåˆ™ï¼Œç¡®ä¿æ•´ä¸ªç³»ç»Ÿçš„å¯é æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

æœ¬èŠ‚å°†æ·±å…¥åˆ†æå‰åç«¯çŠ¶æ€åŒæ­¥çš„è®¾è®¡åŸç†å’Œå®ç°æ–¹æ¡ˆã€‚

## 1. å‰ç«¯çŠ¶æ€ç®¡ç†æ¶æ„

### 1.1 å‰ç«¯èŠå¤©çŠ¶æ€æ¨¡å‹

```typescript
/**
 * å‰ç«¯èŠå¤©çŠ¶æ€æšä¸¾
 */
export enum ChatState {
  IDLE = 'idle',                    // ç©ºé—²çŠ¶æ€ï¼šç­‰å¾…ç”¨æˆ·è¾“å…¥
  SENDING = 'sending',              // å‘é€ä¸­ï¼šç”¨æˆ·æ¶ˆæ¯æ­£åœ¨å‘é€
  PROCESSING = 'processing',        // å¤„ç†ä¸­ï¼šåç«¯æ­£åœ¨å¤„ç†è¯·æ±‚
  STREAMING = 'streaming',          // æµå¼å“åº”ï¼šæ¥æ”¶å®æ—¶æ•°æ®æµ
  COMPLETED = 'completed',          // å·²å®Œæˆï¼šä»»åŠ¡æ‰§è¡Œå®Œæ¯•
  ERROR = 'error',                  // é”™è¯¯çŠ¶æ€ï¼šå¤„ç†è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯
  TIMEOUT = 'timeout',              // è¶…æ—¶çŠ¶æ€ï¼šè¯·æ±‚è¶…æ—¶
  CANCELLED = 'cancelled'           // å·²å–æ¶ˆï¼šç”¨æˆ·ä¸»åŠ¨å–æ¶ˆä»»åŠ¡
}

/**
 * ä»»åŠ¡çŠ¶æ€æšä¸¾ - ä¸åç«¯ä¿æŒä¸€è‡´
 */
export enum TaskStatus {
  PENDING = 0,      // å¾…å¤„ç†
  RUNNING = 1,      // æ‰§è¡Œä¸­
  COMPLETED = 2,    // å·²å®Œæˆ
  FAILED = 3,       // å¤±è´¥
  CANCELLED = 4     // å–æ¶ˆ
}

/**
 * èŠå¤©é¡¹ç›®çŠ¶æ€æ¥å£
 */
export interface ChatItem {
  query: string;
  files?: File[];
  responseType: "txt" | "json" | "stream";
  sessionId: string;
  requestId: string;
  loading: boolean;
  forceStop: boolean;
  
  // ä»»åŠ¡ç›¸å…³çŠ¶æ€
  tasks: MESSAGE.Task[][];
  taskStatus: TaskStatus;
  thought: string;
  response: string;
  
  // å¤šAgentç›¸å…³çŠ¶æ€
  multiAgent: {
    tasks: MESSAGE.Task[][];
  };
  
  // è®¡åˆ’ç›¸å…³çŠ¶æ€
  plan?: CHAT.Plan;
  planList?: CHAT.PlanItem[];
  conclusion?: any;
}
```

### 1.2 å‰ç«¯çŠ¶æ€æœºå®ç°

```typescript
/**
 * èŠå¤©çŠ¶æ€æœºç®¡ç†å™¨
 */
class ChatStateMachine {
  private state: ChatState = ChatState.IDLE;
  private chatItem: ChatItem | null = null;
  private listeners: Map<string, (state: ChatState) => void> = new Map();
  private stateHistory: Array<{state: ChatState, timestamp: number}> = [];
  
  /**
   * çŠ¶æ€è½¬æ¢éªŒè¯
   */
  private isValidTransition(from: ChatState, to: ChatState): boolean {
    const validTransitions: Record<ChatState, ChatState[]> = {
      [ChatState.IDLE]: [ChatState.SENDING, ChatState.ERROR],
      [ChatState.SENDING]: [ChatState.PROCESSING, ChatState.ERROR, ChatState.TIMEOUT],
      [ChatState.PROCESSING]: [ChatState.STREAMING, ChatState.COMPLETED, ChatState.ERROR, ChatState.TIMEOUT],
      [ChatState.STREAMING]: [ChatState.COMPLETED, ChatState.ERROR, ChatState.CANCELLED],
      [ChatState.COMPLETED]: [ChatState.IDLE],
      [ChatState.ERROR]: [ChatState.IDLE],
      [ChatState.TIMEOUT]: [ChatState.IDLE, ChatState.SENDING],
      [ChatState.CANCELLED]: [ChatState.IDLE]
    };
    
    return validTransitions[from]?.includes(to) ?? false;
  }
  
  /**
   * çŠ¶æ€è½¬æ¢
   */
  public transitionTo(newState: ChatState, context?: any): boolean {
    if (!this.isValidTransition(this.state, newState)) {
      console.warn(`Invalid state transition: ${this.state} -> ${newState}`);
      return false;
    }
    
    const oldState = this.state;
    this.state = newState;
    
    // è®°å½•çŠ¶æ€å†å²
    this.stateHistory.push({
      state: newState,
      timestamp: Date.now()
    });
    
    console.log(`Chat state transition: ${oldState} -> ${newState}`);
    
    // é€šçŸ¥ç›‘å¬å™¨
    this.notifyListeners(newState);
    
    // æ‰§è¡ŒçŠ¶æ€è¿›å…¥é€»è¾‘
    this.onStateEnter(newState, context);
    
    return true;
  }
  
  /**
   * çŠ¶æ€è¿›å…¥å¤„ç†
   */
  private onStateEnter(state: ChatState, context?: any): void {
    switch (state) {
      case ChatState.SENDING:
        this.handleSendingState();
        break;
      case ChatState.PROCESSING:
        this.handleProcessingState();
        break;
      case ChatState.STREAMING:
        this.handleStreamingState();
        break;
      case ChatState.COMPLETED:
        this.handleCompletedState();
        break;
      case ChatState.ERROR:
        this.handleErrorState(context);
        break;
      case ChatState.TIMEOUT:
        this.handleTimeoutState();
        break;
      case ChatState.CANCELLED:
        this.handleCancelledState();
        break;
    }
  }
  
  /**
   * å¤„ç†å‘é€ä¸­çŠ¶æ€
   */
  private handleSendingState(): void {
    if (this.chatItem) {
      this.chatItem.loading = true;
      this.chatItem.forceStop = false;
    }
  }
  
  /**
   * å¤„ç†æµå¼å“åº”çŠ¶æ€
   */
  private handleStreamingState(): void {
    // å¯åŠ¨å¿ƒè·³æ£€æµ‹ï¼Œç¡®ä¿è¿æ¥æ´»è·ƒ
    this.startHeartbeat();
    
    // é‡ç½®å¼ºåˆ¶åœæ­¢æ ‡å¿—
    if (this.chatItem) {
      this.chatItem.forceStop = false;
    }
  }
  
  /**
   * å¤„ç†å®ŒæˆçŠ¶æ€
   */
  private handleCompletedState(): void {
    this.stopHeartbeat();
    
    if (this.chatItem) {
      this.chatItem.loading = false;
      this.chatItem.taskStatus = TaskStatus.COMPLETED;
    }
    
    // å»¶æ—¶è½¬æ¢åˆ°ç©ºé—²çŠ¶æ€
    setTimeout(() => {
      this.transitionTo(ChatState.IDLE);
    }, 1000);
  }
  
  /**
   * å¤„ç†é”™è¯¯çŠ¶æ€
   */
  private handleErrorState(error?: any): void {
    this.stopHeartbeat();
    
    if (this.chatItem) {
      this.chatItem.loading = false;
      this.chatItem.taskStatus = TaskStatus.FAILED;
    }
    
    console.error('Chat state error:', error);
    
    // æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
    this.showErrorNotification(error);
  }
  
  private heartbeatTimer: NodeJS.Timeout | null = null;
  
  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.heartbeatTimer = setInterval(() => {
      // å‘é€å¿ƒè·³æˆ–æ£€æŸ¥è¿æ¥çŠ¶æ€
      this.checkConnectionHealth();
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
}
```

### 1.3 æ¶ˆæ¯çŠ¶æ€ç»„åˆä¸å¤„ç†

```typescript
/**
 * æ¶ˆæ¯çŠ¶æ€ç»„åˆå¤„ç†å™¨
 */
export const combineData = (
  eventData: MESSAGE.EventData,
  currentChat: CHAT.ChatItem
): CHAT.ChatItem => {
  
  const messageType = eventData.messageType;
  
  switch (messageType) {
    case "plan":
      return handlePlanMessage(eventData, currentChat);
    case "plan_thought":
      return handlePlanThoughtMessage(eventData, currentChat);
    case "task":
      return handleTaskMessage(eventData, currentChat);
    case "content":
      return handleContentMessage(eventData, currentChat);
    case "code":
      return handleCodeMessage(eventData, currentChat);
    case "deep_search":
      return handleDeepSearchMessage(eventData, currentChat);
    case "result":
      return handleResultMessage(eventData, currentChat);
    default:
      console.warn("Unknown message type:", messageType);
      return currentChat;
  }
};

/**
 * å¤„ç†è®¡åˆ’ç±»å‹æ¶ˆæ¯
 */
function handlePlanMessage(eventData: MESSAGE.EventData, currentChat: CHAT.ChatItem): CHAT.ChatItem {
  const plan = eventData.plan;
  if (plan) {
    currentChat.plan = plan;
    
    // æ„å»ºè®¡åˆ’é¡¹ç›®åˆ—è¡¨
    currentChat.planList = plan.stages?.reduce(
      (result: CHAT.PlanItem[], stage: string, index: number) => {
        const group = result.find((item) => item.name === stage);
        if (group) {
          group.list.push(plan.steps[index] || "");
        } else {
          result.push({
            name: stage,
            list: [plan.steps[index] || ""],
          });
        }
        return result;
      },
      []
    );
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€
    if (plan.stepStatus) {
      const completedCount = plan.stepStatus.filter(status => status === "completed").length;
      const totalCount = plan.stepStatus.length;
      
      if (completedCount === totalCount) {
        currentChat.taskStatus = TaskStatus.COMPLETED;
      } else if (completedCount > 0) {
        currentChat.taskStatus = TaskStatus.RUNNING;
      } else {
        currentChat.taskStatus = TaskStatus.PENDING;
      }
    }
  }
  
  return currentChat;
}

/**
 * å¤„ç†å†…å®¹æ¶ˆæ¯
 */
function handleContentMessage(eventData: MESSAGE.EventData, currentChat: CHAT.ChatItem): CHAT.ChatItem {
  const taskIndex = findTaskIndex(currentChat.multiAgent.tasks, eventData.taskId);
  const toolIndex = taskIndex !== -1 ? findToolIndex(
    currentChat.multiAgent.tasks[taskIndex], 
    eventData.taskId
  ) : -1;
  
  if (taskIndex !== -1) {
    if (toolIndex !== -1) {
      // æ›´æ–°ç°æœ‰å·¥å…·æ‰§è¡Œç»“æœ
      const tool = currentChat.multiAgent.tasks[taskIndex][toolIndex];
      
      if (eventData.resultMap.resultMap.isFinal) {
        // æœ€ç»ˆç»“æœ
        tool.resultMap = {
          ...eventData.resultMap.resultMap,
          codeOutput: eventData.resultMap.resultMap.data,
        };
        
        // æ›´æ–°å·¥å…·çŠ¶æ€
        tool.status = TaskStatus.COMPLETED;
      } else {
        // ä¸­é—´ç»“æœ
        tool.resultMap.isFinal = false;
        tool.resultMap.codeOutput = (tool.resultMap.codeOutput || "") + 
          (eventData.resultMap.resultMap?.data || "");
        
        // æ›´æ–°å·¥å…·çŠ¶æ€
        tool.status = TaskStatus.RUNNING;
      }
    } else {
      // æ·»åŠ æ–°çš„å·¥å…·æ‰§è¡Œ
      const newTool: MESSAGE.Task = {
        taskId: eventData.taskId,
        messageType: eventData.messageType,
        status: eventData.resultMap.resultMap.isFinal ? TaskStatus.COMPLETED : TaskStatus.RUNNING,
        ...eventData.resultMap,
      };
      
      currentChat.multiAgent.tasks[taskIndex].push(newTool);
    }
  } else {
    // æ·»åŠ æ–°çš„ä»»åŠ¡ç»„
    const newTask: MESSAGE.Task = {
      taskId: eventData.taskId,
      messageType: eventData.messageType,
      status: eventData.resultMap.resultMap.isFinal ? TaskStatus.COMPLETED : TaskStatus.RUNNING,
      ...eventData.resultMap,
    };
    
    currentChat.multiAgent.tasks.push([newTask]);
  }
  
  return currentChat;
}
```

## 2. WebSocketè¿æ¥çŠ¶æ€æœº

### 2.1 WebSocketè¿æ¥çŠ¶æ€è®¾è®¡

```typescript
/**
 * WebSocketè¿æ¥çŠ¶æ€æšä¸¾
 */
export enum WebSocketState {
  DISCONNECTED = 'disconnected',     // æœªè¿æ¥
  CONNECTING = 'connecting',         // è¿æ¥ä¸­
  CONNECTED = 'connected',           // å·²è¿æ¥
  RECONNECTING = 'reconnecting',     // é‡è¿ä¸­
  ERROR = 'error',                   // è¿æ¥é”™è¯¯
  CLOSING = 'closing',               // å…³é—­ä¸­
  CLOSED = 'closed'                  // å·²å…³é—­
}

/**
 * WebSocketçŠ¶æ€æœºç®¡ç†å™¨
 */
class WebSocketStateMachine {
  private state: WebSocketState = WebSocketState.DISCONNECTED;
  private websocket: WebSocket | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelay: number = 1000;
  private heartbeatInterval: number = 30000;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private lastHeartbeat: number = 0;
  
  constructor(private url: string, private onMessage?: (data: any) => void) {}
  
  /**
   * è¿æ¥WebSocket
   */
  public connect(): Promise<void> {
    if (this.state === WebSocketState.CONNECTED || 
        this.state === WebSocketState.CONNECTING) {
      return Promise.resolve();
    }
    
    this.transitionTo(WebSocketState.CONNECTING);
    
    return new Promise((resolve, reject) => {
      try {
        this.websocket = new WebSocket(this.url);
        
        this.websocket.onopen = (event) => {
          this.transitionTo(WebSocketState.CONNECTED);
          this.reconnectAttempts = 0;
          this.startHeartbeat();
          resolve();
        };
        
        this.websocket.onmessage = (event) => {
          this.handleMessage(event);
        };
        
        this.websocket.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.transitionTo(WebSocketState.ERROR);
          reject(error);
        };
        
        this.websocket.onclose = (event) => {
          this.handleClose(event);
        };
        
        // è¿æ¥è¶…æ—¶å¤„ç†
        setTimeout(() => {
          if (this.state === WebSocketState.CONNECTING) {
            this.transitionTo(WebSocketState.ERROR);
            reject(new Error('Connection timeout'));
          }
        }, 10000);
        
      } catch (error) {
        this.transitionTo(WebSocketState.ERROR);
        reject(error);
      }
    });
  }
  
  /**
   * å‘é€æ¶ˆæ¯
   */
  public sendMessage(message: any): boolean {
    if (this.state !== WebSocketState.CONNECTED || !this.websocket) {
      console.warn('WebSocket not connected, message not sent');
      return false;
    }
    
    try {
      const messageStr = typeof message === 'string' ? message : JSON.stringify(message);
      this.websocket.send(messageStr);
      return true;
    } catch (error) {
      console.error('Failed to send WebSocket message:', error);
      this.transitionTo(WebSocketState.ERROR);
      return false;
    }
  }
  
  /**
   * å…³é—­è¿æ¥
   */
  public close(): void {
    if (this.state === WebSocketState.DISCONNECTED || 
        this.state === WebSocketState.CLOSED) {
      return;
    }
    
    this.transitionTo(WebSocketState.CLOSING);
    this.stopHeartbeat();
    
    if (this.websocket) {
      this.websocket.close();
    }
  }
  
  /**
   * çŠ¶æ€è½¬æ¢
   */
  private transitionTo(newState: WebSocketState): void {
    const oldState = this.state;
    this.state = newState;
    
    console.log(`WebSocket state transition: ${oldState} -> ${newState}`);
    
    // çŠ¶æ€å˜æ›´å¤„ç†
    this.onStateChange(oldState, newState);
  }
  
  /**
   * å¤„ç†çŠ¶æ€å˜æ›´
   */
  private onStateChange(from: WebSocketState, to: WebSocketState): void {
    switch (to) {
      case WebSocketState.CONNECTED:
        console.log('WebSocket connected successfully');
        break;
        
      case WebSocketState.ERROR:
        console.error('WebSocket entered error state');
        this.stopHeartbeat();
        this.scheduleReconnect();
        break;
        
      case WebSocketState.CLOSED:
        console.log('WebSocket connection closed');
        this.stopHeartbeat();
        this.scheduleReconnect();
        break;
    }
  }
  
  /**
   * å¤„ç†æ¶ˆæ¯æ¥æ”¶
   */
  private handleMessage(event: MessageEvent): void {
    this.lastHeartbeat = Date.now();
    
    try {
      const data = JSON.parse(event.data);
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯å¿ƒè·³å“åº”
      if (data.type === 'heartbeat') {
        return; // å¿ƒè·³æ¶ˆæ¯ä¸éœ€è¦è¿›ä¸€æ­¥å¤„ç†
      }
      
      // è°ƒç”¨æ¶ˆæ¯å¤„ç†å›è°ƒ
      if (this.onMessage) {
        this.onMessage(data);
      }
      
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error);
    }
  }
  
  /**
   * å¤„ç†è¿æ¥å…³é—­
   */
  private handleClose(event: CloseEvent): void {
    const wasConnected = this.state === WebSocketState.CONNECTED;
    
    this.transitionTo(WebSocketState.CLOSED);
    
    // å¦‚æœæ˜¯éæ­£å¸¸å…³é—­ä¸”ä¹‹å‰å·²è¿æ¥ï¼Œå°è¯•é‡è¿
    if (event.code !== 1000 && wasConnected) {
      this.scheduleReconnect();
    }
  }
  
  /**
   * å®‰æ’é‡è¿
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnect attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // æŒ‡æ•°é€€é¿
    
    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    setTimeout(() => {
      if (this.state === WebSocketState.CLOSED || this.state === WebSocketState.ERROR) {
        this.transitionTo(WebSocketState.RECONNECTING);
        this.connect().catch(error => {
          console.error('Reconnect failed:', error);
        });
      }
    }, delay);
  }
  
  /**
   * å¯åŠ¨å¿ƒè·³
   */
  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.lastHeartbeat = Date.now();
    
    this.heartbeatTimer = setInterval(() => {
      if (this.state === WebSocketState.CONNECTED) {
        // å‘é€å¿ƒè·³æ¶ˆæ¯
        this.sendMessage({ type: 'heartbeat', timestamp: Date.now() });
        
        // æ£€æŸ¥å¿ƒè·³è¶…æ—¶
        const now = Date.now();
        if (now - this.lastHeartbeat > this.heartbeatInterval * 2) {
          console.warn('Heartbeat timeout detected');
          this.transitionTo(WebSocketState.ERROR);
        }
      }
    }, this.heartbeatInterval);
  }
  
  /**
   * åœæ­¢å¿ƒè·³
   */
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
}
```

## 3. SSEæµå¼å“åº”çŠ¶æ€ç®¡ç†

### 3.1 SSEè¿æ¥çŠ¶æ€æœº

```typescript
/**
 * SSEï¼ˆServer-Sent Eventsï¼‰çŠ¶æ€æœºç®¡ç†å™¨
 */
class SSEStateMachine {
  private state: 'idle' | 'connecting' | 'connected' | 'error' | 'closed' = 'idle';
  private eventSource: EventSource | null = null;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 3;
  
  constructor(
    private url: string,
    private onMessage: (data: any) => void,
    private onError?: (error: Event) => void,
    private onClose?: () => void
  ) {}
  
  /**
   * å¼€å§‹SSEè¿æ¥
   */
  public start(params: Record<string, any>): void {
    if (this.state === 'connected' || this.state === 'connecting') {
      return;
    }
    
    this.state = 'connecting';
    
    // æ„å»ºæŸ¥è¯¢å‚æ•°
    const queryString = new URLSearchParams(params).toString();
    const fullUrl = `${this.url}?${queryString}`;
    
    try {
      this.eventSource = new EventSource(fullUrl);
      
      this.eventSource.onopen = (event) => {
        this.state = 'connected';
        this.reconnectAttempts = 0;
        console.log('SSE connection opened');
      };
      
      this.eventSource.onmessage = (event) => {
        this.handleMessage(event);
      };
      
      this.eventSource.onerror = (error) => {
        this.handleError(error);
      };
      
    } catch (error) {
      console.error('Failed to create SSE connection:', error);
      this.state = 'error';
      if (this.onError) {
        this.onError(error as Event);
      }
    }
  }
  
  /**
   * åœæ­¢SSEè¿æ¥
   */
  public stop(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    this.state = 'closed';
    
    if (this.onClose) {
      this.onClose();
    }
  }
  
  /**
   * å¤„ç†SSEæ¶ˆæ¯
   */
  private handleMessage(event: MessageEvent): void {
    try {
      // è§£æJSONæ•°æ®
      const data = JSON.parse(event.data);
      
      // æ£€æŸ¥æ¶ˆæ¯çŠ¶æ€
      if (data.finished === true) {
        console.log('SSE stream finished');
        this.stop();
        return;
      }
      
      // æ£€æŸ¥ç‰¹æ®ŠçŠ¶æ€
      if (data.status === "tokenUseUp") {
        console.warn('Token usage limit reached');
        this.stop();
        // å¯ä»¥è§¦å‘ç‰¹æ®Šå¤„ç†é€»è¾‘
        return;
      }
      
      // å¤„ç†æ­£å¸¸æ¶ˆæ¯
      if (data.packageType !== "heartbeat") {
        this.onMessage(data);
      }
      
    } catch (error) {
      console.error('Failed to parse SSE message:', event.data, error);
    }
  }
  
  /**
   * å¤„ç†SSEé”™è¯¯
   */
  private handleError(error: Event): void {
    console.error('SSE connection error:', error);
    this.state = 'error';
    
    if (this.onError) {
      this.onError(error);
    }
    
    // å°è¯•é‡è¿
    this.scheduleReconnect();
  }
  
  /**
   * å®‰æ’é‡è¿
   */
  private scheduleReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max SSE reconnect attempts reached');
      this.state = 'closed';
      return;
    }
    
    this.reconnectAttempts++;
    const delay = 1000 * Math.pow(2, this.reconnectAttempts - 1); // æŒ‡æ•°é€€é¿
    
    console.log(`Scheduling SSE reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);
    
    this.reconnectTimer = setTimeout(() => {
      if (this.state === 'error') {
        this.start({}); // éœ€è¦ä¼ é€’åŸå§‹å‚æ•°
      }
    }, delay);
  }
  
  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  public getState(): string {
    return this.state;
  }
  
  /**
   * æ˜¯å¦è¿æ¥ä¸­
   */
  public isConnected(): boolean {
    return this.state === 'connected';
  }
}
```

### 3.2 æµå¼æ•°æ®å¤„ç†çŠ¶æ€æœº

```typescript
/**
 * æµå¼æ•°æ®å¤„ç†çŠ¶æ€æœº
 */
class StreamDataProcessor {
  private processingState: 'idle' | 'processing' | 'paused' | 'completed' | 'error' = 'idle';
  private dataBuffer: any[] = [];
  private processTimer: NodeJS.Timeout | null = null;
  
  constructor(
    private onDataProcessed: (data: any) => void,
    private onComplete?: () => void,
    private onError?: (error: any) => void
  ) {}
  
  /**
   * æ·»åŠ æ•°æ®åˆ°å¤„ç†é˜Ÿåˆ—
   */
  public addData(data: any): void {
    this.dataBuffer.push({
      data,
      timestamp: Date.now(),
      id: Math.random().toString(36).substr(2, 9)
    });
    
    if (this.processingState === 'idle') {
      this.startProcessing();
    }
  }
  
  /**
   * å¼€å§‹å¤„ç†æ•°æ®
   */
  private startProcessing(): void {
    if (this.processingState !== 'idle') {
      return;
    }
    
    this.processingState = 'processing';
    this.processNextBatch();
  }
  
  /**
   * å¤„ç†ä¸‹ä¸€æ‰¹æ•°æ®
   */
  private processNextBatch(): void {
    if (this.processingState !== 'processing') {
      return;
    }
    
    if (this.dataBuffer.length === 0) {
      this.processingState = 'idle';
      return;
    }
    
    // æ‰¹é‡å¤„ç†æ•°æ®ï¼Œé¿å…ç•Œé¢é˜»å¡
    const batchSize = Math.min(5, this.dataBuffer.length);
    const batch = this.dataBuffer.splice(0, batchSize);
    
    try {
      // å¤„ç†å½“å‰æ‰¹æ¬¡
      batch.forEach(item => {
        this.onDataProcessed(item.data);
      });
      
      // å®‰æ’ä¸‹ä¸€æ‰¹æ¬¡å¤„ç†
      this.processTimer = setTimeout(() => {
        this.processNextBatch();
      }, 10); // 10msé—´éš”ï¼Œä¿è¯ç•Œé¢å“åº”æ€§
      
    } catch (error) {
      console.error('Error processing stream data:', error);
      this.processingState = 'error';
      
      if (this.onError) {
        this.onError(error);
      }
    }
  }
  
  /**
   * æš‚åœå¤„ç†
   */
  public pause(): void {
    if (this.processingState === 'processing') {
      this.processingState = 'paused';
      
      if (this.processTimer) {
        clearTimeout(this.processTimer);
        this.processTimer = null;
      }
    }
  }
  
  /**
   * æ¢å¤å¤„ç†
   */
  public resume(): void {
    if (this.processingState === 'paused') {
      this.processingState = 'processing';
      this.processNextBatch();
    }
  }
  
  /**
   * åœæ­¢å¤„ç†
   */
  public stop(): void {
    this.processingState = 'completed';
    
    if (this.processTimer) {
      clearTimeout(this.processTimer);
      this.processTimer = null;
    }
    
    // æ¸…ç©ºç¼“å†²åŒº
    this.dataBuffer = [];
    
    if (this.onComplete) {
      this.onComplete();
    }
  }
  
  /**
   * è·å–å¤„ç†çŠ¶æ€
   */
  public getState(): string {
    return this.processingState;
  }
  
  /**
   * è·å–ç¼“å†²åŒºå¤§å°
   */
  public getBufferSize(): number {
    return this.dataBuffer.length;
  }
}
```

## 4. åç«¯æµå¼å“åº”çŠ¶æ€ç®¡ç†

### 4.1 SSEå“åº”çŠ¶æ€æ§åˆ¶å™¨

```java
/**
 * SSEå“åº”çŠ¶æ€æ§åˆ¶å™¨
 */
@RestController
public class SSEResponseController {
    
    /**
     * SSEå“åº”çŠ¶æ€æšä¸¾
     */
    public enum SSEResponseState {
        INITIALIZING,    // åˆå§‹åŒ–ä¸­
        STREAMING,       // æµå¼å“åº”ä¸­
        PAUSED,         // æš‚åœå“åº”
        COMPLETED,      // å“åº”å®Œæˆ
        ERROR,          // å“åº”é”™è¯¯
        CANCELLED       // å“åº”å–æ¶ˆ
    }
    
    /**
     * SSEå“åº”ä¸Šä¸‹æ–‡
     */
    @Data
    @Builder
    public static class SSEResponseContext {
        private String responseId;
        private String sessionId;
        private String requestId;
        private SSEResponseState state;
        private SseEmitter emitter;
        private long startTime;
        private long lastSendTime;
        private AtomicLong messageCount;
        private volatile boolean cancelled;
    }
    
    private final Map<String, SSEResponseContext> responseContexts = new ConcurrentHashMap<>();
    private final ScheduledExecutorService heartbeatExecutor = Executors.newScheduledThreadPool(2);
    
    /**
     * åˆ›å»ºSSEæµå¼å“åº”
     */
    @GetMapping("/api/stream")
    public SseEmitter createStreamResponse(
            @RequestParam String sessionId,
            @RequestParam String requestId,
            @RequestParam String query,
            @RequestParam(defaultValue = "0") Integer deepThink,
            @RequestParam(required = false) String outputStyle) {
        
        String responseId = UUID.randomUUID().toString();
        SseEmitter emitter = new SseEmitter(300000L); // 5åˆ†é’Ÿè¶…æ—¶
        
        SSEResponseContext context = SSEResponseContext.builder()
            .responseId(responseId)
            .sessionId(sessionId)
            .requestId(requestId)
            .state(SSEResponseState.INITIALIZING)
            .emitter(emitter)
            .startTime(System.currentTimeMillis())
            .messageCount(new AtomicLong(0))
            .cancelled(false)
            .build();
        
        responseContexts.put(responseId, context);
        
        // è®¾ç½®SSEäº‹ä»¶å¤„ç†
        setupSSEEventHandlers(context);
        
        // å¼‚æ­¥å¤„ç†è¯·æ±‚
        CompletableFuture.runAsync(() -> {
            processStreamingRequest(context, query, deepThink, outputStyle);
        });
        
        return emitter;
    }
    
    /**
     * è®¾ç½®SSEäº‹ä»¶å¤„ç†å™¨
     */
    private void setupSSEEventHandlers(SSEResponseContext context) {
        SseEmitter emitter = context.getEmitter();
        
        // å®Œæˆäº‹ä»¶
        emitter.onCompletion(() -> {
            context.setState(SSEResponseState.COMPLETED);
            responseContexts.remove(context.getResponseId());
            log.info("SSE response completed: {}", context.getResponseId());
        });
        
        // è¶…æ—¶äº‹ä»¶
        emitter.onTimeout(() -> {
            context.setState(SSEResponseState.ERROR);
            responseContexts.remove(context.getResponseId());
            log.warn("SSE response timeout: {}", context.getResponseId());
        });
        
        // é”™è¯¯äº‹ä»¶
        emitter.onError((ex) -> {
            context.setState(SSEResponseState.ERROR);
            responseContexts.remove(context.getResponseId());
            log.error("SSE response error: " + context.getResponseId(), ex);
        });
        
        // å¯åŠ¨å¿ƒè·³
        startHeartbeat(context);
    }
    
    /**
     * å¤„ç†æµå¼è¯·æ±‚
     */
    private void processStreamingRequest(SSEResponseContext context, 
                                       String query, Integer deepThink, String outputStyle) {
        try {
            context.setState(SSEResponseState.STREAMING);
            
            // æ„å»ºAgentè¯·æ±‚
            AgentRequest request = new AgentRequest();
            request.setSessionId(context.getSessionId());
            request.setRequestId(context.getRequestId());
            request.setQuery(query);
            
            // åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨
            StreamMessageHandler messageHandler = new StreamMessageHandler(context);
            
            // æ‰§è¡ŒAgentå¤„ç†
            agentHandlerService.handleAsync(request, messageHandler);
            
        } catch (Exception e) {
            log.error("Error processing streaming request", e);
            sendErrorMessage(context, "Processing failed: " + e.getMessage());
        }
    }
    
    /**
     * æµå¼æ¶ˆæ¯å¤„ç†å™¨
     */
    private class StreamMessageHandler {
        private final SSEResponseContext context;
        
        public StreamMessageHandler(SSEResponseContext context) {
            this.context = context;
        }
        
        /**
         * å¤„ç†Agentæ¶ˆæ¯
         */
        public void handleMessage(String messageType, Object data) {
            if (context.isCancelled() || context.getState() != SSEResponseState.STREAMING) {
                return;
            }
            
            try {
                // æ„å»ºSSEæ¶ˆæ¯
                Map<String, Object> message = new HashMap<>();
                message.put("requestId", context.getRequestId());
                message.put("messageType", messageType);
                message.put("data", data);
                message.put("timestamp", System.currentTimeMillis());
                message.put("finished", false);
                
                // å‘é€æ¶ˆæ¯
                sendMessage(context, message);
                
            } catch (Exception e) {
                log.error("Error handling stream message", e);
                sendErrorMessage(context, "Message handling failed: " + e.getMessage());
            }
        }
        
        /**
         * å¤„ç†å®Œæˆæ¶ˆæ¯
         */
        public void handleCompletion(String result) {
            Map<String, Object> message = new HashMap<>();
            message.put("requestId", context.getRequestId());
            message.put("messageType", "result");
            message.put("result", result);
            message.put("finished", true);
            message.put("timestamp", System.currentTimeMillis());
            
            sendMessage(context, message);
            completeResponse(context);
        }
        
        /**
         * å¤„ç†é”™è¯¯æ¶ˆæ¯
         */
        public void handleError(String error) {
            sendErrorMessage(context, error);
        }
    }
    
    /**
     * å‘é€SSEæ¶ˆæ¯
     */
    private void sendMessage(SSEResponseContext context, Object data) {
        if (context.isCancelled()) {
            return;
        }
        
        try {
            SseEmitter.SseEventBuilder eventBuilder = SseEmitter.event()
                .data(data)
                .id(context.getMessageCount().incrementAndGet());
            
            context.getEmitter().send(eventBuilder);
            context.setLastSendTime(System.currentTimeMillis());
            
        } catch (IOException e) {
            log.error("Failed to send SSE message", e);
            context.setState(SSEResponseState.ERROR);
            context.setCancelled(true);
        }
    }
    
    /**
     * å‘é€é”™è¯¯æ¶ˆæ¯
     */
    private void sendErrorMessage(SSEResponseContext context, String error) {
        Map<String, Object> errorMessage = new HashMap<>();
        errorMessage.put("error", true);
        errorMessage.put("message", error);
        errorMessage.put("finished", true);
        
        sendMessage(context, errorMessage);
        context.setState(SSEResponseState.ERROR);
    }
    
    /**
     * å®Œæˆå“åº”
     */
    private void completeResponse(SSEResponseContext context) {
        try {
            context.setState(SSEResponseState.COMPLETED);
            context.getEmitter().complete();
        } catch (IOException e) {
            log.error("Failed to complete SSE response", e);
        }
    }
    
    /**
     * å¯åŠ¨å¿ƒè·³
     */
    private void startHeartbeat(SSEResponseContext context) {
        heartbeatExecutor.scheduleAtFixedRate(() -> {
            if (context.getState() == SSEResponseState.STREAMING && !context.isCancelled()) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€å¿ƒè·³
                long now = System.currentTimeMillis();
                if (now - context.getLastSendTime() > 30000) { // 30ç§’æ— æ¶ˆæ¯åˆ™å‘é€å¿ƒè·³
                    Map<String, Object> heartbeat = new HashMap<>();
                    heartbeat.put("packageType", "heartbeat");
                    heartbeat.put("timestamp", now);
                    
                    sendMessage(context, heartbeat);
                }
            }
        }, 30, 30, TimeUnit.SECONDS);
    }
}
```

## 5. å‰åç«¯çŠ¶æ€åŒæ­¥æœ€ä½³å®è·µ

### 5.1 çŠ¶æ€åŒæ­¥åè®®è®¾è®¡

```typescript
/**
 * å‰åç«¯çŠ¶æ€åŒæ­¥åè®®
 */
export interface StateSyncProtocol {
  // çŠ¶æ€åŒæ­¥æ¶ˆæ¯ç±»å‹
  type: 'state_sync' | 'state_request' | 'state_response';
  
  // åŒæ­¥èŒƒå›´
  scope: 'chat' | 'task' | 'agent' | 'global';
  
  // çŠ¶æ€æ•°æ®
  state: {
    sessionId: string;
    requestId?: string;
    agentId?: string;
    currentState: string;
    previousState?: string;
    timestamp: number;
    version: number;
  };
  
  // åŒæ­¥å…ƒæ•°æ®
  metadata?: {
    source: 'frontend' | 'backend';
    reliable: boolean;
    priority: number;
  };
}

/**
 * çŠ¶æ€åŒæ­¥ç®¡ç†å™¨
 */
class StateSyncManager {
  private syncQueue: StateSyncProtocol[] = [];
  private syncTimer: NodeJS.Timeout | null = null;
  private lastSyncTime: number = 0;
  private syncInterval: number = 5000; // 5ç§’åŒæ­¥é—´éš”
  
  constructor(
    private websocket: WebSocketStateMachine,
    private onStateUpdate: (state: any) => void
  ) {
    this.startSyncTimer();
  }
  
  /**
   * è¯·æ±‚çŠ¶æ€åŒæ­¥
   */
  public requestStateSync(scope: string, identifier: string): void {
    const syncMessage: StateSyncProtocol = {
      type: 'state_request',
      scope: scope as any,
      state: {
        sessionId: identifier,
        currentState: 'unknown',
        timestamp: Date.now(),
        version: 0
      },
      metadata: {
        source: 'frontend',
        reliable: true,
        priority: 1
      }
    };
    
    this.sendSyncMessage(syncMessage);
  }
  
  /**
   * å‘é€çŠ¶æ€æ›´æ–°
   */
  public sendStateUpdate(scope: string, state: any): void {
    const syncMessage: StateSyncProtocol = {
      type: 'state_sync',
      scope: scope as any,
      state: {
        ...state,
        timestamp: Date.now(),
        version: (state.version || 0) + 1
      },
      metadata: {
        source: 'frontend',
        reliable: false,
        priority: 3
      }
    };
    
    this.addToSyncQueue(syncMessage);
  }
  
  /**
   * å¤„ç†çŠ¶æ€åŒæ­¥å“åº”
   */
  public handleSyncResponse(message: StateSyncProtocol): void {
    if (message.type === 'state_response') {
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      this.onStateUpdate(message.state);
      
      console.log('Received state sync response:', message.state);
    }
  }
  
  /**
   * æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
   */
  private addToSyncQueue(message: StateSyncProtocol): void {
    this.syncQueue.push(message);
    
    // å¦‚æœæ˜¯é«˜ä¼˜å…ˆçº§æ¶ˆæ¯ï¼Œç«‹å³å‘é€
    if (message.metadata?.priority <= 2) {
      this.flushSyncQueue();
    }
  }
  
  /**
   * å‘é€åŒæ­¥æ¶ˆæ¯
   */
  private sendSyncMessage(message: StateSyncProtocol): void {
    if (this.websocket.isConnected()) {
      this.websocket.sendMessage(message);
    } else {
      console.warn('WebSocket not connected, sync message queued');
      this.addToSyncQueue(message);
    }
  }
  
  /**
   * æ¸…ç©ºåŒæ­¥é˜Ÿåˆ—
   */
  private flushSyncQueue(): void {
    if (this.syncQueue.length === 0) {
      return;
    }
    
    const messages = this.syncQueue.splice(0);
    
    for (const message of messages) {
      this.sendSyncMessage(message);
    }
    
    this.lastSyncTime = Date.now();
  }
  
  /**
   * å¯åŠ¨åŒæ­¥å®šæ—¶å™¨
   */
  private startSyncTimer(): void {
    this.syncTimer = setInterval(() => {
      this.flushSyncQueue();
    }, this.syncInterval);
  }
  
  /**
   * åœæ­¢åŒæ­¥å®šæ—¶å™¨
   */
  public stop(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }
}
```

### 5.2 çŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥

```typescript
/**
 * çŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥å™¨
 */
class StateConsistencyChecker {
  private inconsistencies: Map<string, any> = new Map();
  private checkTimer: NodeJS.Timeout | null = null;
  
  constructor(
    private localStateManager: any,
    private syncManager: StateSyncManager
  ) {
    this.startConsistencyCheck();
  }
  
  /**
   * æ£€æŸ¥çŠ¶æ€ä¸€è‡´æ€§
   */
  public async checkConsistency(scope: string, identifier: string): Promise<boolean> {
    // è·å–æœ¬åœ°çŠ¶æ€
    const localState = this.localStateManager.getState(scope, identifier);
    
    // è¯·æ±‚è¿œç¨‹çŠ¶æ€
    const remoteState = await this.requestRemoteState(scope, identifier);
    
    // æ¯”è¾ƒçŠ¶æ€
    const isConsistent = this.compareStates(localState, remoteState);
    
    if (!isConsistent) {
      this.recordInconsistency(scope, identifier, localState, remoteState);
      await this.resolveInconsistency(scope, identifier, localState, remoteState);
    }
    
    return isConsistent;
  }
  
  /**
   * è¯·æ±‚è¿œç¨‹çŠ¶æ€
   */
  private async requestRemoteState(scope: string, identifier: string): Promise<any> {
    return new Promise((resolve, reject) => {
      // å‘é€çŠ¶æ€è¯·æ±‚
      this.syncManager.requestStateSync(scope, identifier);
      
      // è®¾ç½®è¶…æ—¶
      const timeout = setTimeout(() => {
        reject(new Error('Remote state request timeout'));
      }, 10000);
      
      // ç›‘å¬çŠ¶æ€å“åº”ï¼ˆç®€åŒ–å®ç°ï¼‰
      const handleResponse = (state: any) => {
        if (state.sessionId === identifier) {
          clearTimeout(timeout);
          resolve(state);
        }
      };
      
      // æ³¨å†Œä¸´æ—¶ç›‘å¬å™¨
      this.syncManager.onStateUpdate = handleResponse;
    });
  }
  
  /**
   * æ¯”è¾ƒçŠ¶æ€
   */
  private compareStates(local: any, remote: any): boolean {
    if (!local || !remote) {
      return false;
    }
    
    // æ¯”è¾ƒå…³é”®å­—æ®µ
    const keyFields = ['currentState', 'taskStatus', 'loading'];
    
    for (const field of keyFields) {
      if (local[field] !== remote[field]) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * è®°å½•ä¸ä¸€è‡´æ€§
   */
  private recordInconsistency(scope: string, identifier: string, local: any, remote: any): void {
    const inconsistency = {
      scope,
      identifier,
      localState: local,
      remoteState: remote,
      timestamp: Date.now()
    };
    
    this.inconsistencies.set(`${scope}:${identifier}`, inconsistency);
    
    console.warn('State inconsistency detected:', inconsistency);
  }
  
  /**
   * è§£å†³ä¸ä¸€è‡´æ€§
   */
  private async resolveInconsistency(scope: string, identifier: string, 
                                   local: any, remote: any): Promise<void> {
    // é‡‡ç”¨æ—¶é—´æˆ³ä¼˜å…ˆç­–ç•¥
    const localTimestamp = local.timestamp || 0;
    const remoteTimestamp = remote.timestamp || 0;
    
    if (remoteTimestamp > localTimestamp) {
      // é‡‡ç”¨è¿œç¨‹çŠ¶æ€
      this.localStateManager.setState(scope, identifier, remote);
      console.log('Resolved inconsistency: adopted remote state');
    } else {
      // å‘é€æœ¬åœ°çŠ¶æ€
      this.syncManager.sendStateUpdate(scope, local);
      console.log('Resolved inconsistency: sent local state');
    }
    
    // ç§»é™¤è®°å½•
    this.inconsistencies.delete(`${scope}:${identifier}`);
  }
  
  /**
   * å¯åŠ¨ä¸€è‡´æ€§æ£€æŸ¥
   */
  private startConsistencyCheck(): void {
    this.checkTimer = setInterval(() => {
      // æ£€æŸ¥æ‰€æœ‰æ´»è·ƒçš„ä¼šè¯çŠ¶æ€
      const activeSessions = this.localStateManager.getActiveSessions();
      
      for (const sessionId of activeSessions) {
        this.checkConsistency('chat', sessionId).catch(error => {
          console.error('Consistency check failed:', error);
        });
      }
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  /**
   * åœæ­¢ä¸€è‡´æ€§æ£€æŸ¥
   */
  public stop(): void {
    if (this.checkTimer) {
      clearInterval(this.checkTimer);
      this.checkTimer = null;
    }
  }
}
```

## 6. å°ç»“

æœ¬èŠ‚æ·±å…¥æ¢è®¨äº†å‰åç«¯çŠ¶æ€åŒæ­¥ä¸å®æ—¶é€šä¿¡çŠ¶æ€æœºçš„å…³é”®æŠ€æœ¯ï¼š

1. **å‰ç«¯çŠ¶æ€ç®¡ç†**ï¼šè®¾è®¡äº†èŠå¤©çŠ¶æ€å’Œä»»åŠ¡çŠ¶æ€çš„ç»Ÿä¸€ç®¡ç†æ¨¡å‹
2. **WebSocketçŠ¶æ€æœº**ï¼šå®ç°äº†å¯é çš„WebSocketè¿æ¥ç®¡ç†å’Œè‡ªåŠ¨é‡è¿æœºåˆ¶
3. **SSEæµå¼å“åº”**ï¼šå»ºç«‹äº†æœåŠ¡ç«¯æµå¼æ•°æ®æ¨é€çš„çŠ¶æ€æ§åˆ¶ç³»ç»Ÿ
4. **çŠ¶æ€åŒæ­¥åè®®**ï¼šå®šä¹‰äº†å‰åç«¯çŠ¶æ€åŒæ­¥çš„æ ‡å‡†åŒ–åè®®å’Œä¸€è‡´æ€§æ£€æŸ¥æœºåˆ¶

è¿™äº›æŠ€æœ¯ç¡®ä¿äº†AIåº”ç”¨ä¸­å‰åç«¯çŠ¶æ€çš„å®æ—¶åŒæ­¥å’Œä¸€è‡´æ€§ï¼Œä¸ºç”¨æˆ·æä¾›äº†æµç•…çš„äº¤äº’ä½“éªŒã€‚

## å»¶ä¼¸æ€è€ƒ

1. å¦‚ä½•ä¼˜åŒ–å¤§é‡å¹¶å‘ç”¨æˆ·çš„çŠ¶æ€åŒæ­¥æ€§èƒ½ï¼Ÿ
2. å¦‚ä½•å®ç°ç¦»çº¿çŠ¶æ€çš„æœ¬åœ°ç¼“å­˜å’Œæ¢å¤æœºåˆ¶ï¼Ÿ
3. å¦‚ä½•å¤„ç†ç½‘ç»œä¸ç¨³å®šç¯å¢ƒä¸‹çš„çŠ¶æ€åŒæ­¥é—®é¢˜ï¼Ÿ
4. å¦‚ä½•è®¾è®¡æ›´æ™ºèƒ½çš„å†²çªè§£å†³ç­–ç•¥ï¼Ÿ

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†é€šè¿‡ä¼ä¸šçº§AIåº”ç”¨æ¡ˆä¾‹æ¥åˆ†æçŠ¶æ€æœºæ¶æ„çš„å®é™…åº”ç”¨ã€‚
