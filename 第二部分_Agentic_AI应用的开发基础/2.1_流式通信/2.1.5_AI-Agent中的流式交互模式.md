# 2.1.5 AI Agentä¸­çš„æµå¼äº¤äº’æ¨¡å¼

**å­¦ä¹ ç›®æ ‡ï¼š** ç†è§£AI Agentåœºæ™¯ä¸‹çš„ç‰¹æ®Šæµå¼äº¤äº’éœ€æ±‚ï¼ŒæŒæ¡æ™ºèƒ½åŒ–çš„æµå¼é€šä¿¡æ¨¡å¼

æµå¼é€šä¿¡æœåŠ¡ç«¯è®¾è®¡

åœ¨å­¦ä¹ å®Œæµå¼é€šä¿¡åŸºç¡€åï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåœ¨Agentic AI åº”ç”¨ä¸­çš„å•æ™ºèƒ½ä½“ï¼Œå¦‚ä½•æ„å»ºæµå¼é€šä¿¡æœåŠ¡ç«¯ã€‚
æœ¬æ–‡ä»¥Python AI Agentä½œä¸ºä¾‹å­ã€‚

## 1 Pythonç«¯æµå¼é€šä¿¡å®ç°
``` Python
# Please install OpenAI SDK first: `pip3 install openai`
import os
from openai import OpenAI

client = OpenAI(
    api_key=os.environ.get('DEEPSEEK_API_KEY'),
    base_url="https://api.deepseek.com")

response = client.chat.completions.create(
    model="deepseek-chat",
    messages=[
        {"role": "system", "content": "You are a helpful assistant"},
        {"role": "user", "content": "Hello"},
    ],
    stream=True
)

print(response.choices[0].message.content)
```
è¿™æ®µä»£ç å±•ç¤ºäº†ä¸€ä¸ªæœ€ç®€å•çš„LLMé€šä¿¡ç¤ºä¾‹ï¼Œè¿™æ˜¯åˆ©ç”¨OpenAI SDKè°ƒç”¨LLMçš„æœ€å°å®ç°ã€‚è™½ç„¶ä»£ç ä¸­è®¾ç½®äº†`stream=True`å‚æ•°å¼€å¯äº†æµå¼å“åº”ï¼Œä½†è¿™ä¸ªåŸºç¡€Demoä½œä¸ºLLMçš„ç›´æ¥å®¢æˆ·ç«¯ï¼Œå¹¶ä¸å…·å¤‡æµå¼æ¶ˆæ¯è½¬å‘çš„èƒ½åŠ›ã€‚åœ¨å®é™…çš„AIåº”ç”¨å¼€å‘ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸éœ€è¦åŸºäºæ­¤ç±»LLMå®¢æˆ·ç«¯æ„å»ºä¸€ä¸ªæµå¼æ¶ˆæ¯è½¬å‘æœåŠ¡ï¼Œä»¥å®ç°ä»LLMåˆ°å‰ç«¯ã€åç«¯çš„å®Œæ•´æµå¼é€šä¿¡é“¾è·¯ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†é€šè¿‡äº¬ä¸œçš„ä¸€ä¸ªå¼€æºé¡¹ç›®æ¥å­¦ä¹ å¦‚ä½•åœ¨æœåŠ¡ç«¯å®ç°è¿™æ ·çš„æµå¼è½¬å‘æœåŠ¡ã€‚

ä»¥äº¬ä¸œé¡¹ç›®ä¸­genie_toolçš„  å­¦ä¹ å¦‚ä½•æ„å»ºæµå¼é€šä¿¡æœåŠ¡ç«¯ã€‚

é¡¹ç›®ä½¿ç”¨äº†ä¸‰ä¸ªå…³é”®åº“æ¥å®ç°æµå¼é€šä¿¡ï¼š
```Python
@timer(key="enter")
async def ask_llm(
        messages: str | List[Any],
        model: str,
        temperature: float = None,
        top_p: float = None,
        stream: bool = False,

        # è‡ªå®šä¹‰å­—æ®µ
        only_content: bool = False,     # åªè¿”å›å†…å®¹

        extra_headers: Optional[dict] = None,
        **kwargs,
):
```

æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶ï¼š
litellm - ç»Ÿä¸€å¤šä¸ªLLMæä¾›å•†çš„APIè°ƒç”¨
sse-starlette - FastAPIçš„SSEå®ç°
asyncio - å¼‚æ­¥å¤„ç†æœºåˆ¶


sse_starlette æ˜¯ä¸€ä¸ª Python åº“ï¼Œä¸º Starlette å’Œ FastAPI æ¡†æ¶æä¾›å¯¹ Server-Sent Eventsï¼ˆSSEï¼ŒæœåŠ¡å™¨æ¨é€äº‹ä»¶ï¼‰çš„æ”¯æŒã€‚å®ƒé€šè¿‡ EventSourceResponse ç±»å®ç° SSE åè®®ï¼Œå…è®¸æœåŠ¡å™¨å¼‚æ­¥å‘å®¢æˆ·ç«¯æ¨é€å®æ—¶æ•°æ®ï¼Œé€‚åˆæ„å»ºå®æ—¶ Web åº”ç”¨ï¼Œå¦‚é€šçŸ¥ç³»ç»Ÿã€å®æ—¶ä»ªè¡¨ç›˜æˆ–æµå¼æ•°æ®æ›´æ–°ã€‚sse_starlette è½»é‡ä¸”ä¸ ASGI æ¡†æ¶æ— ç¼é›†æˆï¼Œå¸¸ç”¨äºéœ€è¦é«˜æ•ˆå•å‘é€šä¿¡çš„åœºæ™¯ã€‚

SSEåè®®å®ç° - æä¾›æ ‡å‡†çš„Server-Sent Eventsåè®®æ”¯æŒ


FastAPIé›†æˆ - ä¸FastAPI/Starletteæ¡†æ¶æ— ç¼é›†æˆ


sse_starlette åº“çš„ä½œç”¨
SSE æ”¯æŒï¼šä¸ºFastAPI æä¾›æ ‡å‡†åŒ–çš„ SSE å®ç°ï¼ŒåŸºäº HTML5 EventSource API
å®æ—¶æ•°æ®æ¨é€ï¼šæ”¯æŒæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯çš„å•å‘æ•°æ®æµï¼Œé€‚åˆå®æ—¶æ›´æ–°ã€‚
æ¶ˆæ¯æ ¼å¼åŒ–ï¼š è‡ªåŠ¨å°†Pythonå¯¹è±¡è½¬æ¢ä¸ºSSEæ ‡å‡†æ ¼å¼
é«˜æ€§èƒ½ï¼šåˆ©ç”¨ asyncio å’Œ anyio çš„å¼‚æ­¥ä»»åŠ¡ç»„ï¼ˆTaskGroupsï¼‰ï¼Œç¡®ä¿é«˜æ•ˆå¹¶å‘
æ˜“äºé›†æˆï¼šä¸ FastAPI æ— ç¼å…¼å®¹ï¼Œæ”¯æŒè‡ªå®šä¹‰äº‹ä»¶å’Œå¤´éƒ¨
è¿æ¥ç®¡ç†ï¼š å¤„ç†HTTPè¿æ¥ã€å¿ƒè·³ã€é”™è¯¯æ¢å¤ç­‰



å•æ™ºèƒ½ä½“åœ¨AIåº”ç”¨ä¸­çš„æµå¼æ•°æ®ä¼ è¾“çš„å®Œæ•´é“¾è·¯


## ğŸ”„ æµå¼æ•°æ®ä¼ è¾“çš„å®Œæ•´é“¾è·¯

### 1. æ•°æ®æµå‘åˆ†æ

"""
æ•°æ®æµå‘é“¾è·¯ï¼š

LLM API (OpenAI/Claude/DeepSeek)
    â†“ åŸå§‹æµå¼å“åº”
code_interpreter_agent() 
    â†“ å¤„ç†åçš„ CodeOutput/ActionOutput å¯¹è±¡
_stream() å¼‚æ­¥ç”Ÿæˆå™¨
    â†“ yield ServerSentEvent (ä½ é—®çš„è¿™ä¸€æ­¥ï¼)
EventSourceResponse (sse-starlette)
    â†“ HTTP SSE æµå¼å“åº”
Javaåç«¯ (æ¥æ”¶æ–¹)
    â†“ å†æ¬¡è½¬å‘
å‰ç«¯ç”¨æˆ·ç•Œé¢
"""
### 2. ServerSentEvent çš„æ•°æ®æ ¼å¼
```Python
             yield ServerSentEvent(
                    data=json.dumps(
                        {
                            "requestId": body.request_id,
                            "code": chunk.code,
                            "fileInfo": chunk.file_list,
                            "isFinal": False,
                        },
                        ensure_ascii=False,
                    )
                )

```


2.2 æµå¼å“åº”å¤„ç†æœºåˆ¶
```Python
  async with AsyncTimer(key=f"exec ask_llm"):
        if stream:
            async for chunk in response:
                if only_content:
                    if chunk.choices and chunk.choices[0] and chunk.choices[0].delta and chunk.choices[0].delta.content:
                        yield chunk.choices[0].delta.content
                else:
                    yield chunk
        else:
            yield response.choices[0].message.content if only_content else response
```
å…³é”®ç‰¹æ€§ï¼š
å¼‚æ­¥è¿­ä»£å™¨æ¨¡å¼ - async for chunk in response
å¢é‡å†…å®¹æå– - ä»delta.contentè·å–æµå¼ç‰‡æ®µ
çµæ´»è¾“å‡ºæ¨¡å¼ - æ”¯æŒçº¯å†…å®¹æˆ–å®Œæ•´å“åº”å¯¹è±¡



 ä¸‰ç§æµå¼æ¨¡å¼ï¼šGeneral(å®æ—¶)ã€Token(ç´¯ç§¯)ã€Time(å®šæ—¶)ï¼Œé€‚åº”ä¸åŒåº”ç”¨åœºæ™¯

### 1.Generalæ¨¡å¼ï¼ˆå®æ—¶æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š

- æ¯ä¸ªchunkç«‹å³æ¨é€åˆ°å‰ç«¯
- æœ€å¿«çš„ç”¨æˆ·åé¦ˆä½“éªŒ
- é€‚ç”¨äºä»£ç ç”Ÿæˆã€å®æ—¶å¯¹è¯åœºæ™¯

åº”ç”¨åœºæ™¯ï¼šÂ ä»£ç è§£é‡Šå™¨å·¥å…·ï¼Œç”¨æˆ·éœ€è¦å®æ—¶çœ‹åˆ°ä»£ç ç”Ÿæˆè¿‡ç¨‹
```Python
        acc_content += chunk
        acc_token += 1
        if body.stream_mode.mode == "general":
            yield ServerSentEvent(
                data=json.dumps(
                    {"requestId": body.request_id, "data": chunk, "isFinal": False},
                    ensure_ascii=False,
                )
            )
```


### 3.2 Tokenæ¨¡å¼ï¼ˆæ‰¹é‡ç´¯ç§¯æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š
- ç´¯ç§¯Nä¸ªtokenåæ‰¹é‡æ¨é€
- å¹³è¡¡å“åº”é€Ÿåº¦å’Œç½‘ç»œå¼€é”€
- é€‚ç”¨äºé•¿æ–‡æœ¬ç”Ÿæˆåœºæ™¯
åº”ç”¨åœºæ™¯ï¼šÂ æ·±åº¦æœç´¢å·¥å…·ï¼Œéœ€è¦å¤„ç†å¤§é‡æœç´¢ç»“æœ
```Python
                elif body.stream_mode.mode == "token":
                    if acc_token >= body.stream_mode.token:
                        yield ServerSentEvent(
                            data=json.dumps(
                                {
                                    "requestId": body.request_id,
                                    "data": acc_content,
                                    "isFinal": False,
                                },
                                ensure_ascii=False,
                            )
                        )
                        acc_token = 0
                        acc_content = ""
```
### 3.3 Timeæ¨¡å¼ï¼ˆå®šæ—¶æ‰¹é‡æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š
æŒ‰å›ºå®šæ—¶é—´é—´éš”æ¨é€
ç¨³å®šçš„æ¨é€èŠ‚å¥
é€‚ç”¨äºæŠ¥å‘Šç”Ÿæˆåœºæ™¯
åº”ç”¨åœºæ™¯ï¼š HTML/PPTæŠ¥å‘Šç”Ÿæˆï¼Œé¿å…é¢‘ç¹æ¨é€å½±å“æ¸²æŸ“æ€§èƒ½

```Python
                elif body.stream_mode.mode == "time":
                    if time.time() - acc_time > body.stream_mode.time:
                        yield ServerSentEvent(
                            data=json.dumps(
                                {
                                    "requestId": body.request_id,
                                    "data": acc_content,
                                    "isFinal": False,
                                },
                                ensure_ascii=False,
                            )
                        )
                        acc_time = time.time()
                        acc_content = ""
```






### å®é™…åº”ç”¨åœºæ™¯

- ä»£ç è§£é‡Šå™¨ï¼šå®æ—¶ç”Ÿæˆå’Œæ‰§è¡ŒPythonä»£ç ï¼Œæµå¼æ˜¾ç¤ºè¿‡ç¨‹

- æ·±åº¦æœç´¢ï¼šæ‰¹é‡å¤„ç†æœç´¢ç»“æœï¼ŒTokenæ¨¡å¼ä¼˜åŒ–ç½‘ç»œå¼€é”€

- æŠ¥å‘Šç”Ÿæˆï¼šå®šæ—¶æ¨é€HTML/PPTå†…å®¹ï¼Œé¿å…é¢‘ç¹UIæ›´æ–°


## Agentæ‰§è¡ŒçŠ¶æ€çš„æµå¼åé¦ˆ

### Agentç”Ÿå‘½å‘¨æœŸä¸çŠ¶æ€æµ

AI Agentçš„æ‰§è¡Œè¿‡ç¨‹é€šå¸¸åŒ…å«å¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦å‘ç”¨æˆ·æä¾›å®æ—¶åé¦ˆï¼š

```java
public enum AgentState {
    INITIALIZING("åˆå§‹åŒ–ä¸­", "æ­£åœ¨å‡†å¤‡æ‰§è¡Œç¯å¢ƒ..."),
    PLANNING("åˆ¶å®šè®¡åˆ’", "æ­£åœ¨åˆ†æä»»åŠ¡å¹¶åˆ¶å®šæ‰§è¡Œè®¡åˆ’..."),
    TOOL_CALLING("è°ƒç”¨å·¥å…·", "æ­£åœ¨ä½¿ç”¨å·¥å…·æ‰§è¡Œå…·ä½“ä»»åŠ¡..."),
    THINKING("æ€è€ƒä¸­", "æ­£åœ¨åˆ†æä¸­é—´ç»“æœ..."),
    SUMMARIZING("æ€»ç»“ä¸­", "æ­£åœ¨æ•´ç†å’Œæ€»ç»“æ‰§è¡Œç»“æœ..."),
    COMPLETED("å·²å®Œæˆ", "ä»»åŠ¡æ‰§è¡Œå®Œæˆ"),
    ERROR("æ‰§è¡Œé”™è¯¯", "æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°é”™è¯¯");

    private final String displayName;
    private final String description;

    AgentState(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }
}

@Component
public class AgentStatusStreamer {
    
    public void streamAgentStatus(Printer printer, AgentState state, String detail) {
        AgentStatusMessage message = AgentStatusMessage.builder()
            .state(state.name())
            .displayName(state.getDisplayName())
            .description(state.getDescription())
            .detail(detail)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_status", message);
    }

    public void streamThinking(Printer printer, String thought) {
        ThinkingMessage message = ThinkingMessage.builder()
            .content(thought)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_thinking", message);
    }

    public void streamPlanUpdate(Printer printer, List<Plan> plans, int currentStep) {
        PlanUpdateMessage message = PlanUpdateMessage.builder()
            .plans(plans)
            .currentStep(currentStep)
            .progress(calculateProgress(plans, currentStep))
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("plan_update", message);
    }

    private double calculateProgress(List<Plan> plans, int currentStep) {
        if (plans == null || plans.isEmpty()) {
            return 0.0;
        }
        return Math.min(100.0, (double) currentStep / plans.size() * 100);
    }
}
```

### åˆ†å±‚çŠ¶æ€åé¦ˆæœºåˆ¶

```java
public abstract class BaseAgent {
    protected Printer printer;
    protected AgentStatusStreamer statusStreamer;
    
    protected void executeWithStatusFeedback(String operation, Runnable task) {
        try {
            // å¼€å§‹æ‰§è¡Œåé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.TOOL_CALLING, "å¼€å§‹æ‰§è¡Œ: " + operation);
            
            // æ‰§è¡Œå®é™…ä»»åŠ¡
            task.run();
            
            // å®Œæˆåé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.COMPLETED, "å®Œæˆ: " + operation);
                
        } catch (Exception e) {
            // é”™è¯¯åé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.ERROR, "æ‰§è¡Œå¤±è´¥: " + operation + " - " + e.getMessage());
            throw e;
        }
    }

    protected <T> T executeWithProgressFeedback(String operation, 
                                               Supplier<T> task, 
                                               ProgressCallback callback) {
        statusStreamer.streamAgentStatus(printer, AgentState.TOOL_CALLING, operation);
        
        return task.get(); // å®é™…æ‰§è¡Œä¸­ä¼šç»“åˆcallbackæä¾›è¿›åº¦æ›´æ–°
    }
}

@Component
public class PlanningAgent extends BaseAgent {
    
    @Override
    public void handle(AgentContext context, AgentRequest request) {
        printer = context.getPrinter();
        statusStreamer = new AgentStatusStreamer();
        
        try {
            // é˜¶æ®µ1ï¼šåˆå§‹åŒ–
            statusStreamer.streamAgentStatus(printer, AgentState.INITIALIZING, 
                "å‡†å¤‡åˆ†æä»»åŠ¡: " + request.getQuery());
            
            // é˜¶æ®µ2ï¼šåˆ¶å®šè®¡åˆ’
            statusStreamer.streamAgentStatus(printer, AgentState.PLANNING, 
                "æ­£åœ¨åˆ¶å®šæ‰§è¡Œè®¡åˆ’...");
            
            List<Plan> plans = executeWithProgressFeedback("ç”Ÿæˆæ‰§è¡Œè®¡åˆ’", 
                () -> generatePlan(request), 
                (progress, detail) -> {
                    // è¿›åº¦å›è°ƒ
                    printer.send("plan_progress", Map.of(
                        "progress", progress,
                        "detail", detail
                    ));
                });
            
            // æµå¼å‘é€å®Œæ•´è®¡åˆ’
            statusStreamer.streamPlanUpdate(printer, plans, 0);
            
            // é˜¶æ®µ3ï¼šæ‰§è¡Œè®¡åˆ’
            executePlansWithStreaming(context, plans);
            
        } catch (Exception e) {
            statusStreamer.streamAgentStatus(printer, AgentState.ERROR, e.getMessage());
            throw e;
        }
    }

    private void executePlansWithStreaming(AgentContext context, List<Plan> plans) {
        for (int i = 0; i < plans.size(); i++) {
            Plan plan = plans.get(i);
            
            // æ›´æ–°å½“å‰æ‰§è¡Œè®¡åˆ’
            statusStreamer.streamPlanUpdate(printer, plans, i + 1);
            
            // æ‰§è¡Œå•ä¸ªè®¡åˆ’æ­¥éª¤
            executeWithStatusFeedback("æ‰§è¡Œæ­¥éª¤: " + plan.getAction(), () -> {
                executePlan(context, plan);
                plan.setStatus(PlanStatus.COMPLETED);
            });
            
            // å‘é€æ­¥éª¤å®Œæˆçš„æµå¼åé¦ˆ
            printer.send("plan_step_completed", Map.of(
                "stepIndex", i,
                "plan", plan,
                "progress", (i + 1.0) / plans.size() * 100
            ));
        }
    }
}
```

## å·¥å…·è°ƒç”¨ç»“æœçš„å¢é‡ä¼ è¾“

### å·¥å…·æ‰§è¡Œçš„æµå¼åŒ…è£…

```java
public abstract class BaseTool {
    protected AgentContext agentContext;

    /**
     * æµå¼æ‰§è¡Œå·¥å…·ï¼Œæ”¯æŒå¢é‡ç»“æœä¼ è¾“
     */
    protected <T> T executeStreamingly(String toolName, 
                                     Supplier<T> execution, 
                                     Function<T, Stream<Object>> resultStreamer) {
        Printer printer = agentContext.getPrinter();
        String requestId = agentContext.getRequestId();
        
        // å¼€å§‹æ‰§è¡Œé€šçŸ¥
        printer.send("tool_start", Map.of(
            "toolName", toolName,
            "requestId", requestId,
            "timestamp", System.currentTimeMillis()
        ));
        
        try {
            T result = execution.get();
            
            // æµå¼ä¼ è¾“ç»“æœ
            if (resultStreamer != null) {
                resultStreamer.apply(result).forEach(chunk -> {
                    printer.send("tool_stream", Map.of(
                        "toolName", toolName,
                        "chunk", chunk,
                        "requestId", requestId
                    ));
                });
            }
            
            // å®Œæˆé€šçŸ¥
            printer.send("tool_complete", Map.of(
                "toolName", toolName,
                "result", result,
                "requestId", requestId
            ));
            
            return result;
            
        } catch (Exception e) {
            // é”™è¯¯é€šçŸ¥
            printer.send("tool_error", Map.of(
                "toolName", toolName,
                "error", e.getMessage(),
                "requestId", requestId
            ));
            throw e;
        }
    }
}

@Component
public class DeepSearchTool extends BaseTool {
    
    @Override
    public String call(String query) {
        return executeStreamingly("æ·±åº¦æœç´¢", 
            () -> performDeepSearch(query),
            result -> streamSearchResults(result));
    }

    private DeepSearchResult performDeepSearch(String query) {
        Printer printer = agentContext.getPrinter();
        
        // ç¬¬ä¸€æ­¥ï¼šæŸ¥è¯¢ç†è§£
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "description", "ç†è§£æœç´¢æ„å›¾",
            "status", "in_progress"
        ));
        
        QueryIntent intent = analyzeQuery(query);
        
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "result", intent,
            "status", "completed"
        ));
        
        // ç¬¬äºŒæ­¥ï¼šå¤šæºæœç´¢
        printer.send("search_step", Map.of(
            "step", "multi_source_search",
            "description", "æ‰§è¡Œå¤šæºæœç´¢",
            "status", "in_progress"
        ));
        
        List<SearchSource> sources = getSearchSources();
        List<SearchResult> allResults = new ArrayList<>();
        
        for (int i = 0; i < sources.size(); i++) {
            SearchSource source = sources.get(i);
            
            printer.send("search_progress", Map.of(
                "source", source.getName(),
                "progress", (i + 1.0) / sources.size() * 100,
                "status", "searching"
            ));
            
            try {
                List<SearchResult> sourceResults = searchFromSource(source, query);
                allResults.addAll(sourceResults);
                
                // æµå¼å‘é€ä¸­é—´ç»“æœ
                printer.send("search_intermediate", Map.of(
                    "source", source.getName(),
                    "results", sourceResults,
                    "count", sourceResults.size()
                ));
                
            } catch (Exception e) {
                printer.send("search_error", Map.of(
                    "source", source.getName(),
                    "error", e.getMessage()
                ));
            }
        }
        
        // ç¬¬ä¸‰æ­¥ï¼šç»“æœæ•´åˆ
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "description", "æ•´åˆæœç´¢ç»“æœ",
            "status", "in_progress",
            "totalResults", allResults.size()
        ));
        
        DeepSearchResult finalResult = integrateResults(allResults, intent);
        
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "status", "completed",
            "finalResultCount", finalResult.getItems().size()
        ));
        
        return finalResult;
    }

    private Stream<Object> streamSearchResults(DeepSearchResult result) {
        return result.getItems().stream().map(item -> Map.of(
            "type", "search_item",
            "title", item.getTitle(),
            "content", item.getContent(),
            "source", item.getSource(),
            "relevance", item.getRelevance()
        ));
    }
}
```

### ä»£ç è§£é‡Šå™¨çš„æµå¼è¾“å‡º

```java
@Component
public class CodeInterpreterTool extends BaseTool {
    
    @Override
    public CodeInterpreterResponse call(CodeInterpreterRequest request) {
        return executeStreamingly("ä»£ç è§£é‡Šå™¨",
            () -> executeCode(request),
            result -> streamCodeExecution(result));
    }

    private CodeInterpreterResult executeCode(CodeInterpreterRequest request) {
        Printer printer = agentContext.getPrinter();
        String code = request.getCode();
        String language = request.getLanguage();
        
        // ä»£ç åˆ†æé˜¶æ®µ
        printer.send("code_analysis", Map.of(
            "phase", "analyzing",
            "language", language,
            "codeLength", code.length()
        ));
        
        CodeAnalysis analysis = analyzeCode(code, language);
        
        printer.send("code_analysis", Map.of(
            "phase", "completed",
            "analysis", analysis,
            "estimatedExecutionTime", analysis.getEstimatedTime()
        ));
        
        // æ‰§è¡Œç¯å¢ƒå‡†å¤‡
        printer.send("execution_env", Map.of(
            "phase", "preparing",
            "environment", language
        ));
        
        ExecutionEnvironment env = prepareEnvironment(language);
        
        printer.send("execution_env", Map.of(
            "phase", "ready",
            "environmentId", env.getId()
        ));
        
        // ä»£ç æ‰§è¡Œ - å®æ—¶è¾“å‡º
        printer.send("code_execution", Map.of(
            "phase", "running",
            "startTime", System.currentTimeMillis()
        ));
        
        CodeExecutionResult result = executeCodeWithStreaming(env, code, printer);
        
        return CodeInterpreterResult.builder()
            .analysis(analysis)
            .executionResult(result)
            .environment(env)
            .build();
    }

    private CodeExecutionResult executeCodeWithStreaming(ExecutionEnvironment env, 
                                                        String code, 
                                                        Printer printer) {
        StringBuilder stdout = new StringBuilder();
        StringBuilder stderr = new StringBuilder();
        
        // åˆ›å»ºæµå¼è¾“å‡ºå¤„ç†å™¨
        ProcessBuilder pb = new ProcessBuilder(env.getCommand(), code);
        pb.redirectErrorStream(false);
        
        try {
            Process process = pb.start();
            
            // å¼‚æ­¥è¯»å–æ ‡å‡†è¾“å‡º
            Thread stdoutReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stdout.append(line).append("\n");
                        
                        // å®æ—¶æµå¼è¾“å‡º
                        printer.send("code_stdout", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis()
                        ));
                    }
                } catch (IOException e) {
                    log.error("è¯»å–æ ‡å‡†è¾“å‡ºå¤±è´¥", e);
                }
            });
            
            // å¼‚æ­¥è¯»å–é”™è¯¯è¾“å‡º
            Thread stderrReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getErrorStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stderr.append(line).append("\n");
                        
                        // å®æ—¶æµå¼é”™è¯¯è¾“å‡º
                        printer.send("code_stderr", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis(),
                            "level", "error"
                        ));
                    }
                } catch (IOException e) {
                    log.error("è¯»å–é”™è¯¯è¾“å‡ºå¤±è´¥", e);
                }
            });
            
            stdoutReader.start();
            stderrReader.start();
            
            // ç­‰å¾…æ‰§è¡Œå®Œæˆ
            int exitCode = process.waitFor();
            
            stdoutReader.join();
            stderrReader.join();
            
            // å‘é€æ‰§è¡Œå®Œæˆé€šçŸ¥
            printer.send("code_execution", Map.of(
                "phase", "completed",
                "exitCode", exitCode,
                "endTime", System.currentTimeMillis()
            ));
            
            return CodeExecutionResult.builder()
                .exitCode(exitCode)
                .stdout(stdout.toString())
                .stderr(stderr.toString())
                .executionTime(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            printer.send("code_execution", Map.of(
                "phase", "error",
                "error", e.getMessage()
            ));
            throw new RuntimeException("ä»£ç æ‰§è¡Œå¤±è´¥", e);
        }
    }

    private Stream<Object> streamCodeExecution(CodeInterpreterResult result) {
        List<Object> streamItems = new ArrayList<>();
        
        // åˆ†æç»“æœ
        streamItems.add(Map.of(
            "type", "analysis",
            "data", result.getAnalysis()
        ));
        
        // æ‰§è¡Œç»“æœ
        streamItems.add(Map.of(
            "type", "execution_result",
            "data", result.getExecutionResult()
        ));
        
        // å¦‚æœæœ‰ç”Ÿæˆçš„æ–‡ä»¶ï¼Œé€ä¸ªæµå¼ä¼ è¾“
        if (result.getGeneratedFiles() != null) {
            result.getGeneratedFiles().forEach(file -> {
                streamItems.add(Map.of(
                    "type", "generated_file",
                    "data", file
                ));
            });
        }
        
        return streamItems.stream();
    }
}
```

## å¤šAgentåä½œçš„æµå¼æ¶ˆæ¯ä¼ é€’

### Agenté—´é€šä¿¡æ¶æ„

```java
@Component
public class AgentCommunicationBus {
    private final Map<String, Agent> activeAgents = new ConcurrentHashMap<>();
    private final Map<String, List<AgentMessageListener>> listeners = new ConcurrentHashMap<>();
    private final ExecutorService messageDispatcher = Executors.newFixedThreadPool(5);

    /**
     * æ³¨å†ŒAgentåˆ°é€šä¿¡æ€»çº¿
     */
    public void registerAgent(String agentId, Agent agent) {
        activeAgents.put(agentId, agent);
        
        // å‘é€Agentæ³¨å†Œé€šçŸ¥
        broadcastMessage(AgentMessage.builder()
            .fromAgent("system")
            .toAgent("all")
            .messageType("agent_registered")
            .data(Map.of("agentId", agentId, "agentType", agent.getType()))
            .build());
    }

    /**
     * å‘é€Agenté—´æ¶ˆæ¯
     */
    public void sendMessage(AgentMessage message) {
        messageDispatcher.submit(() -> {
            try {
                // è®°å½•æ¶ˆæ¯æ—¥å¿—
                logMessage(message);
                
                // æµå¼é€šçŸ¥ç”¨æˆ·
                notifyUserOfAgentCommunication(message);
                
                if ("all".equals(message.getToAgent())) {
                    // å¹¿æ’­æ¶ˆæ¯
                    activeAgents.forEach((agentId, agent) -> {
                        if (!agentId.equals(message.getFromAgent())) {
                            deliverMessage(agent, message);
                        }
                    });
                } else {
                    // ç‚¹å¯¹ç‚¹æ¶ˆæ¯
                    Agent targetAgent = activeAgents.get(message.getToAgent());
                    if (targetAgent != null) {
                        deliverMessage(targetAgent, message);
                    }
                }
                
                // é€šçŸ¥ç›‘å¬å™¨
                notifyListeners(message);
                
            } catch (Exception e) {
                log.error("æ¶ˆæ¯å‘é€å¤±è´¥", e);
            }
        });
    }

    private void notifyUserOfAgentCommunication(AgentMessage message) {
        // è·å–ç›¸å…³çš„Printerï¼ˆé€šè¿‡è¯·æ±‚IDå…³è”ï¼‰
        Printer printer = getPrinterForMessage(message);
        if (printer != null) {
            printer.send("agent_communication", Map.of(
                "fromAgent", message.getFromAgent(),
                "toAgent", message.getToAgent(),
                "messageType", message.getMessageType(),
                "summary", summarizeMessage(message),
                "timestamp", message.getTimestamp()
            ));
        }
    }

    private void deliverMessage(Agent agent, AgentMessage message) {
        try {
            agent.receiveMessage(message);
        } catch (Exception e) {
            log.error("æ¶ˆæ¯æŠ•é€’å¤±è´¥: {} -> {}", message.getFromAgent(), 
                     agent.getId(), e);
        }
    }

    /**
     * å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰Agent
     */
    public void broadcastMessage(AgentMessage message) {
        message.setToAgent("all");
        sendMessage(message);
    }

    /**
     * æ·»åŠ æ¶ˆæ¯ç›‘å¬å™¨
     */
    public void addMessageListener(String messageType, AgentMessageListener listener) {
        listeners.computeIfAbsent(messageType, k -> new ArrayList<>()).add(listener);
    }

    private void notifyListeners(AgentMessage message) {
        List<AgentMessageListener> typeListeners = listeners.get(message.getMessageType());
        if (typeListeners != null) {
            typeListeners.forEach(listener -> {
                try {
                    listener.onMessage(message);
                } catch (Exception e) {
                    log.error("æ¶ˆæ¯ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥", e);
                }
            });
        }
    }
}

@Data
@Builder
public class AgentMessage {
    private String messageId;
    private String fromAgent;
    private String toAgent;
    private String messageType;
    private Object data;
    private long timestamp;
    private String requestId; // å…³è”ç”¨æˆ·è¯·æ±‚
}
```

### åä½œæµç¨‹çš„å¯è§†åŒ–æµå¼ä¼ è¾“

```java
@Component
public class CollaborationVisualizer {
    
    public void visualizeCollaboration(String requestId, List<Agent> agents, Printer printer) {
        // åˆå§‹åŒ–åä½œå›¾
        CollaborationGraph graph = new CollaborationGraph();
        agents.forEach(agent -> graph.addNode(agent.getId(), agent.getType()));
        
        printer.send("collaboration_init", Map.of(
            "graph", graph,
            "agents", agents.stream().map(this::serializeAgent).collect(Collectors.toList())
        ));
        
        // ç›‘å¬Agenté—´é€šä¿¡
        AgentCommunicationBus bus = getAgentCommunicationBus();
        bus.addMessageListener("all", message -> {
            if (requestId.equals(message.getRequestId())) {
                // æ›´æ–°åä½œå›¾
                graph.addEdge(message.getFromAgent(), message.getToAgent(), message.getMessageType());
                
                // æµå¼å‘é€åä½œæ›´æ–°
                printer.send("collaboration_update", Map.of(
                    "edge", Map.of(
                        "from", message.getFromAgent(),
                        "to", message.getToAgent(),
                        "type", message.getMessageType(),
                        "timestamp", message.getTimestamp()
                    ),
                    "graph", graph.getSnapshot()
                ));
            }
        });
    }

    private Map<String, Object> serializeAgent(Agent agent) {
        return Map.of(
            "id", agent.getId(),
            "type", agent.getType(),
            "status", agent.getStatus(),
            "capabilities", agent.getCapabilities()
        );
    }
}

@Component 
public class MultiAgentOrchestrator {
    private final AgentCommunicationBus communicationBus;
    private final CollaborationVisualizer visualizer;

    public void executeCollaborativeTask(AgentContext context, CollaborativeTask task) {
        String requestId = context.getRequestId();
        Printer printer = context.getPrinter();
        
        // åˆå§‹åŒ–åä½œç¯å¢ƒ
        printer.send("collaboration_start", Map.of(
            "taskId", task.getId(),
            "description", task.getDescription(),
            "requiredAgents", task.getRequiredAgentTypes()
        ));
        
        // åˆ›å»ºå¹¶æ³¨å†Œæ‰€éœ€çš„Agent
        List<Agent> agents = createRequiredAgents(task, context);
        agents.forEach(agent -> communicationBus.registerAgent(agent.getId(), agent));
        
        // å¯åŠ¨åä½œå¯è§†åŒ–
        visualizer.visualizeCollaboration(requestId, agents, printer);
        
        // åˆ†é…ä»»åŠ¡ç»™å„ä¸ªAgent
        distributeTasksWithStreaming(task, agents, printer);
        
        // ç›‘æ§åä½œè¿›åº¦
        monitorCollaborationProgress(requestId, agents, printer);
    }

    private void distributeTasksWithStreaming(CollaborativeTask task, 
                                           List<Agent> agents, 
                                           Printer printer) {
        List<SubTask> subTasks = task.decomposeToSubTasks();
        
        for (int i = 0; i < subTasks.size(); i++) {
            SubTask subTask = subTasks.get(i);
            Agent assignedAgent = findBestAgent(subTask, agents);
            
            // æµå¼å‘é€ä»»åŠ¡åˆ†é…ä¿¡æ¯
            printer.send("task_assignment", Map.of(
                "subTaskId", subTask.getId(),
                "description", subTask.getDescription(),
                "assignedAgent", assignedAgent.getId(),
                "priority", subTask.getPriority(),
                "dependencies", subTask.getDependencies()
            ));
            
            // å‘é€ä»»åŠ¡ç»™Agent
            AgentMessage taskMessage = AgentMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .fromAgent("orchestrator")
                .toAgent(assignedAgent.getId())
                .messageType("task_assignment")
                .data(subTask)
                .timestamp(System.currentTimeMillis())
                .requestId(task.getRequestId())
                .build();
                
            communicationBus.sendMessage(taskMessage);
        }
    }

    private void monitorCollaborationProgress(String requestId, 
                                           List<Agent> agents, 
                                           Printer printer) {
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        
        monitor.scheduleAtFixedRate(() -> {
            // æ”¶é›†å„AgentçŠ¶æ€
            Map<String, AgentStatus> agentStatuses = agents.stream()
                .collect(Collectors.toMap(Agent::getId, Agent::getStatus));
            
            // è®¡ç®—æ•´ä½“è¿›åº¦
            double overallProgress = calculateOverallProgress(agentStatuses);
            
            // æµå¼å‘é€è¿›åº¦æ›´æ–°
            printer.send("collaboration_progress", Map.of(
                "overallProgress", overallProgress,
                "agentStatuses", agentStatuses,
                "timestamp", System.currentTimeMillis()
            ));
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (isCollaborationComplete(agentStatuses)) {
                printer.send("collaboration_complete", Map.of(
                    "completionTime", System.currentTimeMillis(),
                    "finalResults", collectFinalResults(agents)
                ));
                monitor.shutdown();
            }
            
        }, 5, 5, TimeUnit.SECONDS); // æ¯5ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦
    }
}
```

## æµå¼Tokenè®¡æ•°ä¸é™æµæ§åˆ¶

### å®æ—¶Tokenæ¶ˆè€—ç›‘æ§

```java
@Component
public class TokenMonitor {
    private final Map<String, TokenUsageTracker> sessionTrackers = new ConcurrentHashMap<>();
    private final TokenLimitConfig limitConfig;

    public TokenUsageTracker getOrCreateTracker(String requestId) {
        return sessionTrackers.computeIfAbsent(requestId, 
            k -> new TokenUsageTracker(k, limitConfig));
    }

    @EventListener
    public void handleTokenUsage(TokenUsageEvent event) {
        TokenUsageTracker tracker = getOrCreateTracker(event.getRequestId());
        tracker.addUsage(event.getTokens(), event.getModel());
        
        // æµå¼å‘é€Tokenä½¿ç”¨æƒ…å†µ
        if (event.getPrinter() != null) {
            event.getPrinter().send("token_usage", Map.of(
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit(),
                "percentage", tracker.getUsagePercentage(),
                "model", event.getModel(),
                "timestamp", System.currentTimeMillis()
            ));
        }
        
        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘é™åˆ¶
        if (tracker.isNearLimit(0.9)) { // 90%
            event.getPrinter().send("token_warning", Map.of(
                "message", "Tokenä½¿ç”¨é‡å·²è¾¾åˆ°90%",
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit()
            ));
        }
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if (tracker.isOverLimit()) {
            throw new TokenLimitExceeded(event.getRequestId(), 
                tracker.getCurrentUsage(), tracker.getLimit());
        }
    }

    public void cleanupTracker(String requestId) {
        sessionTrackers.remove(requestId);
    }
}

public class TokenUsageTracker {
    private final String requestId;
    private final TokenLimitConfig limitConfig;
    private final Map<String, AtomicLong> modelUsage = new ConcurrentHashMap<>();
    private final AtomicLong totalUsage = new AtomicLong(0);

    public void addUsage(long tokens, String model) {
        modelUsage.computeIfAbsent(model, k -> new AtomicLong(0)).addAndGet(tokens);
        totalUsage.addAndGet(tokens);
    }

    public boolean isNearLimit(double threshold) {
        return getUsagePercentage() >= threshold * 100;
    }

    public boolean isOverLimit() {
        return totalUsage.get() > limitConfig.getMaxTokensPerSession();
    }

    public double getUsagePercentage() {
        return (double) totalUsage.get() / limitConfig.getMaxTokensPerSession() * 100;
    }

    public long getCurrentUsage() {
        return totalUsage.get();
    }

    public long getLimit() {
        return limitConfig.getMaxTokensPerSession();
    }

    public Map<String, Long> getModelUsageBreakdown() {
        return modelUsage.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> entry.getValue().get()
            ));
    }
}
```

### åŠ¨æ€é™æµç­–ç•¥

```java
@Component
public class AdaptiveThrottleController {
    private final TokenMonitor tokenMonitor;
    private final Map<String, ThrottleState> sessionThrottles = new ConcurrentHashMap<>();

    public void checkAndApplyThrottle(String requestId, Printer printer) {
        TokenUsageTracker tracker = tokenMonitor.getOrCreateTracker(requestId);
        ThrottleState throttle = sessionThrottles.computeIfAbsent(requestId, 
            k -> new ThrottleState());

        double usagePercentage = tracker.getUsagePercentage();
        
        if (usagePercentage > 95) {
            // ä¸¥é‡é™æµï¼šæš‚åœæ‰€æœ‰éå…³é”®æ“ä½œ
            throttle.setLevel(ThrottleLevel.SEVERE);
            printer.send("throttle_applied", Map.of(
                "level", "severe",
                "message", "Tokenä½¿ç”¨é‡è¿‡é«˜ï¼Œæš‚åœéå…³é”®æ“ä½œ",
                "estimatedDelay", "30-60ç§’"
            ));
            
        } else if (usagePercentage > 80) {
            // ä¸­ç­‰é™æµï¼šå»¶é•¿æ“ä½œé—´éš”
            throttle.setLevel(ThrottleLevel.MODERATE);
            printer.send("throttle_applied", Map.of(
                "level", "moderate", 
                "message", "é€‚åº¦é™ä½å¤„ç†é€Ÿåº¦ä»¥æ§åˆ¶Tokenæ¶ˆè€—",
                "slowdownFactor", 2.0
            ));
            
        } else if (usagePercentage > 60) {
            // è½»å¾®é™æµï¼šä¼˜åŒ–è¯·æ±‚
            throttle.setLevel(ThrottleLevel.LIGHT);
            printer.send("throttle_applied", Map.of(
                "level", "light",
                "message", "å¼€å¯Tokenä¼˜åŒ–æ¨¡å¼",
                "optimization", "enabled"
            ));
        }

        // åº”ç”¨é™æµå»¶è¿Ÿ
        if (throttle.getLevel() != ThrottleLevel.NONE) {
            long delayMs = calculateThrottleDelay(throttle.getLevel(), usagePercentage);
            if (delayMs > 0) {
                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private long calculateThrottleDelay(ThrottleLevel level, double usagePercentage) {
        switch (level) {
            case LIGHT:
                return Math.round(500 * (usagePercentage / 100)); // 0-5ç§’
            case MODERATE:
                return Math.round(2000 * (usagePercentage / 100)); // 0-20ç§’  
            case SEVERE:
                return Math.round(10000 * (usagePercentage / 100)); // 0-100ç§’
            default:
                return 0;
        }
    }
}

enum ThrottleLevel {
    NONE, LIGHT, MODERATE, SEVERE
}

@Data
class ThrottleState {
    private ThrottleLevel level = ThrottleLevel.NONE;
    private long lastThrottleTime = 0;
    private int consecutiveThrottles = 0;
}
```

## Agentæ‰§è¡Œè¿›åº¦çš„å¯è§†åŒ–å±•ç¤º

### è¿›åº¦å¯è§†åŒ–ç»„ä»¶

```typescript
interface AgentProgress {
    agentId: string;
    agentType: string;
    currentStep: string;
    totalSteps: number;
    completedSteps: number;
    progress: number;
    status: 'idle' | 'running' | 'completed' | 'error';
    lastUpdate: number;
    estimatedTimeRemaining?: number;
}

interface CollaborationState {
    requestId: string;
    agents: AgentProgress[];
    overallProgress: number;
    activeConnections: Array<{
        from: string;
        to: string;
        type: string;
        timestamp: number;
    }>;
    timeline: Array<{
        timestamp: number;
        event: string;
        agent?: string;
        details: any;
    }>;
}

export const AgentCollaborationDashboard: React.FC<{
  requestId: string;
}> = ({ requestId }) => {
  const [collaborationState, setCollaborationState] = useState<CollaborationState | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const sseClient = new AdvancedSSEClient({
      body: { requestId, agentType: 'collaboration' },
      handleMessage: (message) => {
        handleCollaborationMessage(message);
      },
      handleError: (error) => {
        console.error('åä½œç›‘æ§è¿æ¥é”™è¯¯:', error);
        setIsConnected(false);
      },
      handleClose: () => {
        setIsConnected(false);
      }
    });

    sseClient.connect('/web/api/v1/agent/collaboration/stream');
    setIsConnected(true);

    return () => {
      sseClient.disconnect();
    };
  }, [requestId]);

  const handleCollaborationMessage = (message: any) => {
    switch (message.messageType) {
      case 'collaboration_init':
        setCollaborationState({
          requestId: message.requestId,
          agents: message.agents.map(formatAgentProgress),
          overallProgress: 0,
          activeConnections: [],
          timeline: []
        });
        break;

      case 'collaboration_progress':
        setCollaborationState(prev => prev ? {
          ...prev,
          agents: updateAgentProgress(prev.agents, message.agentStatuses),
          overallProgress: message.overallProgress
        } : null);
        break;

      case 'agent_communication':
        setCollaborationState(prev => prev ? {
          ...prev,
          activeConnections: [
            ...prev.activeConnections.slice(-10), // ä¿ç•™æœ€è¿‘10ä¸ªè¿æ¥
            {
              from: message.fromAgent,
              to: message.toAgent,
              type: message.messageType,
              timestamp: message.timestamp
            }
          ],
          timeline: [
            ...prev.timeline,
            {
              timestamp: message.timestamp,
              event: 'agent_communication',
              agent: message.fromAgent,
              details: {
                to: message.toAgent,
                type: message.messageType,
                summary: message.summary
              }
            }
          ]
        } : null);
        break;

      case 'task_assignment':
        setCollaborationState(prev => prev ? {
          ...prev,
          timeline: [
            ...prev.timeline,
            {
              timestamp: Date.now(),
              event: 'task_assignment',
              agent: message.assignedAgent,
              details: {
                taskId: message.subTaskId,
                description: message.description,
                priority: message.priority
              }
            }
          ]
        } : null);
        break;
    }
  };

  if (!collaborationState) {
    return <div className="loading">åˆå§‹åŒ–åä½œç›‘æ§...</div>;
  }

  return (
    <div className="collaboration-dashboard">
      {/* æ•´ä½“è¿›åº¦ */}
      <div className="overall-progress">
        <h3>æ•´ä½“è¿›åº¦</h3>
        <ProgressRing 
          progress={collaborationState.overallProgress} 
          size={120}
          strokeWidth={8}
        />
        <div className="status-indicator">
          <StatusDot connected={isConnected} />
          <span>{isConnected ? 'å·²è¿æ¥' : 'è¿æ¥æ–­å¼€'}</span>
        </div>
      </div>

      {/* AgentçŠ¶æ€ç½‘æ ¼ */}
      <div className="agents-grid">
        {collaborationState.agents.map(agent => (
          <AgentCard key={agent.agentId} agent={agent} />
        ))}
      </div>

      {/* åä½œå›¾ */}
      <div className="collaboration-graph">
        <h3>Agentåä½œå…³ç³»</h3>
        <CollaborationNetwork 
          agents={collaborationState.agents}
          connections={collaborationState.activeConnections}
        />
      </div>

      {/* æ—¶é—´çº¿ */}
      <div className="timeline">
        <h3>æ‰§è¡Œæ—¶é—´çº¿</h3>
        <Timeline events={collaborationState.timeline} />
      </div>
    </div>
  );
};

const AgentCard: React.FC<{ agent: AgentProgress }> = ({ agent }) => {
  return (
    <div className={`agent-card ${agent.status}`}>
      <div className="agent-header">
        <div className="agent-icon">{getAgentIcon(agent.agentType)}</div>
        <div className="agent-info">
          <h4>{agent.agentId}</h4>
          <span className="agent-type">{agent.agentType}</span>
        </div>
        <StatusBadge status={agent.status} />
      </div>
      
      <div className="agent-progress">
        <div className="progress-bar">
          <div 
            className="progress-fill" 
            style={{ width: `${agent.progress}%` }}
          />
        </div>
        <span className="progress-text">
          {agent.completedSteps}/{agent.totalSteps} æ­¥éª¤
        </span>
      </div>
      
      <div className="current-step">
        <span>å½“å‰: {agent.currentStep}</span>
        {agent.estimatedTimeRemaining && (
          <span className="time-remaining">
            é¢„è®¡å‰©ä½™: {formatDuration(agent.estimatedTimeRemaining)}
          </span>
        )}
      </div>
    </div>
  );
};
```

## å°ç»“

AI-Agentä¸­çš„æµå¼äº¤äº’æ¨¡å¼å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **çŠ¶æ€æµå¼åé¦ˆ**ï¼šAgentæ‰§è¡Œçš„æ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦å®æ—¶åé¦ˆç»™ç”¨æˆ·
2. **å·¥å…·è°ƒç”¨é€æ˜åŒ–**ï¼šå·¥å…·æ‰§è¡Œè¿‡ç¨‹å’Œç»“æœéœ€è¦å¢é‡ä¼ è¾“
3. **å¤šAgentåä½œå¯è§†åŒ–**ï¼šå¤æ‚çš„åä½œå…³ç³»éœ€è¦å®æ—¶å±•ç¤º
4. **Tokenä½¿ç”¨ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å’Œæ§åˆ¶Tokenæ¶ˆè€—
5. **è¿›åº¦å¯è§†åŒ–**ï¼šæä¾›ç›´è§‚çš„æ‰§è¡Œè¿›åº¦å’ŒçŠ¶æ€å±•ç¤º

è¿™äº›æ¨¡å¼ä½¿ç”¨æˆ·èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£AI Agentçš„"æ€è€ƒ"å’Œæ‰§è¡Œè¿‡ç¨‹ï¼Œæä¾›äº†å‰æ‰€æœªæœ‰çš„é€æ˜åº¦å’Œäº¤äº’ä½“éªŒã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨å¦‚ä½•ä¼˜åŒ–æµå¼é€šä¿¡çš„æ€§èƒ½å¹¶å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ã€‚

---

**æœ¬èŠ‚å…³é”®è¦ç‚¹ï¼š**
- Agentç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„æµå¼åé¦ˆæœºåˆ¶
- å·¥å…·è°ƒç”¨ç»“æœçš„å¢é‡ä¼ è¾“ç­–ç•¥
- å¤šAgentåä½œçš„å®æ—¶é€šä¿¡å’Œå¯è§†åŒ–
- æµå¼Tokenè®¡æ•°å’ŒåŠ¨æ€é™æµæ§åˆ¶
- Agentæ‰§è¡Œè¿›åº¦çš„å¯è§†åŒ–å±•ç¤ºæ–¹æ¡ˆ
