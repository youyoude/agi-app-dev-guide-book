# 2.1.5 AI Agentä¸­çš„æµå¼äº¤äº’æ¨¡å¼

**å­¦ä¹ ç›®æ ‡ï¼š** ç†è§£AI Agentåœºæ™¯ä¸‹çš„ç‰¹æ®Šæµå¼äº¤äº’éœ€æ±‚ï¼ŒæŒæ¡æ™ºèƒ½åŒ–çš„æµå¼é€šä¿¡æ¨¡å¼

## å•æ™ºèƒ½ä½“æµå¼é€šä¿¡æœåŠ¡ç«¯å®ç°

åœ¨å­¦ä¹ å®Œæµå¼é€šä¿¡åŸºç¡€åï¼Œæˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªAgentic AIåº”ç”¨ä¸­çš„å•æ™ºèƒ½ä½“æ¡ˆä¾‹ï¼Œå­¦ä¹ å¦‚ä½•æ„å»ºå®Œæ•´çš„å…·æœ‰AI AgentæœåŠ¡èƒ½åŠ›çš„æµå¼é€šä¿¡æœåŠ¡ç«¯ã€‚
æœ¬æ–‡ä»¥Python AI Agentä½œä¸ºä¾‹å­ã€‚

## 1 Pythonç«¯æµå¼é€šä¿¡å®ç°
``` Python
# Please install OpenAI SDK first: `pip3 install openai`
import os
from openai import OpenAI

client = OpenAI(
    api_key=os.environ.get('DEEPSEEK_API_KEY'),
    base_url="https://api.deepseek.com")

response = client.chat.completions.create(
    model="deepseek-chat",
    messages=[
        {"role": "system", "content": "You are a helpful assistant"},
        {"role": "user", "content": "Hello"},
    ],
    stream=True
)

print(response.choices[0].message.content)
```
è¿™æ®µä»£ç å±•ç¤ºäº†ä¸€ä¸ªæœ€ç®€å•çš„LLMé€šä¿¡ç¤ºä¾‹ï¼Œè¿™æ˜¯åˆ©ç”¨OpenAI SDKè°ƒç”¨LLMçš„æœ€å°å®ç°ã€‚è™½ç„¶ä»£ç ä¸­è®¾ç½®äº†`stream=True`å‚æ•°å¼€å¯äº†æµå¼å“åº”ï¼Œä½†è¿™ä¸ªåŸºç¡€Demoä½œä¸ºLLMçš„ç›´æ¥å®¢æˆ·ç«¯ï¼Œå¹¶ä¸å…·å¤‡æµå¼æ¶ˆæ¯è½¬å‘çš„èƒ½åŠ›ã€‚åœ¨å®é™…çš„AIåº”ç”¨å¼€å‘ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸éœ€è¦åŸºäºæ­¤ç±»LLMå®¢æˆ·ç«¯æ„å»ºä¸€ä¸ªæµå¼æ¶ˆæ¯è½¬å‘æœåŠ¡ï¼Œä»¥å®ç°ä»LLMåˆ°å‰ç«¯ã€åç«¯çš„å®Œæ•´æµå¼é€šä¿¡é“¾è·¯ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†é€šè¿‡äº¬ä¸œçš„ä¸€ä¸ªå¼€æºé¡¹ç›®æ¥å­¦ä¹ å¦‚ä½•åœ¨æœåŠ¡ç«¯å®ç°è¿™æ ·çš„æµå¼è½¬å‘æœåŠ¡ã€‚
æœ¬æ–‡ä»¥äº¬ä¸œå¼€æºçš„JDGenieé¡¹ç›®ä¸ºä¾‹ï¼Œæ·±å…¥è§£æå¦‚ä½•åŸºäº**FastAPI + sse_starlette + litellm + SmoLAgents**æ„å»ºä¸€ä¸ªå®Œæ•´çš„å•æ™ºèƒ½ä½“æµå¼é€šä¿¡æœåŠ¡ç«¯ã€‚

## æ ¸å¿ƒæŠ€æœ¯æ ˆåˆ†æ
### 1. FastAPIï¼šç°ä»£åŒ–çš„é«˜æ€§èƒ½ Python Web æ¡†æ¶
FastAPIä½œä¸ºæœåŠ¡ç«¯æ¡†æ¶ï¼Œæ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€æ˜¯å¯¹å¼‚æ­¥ç¼–ç¨‹çš„åŸç”Ÿæ”¯æŒã€‚é€šè¿‡ä½¿ç”¨asyncå’Œawaitï¼ŒFastAPIèƒ½å¤Ÿé«˜æ•ˆå¤„ç† I/O å¯†é›†å‹ä»»åŠ¡ï¼Œå¦‚æ•°æ®åº“æŸ¥è¯¢ã€API è°ƒç”¨å’Œæ–‡ä»¶æ“ä½œã€‚
```python
# server.py - æœåŠ¡å™¨å…¥å£ç‚¹
def create_app() -> FastAPI:
    _app = FastAPI(
        on_startup=[log_setting, print_logo]
    )
    
    register_middleware(_app)
    register_router(_app)
    
    return _app

def register_middleware(app: FastAPI):
    app.add_middleware(UnknownException)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
        allow_credentials=True,
    )
    app.add_middleware(HTTPProcessTimeMiddleware)

app = create_app()

```

### 2. sse_starletteï¼šæä¾›æ ‡å‡†çš„Server-Sent Eventsåè®®å®ç°

sse_starlette æ˜¯ä¸€ä¸ªPythonåº“ï¼Œä¸º Starlette å’Œ FastAPI æ¡†æ¶æä¾›å¯¹ Server-Sent Eventsçš„æ”¯æŒã€‚å®ƒé€šè¿‡ EventSourceResponse ç±»å®ç°SSEåè®®ï¼Œå…è®¸æœåŠ¡å™¨å¼‚æ­¥å‘å®¢æˆ·ç«¯æ¨é€å®æ—¶æ•°æ®ï¼Œé€‚åˆæ„å»ºå®æ—¶ Web åº”ç”¨ï¼Œå¦‚é€šçŸ¥ç³»ç»Ÿã€å®æ—¶ä»ªè¡¨ç›˜æˆ–æµå¼æ•°æ®æ›´æ–°ã€‚sse_starlette è½»é‡ä¸”ä¸ ASGI æ¡†æ¶æ— ç¼é›†æˆï¼Œå¸¸ç”¨äºéœ€è¦é«˜æ•ˆå•å‘é€šä¿¡çš„åœºæ™¯ã€‚
```python
from sse_starlette import ServerSentEvent, EventSourceResponse

# è¿”å›æµå¼å“åº”
return EventSourceResponse(
    _stream(),
    ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
    ping=15,
)
```

sse_starlette åº“çš„ä½œç”¨
SSE æ”¯æŒï¼šä¸ºFastAPI æä¾›æ ‡å‡†åŒ–çš„ SSE å®ç°ï¼ŒåŸºäº HTML5 EventSource API
å®æ—¶æ•°æ®æ¨é€ï¼šæ”¯æŒæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯çš„å•å‘æ•°æ®æµï¼Œé€‚åˆå®æ—¶æ›´æ–°ã€‚
æ¶ˆæ¯æ ¼å¼åŒ–ï¼š è‡ªåŠ¨å°†Pythonå¯¹è±¡è½¬æ¢ä¸ºSSEæ ‡å‡†æ ¼å¼
é«˜æ€§èƒ½ï¼šåˆ©ç”¨ asyncio å’Œ anyio çš„å¼‚æ­¥ä»»åŠ¡ç»„ï¼ˆTaskGroupsï¼‰ï¼Œç¡®ä¿é«˜æ•ˆå¹¶å‘
æ˜“äºé›†æˆï¼šä¸ FastAPI æ— ç¼å…¼å®¹ï¼Œæ”¯æŒè‡ªå®šä¹‰äº‹ä»¶å’Œå¤´éƒ¨
è¿æ¥ç®¡ç†ï¼š å¤„ç†HTTPè¿æ¥ã€å¿ƒè·³ã€é”™è¯¯æ¢å¤ç­‰


### 3. LiteLLMï¼šç»Ÿä¸€LLMå®¢æˆ·ç«¯æ¥å£

`litellm`æ˜¯ä¸€ä¸ªå¼ºå¤§çš„LLMæŠ½è±¡å±‚ï¼Œå®ƒå±è”½äº†ä¸åŒLLMæä¾›å•†çš„APIå·®å¼‚ï¼Œæä¾›ç»Ÿä¸€çš„è°ƒç”¨æ¥å£ã€‚

**æ ¸å¿ƒä½œç”¨ï¼š**
- **å¤šå‚å•†æ”¯æŒ**ï¼šæ”¯æŒOpenAIã€Claudeã€Geminiã€åƒé—®ã€æ–‡å¿ƒä¸€è¨€ç­‰100+æ¨¡å‹
- **APIæ ‡å‡†åŒ–**ï¼šå°†ä¸åŒå‚å•†çš„APIè°ƒç”¨æ–¹å¼ç»Ÿä¸€ä¸ºOpenAIæ ¼å¼
- **å‚æ•°æ˜ å°„**ï¼šè‡ªåŠ¨å¤„ç†ä¸åŒæ¨¡å‹é—´çš„å‚æ•°å·®å¼‚å’Œé™åˆ¶
- **é”™è¯¯ç»Ÿä¸€**ï¼šæ ‡å‡†åŒ–ä¸åŒå‚å•†çš„é”™è¯¯å“åº”æ ¼å¼

**æŠ€æœ¯ä¼˜åŠ¿ï¼š**
1. **å¼€å‘æ•ˆç‡æå‡**ï¼šä¸€å¥—ä»£ç æ”¯æŒå¤šä¸ªLLMå‚å•†ï¼Œé¿å…é‡å¤å¼€å‘
2. **æ¨¡å‹åˆ‡æ¢çµæ´»**ï¼šé€šè¿‡é…ç½®å³å¯åˆ‡æ¢ä¸åŒæ¨¡å‹ï¼Œæ— éœ€ä¿®æ”¹ä¸šåŠ¡ä»£ç 
3. **é™ä½è¿ç§»æˆæœ¬**ï¼šä»ä¸€ä¸ªå‚å•†è¿ç§»åˆ°å¦ä¸€ä¸ªå‚å•†æˆæœ¬æä½
4. **ç»Ÿä¸€ç›‘æ§ç®¡ç†**ï¼šç»Ÿä¸€çš„è°ƒç”¨æ¥å£ä¾¿äºå®ç°ç»Ÿä¸€çš„ç›‘æ§å’Œæ—¥å¿—

### 4. SmoLAgentsï¼šä¸“ä¸šçš„Agentæ¨ç†æ¡†æ¶

SmoLAgentsæ˜¯Hugging Faceå¼€æºçš„è½»é‡çº§Agentæ¡†æ¶ï¼Œä¸ºæ™ºèƒ½ä½“æä¾›äº†å®Œæ•´çš„æ¨ç†å’Œæ‰§è¡Œèƒ½åŠ›ã€‚

**æ ¸å¿ƒç‰¹æ€§ï¼š**
- **ReActæ¨ç†æ¨¡å¼**ï¼šå®ç°"æ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿ"çš„å®Œæ•´æ¨ç†å¾ªç¯
- **å·¥å…·è°ƒç”¨èƒ½åŠ›**ï¼šå†…ç½®å·¥å…·è°ƒç”¨å’Œä»£ç æ‰§è¡Œå¼•æ“
- **æµå¼è¾“å‡ºæ”¯æŒ**ï¼šåŸç”Ÿæ”¯æŒæµå¼è¾“å‡ºå’Œæ­¥éª¤çº§æ§åˆ¶
- **çµæ´»å¯æ‰©å±•**ï¼šæ˜“äºé›†æˆè‡ªå®šä¹‰å·¥å…·å’Œæç¤ºè¯æ¨¡æ¿

**åœ¨æœ¬æ¡ˆä¾‹ä¸­çš„ä½œç”¨ï¼š**
JDGenieé¡¹ç›®åŸºäºSmoLAgentsæ„å»ºäº†ä»£ç è§£é‡Šå™¨æ™ºèƒ½ä½“ï¼Œåˆ©ç”¨å…¶ReActæ¡†æ¶å®ç°äº†ï¼š
- è‡ªç„¶è¯­è¨€ä»»åŠ¡åˆ†æ
- åŠ¨æ€ä»£ç ç”Ÿæˆä¸æ‰§è¡Œ
- ç»“æœéªŒè¯ä¸è¿­ä»£ä¼˜åŒ–
- å®Œæ•´çš„æµå¼äº¤äº’ä½“éªŒ

**1. è‡ªå®šä¹‰Agentç±»å®ç°**

```python
from smolagents import (
    CodeAgent,
    Tool,
    Model,
    PromptTemplates,
)

class CIAgent(CodeAgent):
    """
    ä»£ç è§£é‡Šå™¨æ™ºèƒ½ä½“ç±»
    
    ç»§æ‰¿è‡ªSmoLAgentsçš„CodeAgentï¼Œæ‰©å±•äº†è¾“å‡ºç›®å½•ç®¡ç†åŠŸèƒ½ã€‚
    ç”¨äºæ‰§è¡Œä»£ç ç”Ÿæˆã€åˆ†æå’Œæ•°æ®å¤„ç†ä»»åŠ¡ã€‚
    """
    
    def __init__(
        self,
        tools: list[Tool],                                    # æ™ºèƒ½ä½“å¯ç”¨çš„å·¥å…·åˆ—è¡¨
        model: Model,                                         # LLMæ¨¡å‹å®ä¾‹
        prompt_templates: PromptTemplates | None = None,      # è‡ªå®šä¹‰æç¤ºè¯æ¨¡æ¿
        additional_authorized_imports: list[str] | None = None, # é¢å¤–å…è®¸çš„Pythonå¯¼å…¥æ¨¡å—
        planning_interval: int | None = None,                 # è§„åˆ’æ­¥éª¤çš„é—´éš”
        executor_type: str | None = "local",                  # æ‰§è¡Œå™¨ç±»å‹ï¼šlocal/remote
        executor_kwargs: dict[str, Any] | None = None,        # æ‰§è¡Œå™¨é¢å¤–å‚æ•°
        grammar: dict[str, str] | None = None,                # è¯­æ³•è§„åˆ™å®šä¹‰
        output_dir: Optional[str] = None,                     # è¾“å‡ºæ–‡ä»¶ä¿å­˜ç›®å½•
        *args,
        **kwargs,
    ):
        # ä¿å­˜è¾“å‡ºç›®å½•é…ç½®ï¼Œç”¨äºåç»­æ–‡ä»¶ç”Ÿæˆ
        self.output_dir = output_dir
        
        # è°ƒç”¨çˆ¶ç±»æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–CodeAgentæ ¸å¿ƒåŠŸèƒ½
        super().__init__(
            tools=tools,
            model=model,
            prompt_templates=prompt_templates,
            grammar=grammar,
            planning_interval=planning_interval,
            additional_authorized_imports=additional_authorized_imports,
            executor_type=executor_type,
            executor_kwargs=executor_kwargs,
            **kwargs,
        )
```

2.æŒ‰éœ€é‡å†™ `_step_stream` æ–¹æ³•
å®ç°**ä¸šåŠ¡ç‰¹å®šçš„æµå¼å¤„ç†éœ€æ±‚**
é¡¹ç›®é‡å†™ä¸»è¦ä¸ºäº†å®ç°ï¼š
- ğŸ¯ **åˆ†é˜¶æ®µæµå¼è¾“å‡º**ï¼šéœ€è¦åœ¨ä»£ç æ‰§è¡Œåç«‹å³è¿”å› `CodeOuput`
- ğŸ“ **æ™ºèƒ½æ–‡ä»¶å¤„ç†**ï¼šè‡ªåŠ¨ç”Ÿæˆå’Œå‘½åä»£ç æ–‡ä»¶  
- ğŸ” **å¤æ‚å®Œæˆåˆ¤æ–­**ï¼šé›†æˆ `FinalAnswerCheck` æ›¿ä»£ç®€å•å¸ƒå°”åˆ¤æ–­
- â±ï¸ **æ€§èƒ½ç›‘æ§**ï¼š`@timer()` è£…é¥°å™¨å®æ—¶ç›‘æ§
- ğŸ¨ **å¢å¼ºæ¸²æŸ“**ï¼šæ›´è¯¦ç»†çš„Richåº“æ¸²æŸ“æ”¯æŒ

| å¯¹æ¯”ç»´åº¦ | SmoLAgentsåŸç”Ÿ | é¡¹ç›®CIAgenté‡å†™ |
|:---:|:---:|:---:|
| **è¿”å›ç±»å‹** | `ActionOutput` (å•ä¸€æœ€ç»ˆç»“æœ) | `CodeOuput` + `ActionOutput` (åˆ†é˜¶æ®µè¾“å‡º) |
| **å¤„ç†æµç¨‹** | ä¸€æ¬¡æ€§ï¼šç”Ÿæˆâ†’è§£æâ†’æ‰§è¡Œâ†’è¿”å› | åˆ†é˜¶æ®µï¼šç”Ÿæˆâ†’è§£æâ†’æ‰§è¡Œâ†’**ä¸­é—´è¾“å‡º**â†’åˆ¤æ–­â†’æœ€ç»ˆè¾“å‡º |
| **å®Œæˆåˆ¤æ–­** | `code_output.is_final_answer` | è‡ªå®šä¹‰ `FinalAnswerCheck` æ™ºèƒ½åˆ¤æ–­ |
| **æ–‡ä»¶ç®¡ç†** | æ— ç‰¹æ®Šå¤„ç† | æ™ºèƒ½æ–‡ä»¶å‘½åï¼š`f"{matcher.group(1).replace(' ', '')}.py"` |
| **è¯·æ±‚è¿½è¸ª** | æ ‡å‡†å¤„ç† | è‡ªå®šä¹‰è¯·æ±‚IDï¼š`f"{model_request_id}-final"` |

**2. æ™ºèƒ½ä½“å¯¹è±¡é…ç½®ä¸åˆå§‹åŒ–**

```python 
def create_ci_agent(
    prompt_templates=None,              # æç¤ºè¯æ¨¡æ¿
    max_tokens: int = 16000,           # æœ€å¤§tokenæ•°
    return_full_result: bool = True,   # æ˜¯å¦è¿”å›å®Œæ•´ç»“æœ
    output_dir: str = "",              # è¾“å‡ºç›®å½•
) -> CIAgent:
    """
    åˆ›å»ºä»£ç è§£é‡Šå™¨æ™ºèƒ½ä½“å®ä¾‹
    
    ä½¿ç”¨LiteLLMåŒ…è£…çš„æ¨¡å‹å’ŒPythonè§£é‡Šå™¨å·¥å…·æ„å»ºAgentã€‚
    """
    # åˆå§‹åŒ–LiteLLMæ¨¡å‹ï¼Œæ”¯æŒå¤šç§LLMæä¾›å•†
    model = LiteLLMModel(
        max_tokens=max_tokens,
        model_id=os.getenv("CODE_INTEPRETER_MODEL", "gpt-4.1")
    )

    # åˆ›å»ºå¹¶è¿”å›CIAgentå®ä¾‹
    return CIAgent(
        model=model,
        prompt_templates=prompt_templates,
        tools=[PythonInterpreterTool()],  # é…ç½®Pythonä»£ç æ‰§è¡Œå·¥å…·
        return_full_result=return_full_result,
        additional_authorized_imports=[    # å…è®¸å¯¼å…¥çš„æ•°æ®åˆ†æåº“
            "pandas", "openpyxl", "numpy", 
            "matplotlib", "seaborn",
        ],
        output_dir=output_dir,
    )
```


```python
from litellm import acompletion

async def ask_llm(
    messages: str | List[Any],
    model: str,
    temperature: float = None,
    stream: bool = False,
    **kwargs,
):
    response = await acompletion(
        messages=messages,
        model=model,
        temperature=temperature,
        stream=stream,
        **kwargs
    )
    
    if stream:
        async for chunk in response:
            yield chunk.choices[0].delta.content
    else:
        yield response.choices[0].message.content
```

## ä»£ç è§£é‡Šå™¨æ™ºèƒ½ä½“ï¼šæ ¸å¿ƒå®ç°æ¡ˆä¾‹

ä»¥`code_interpreter_agent`ä¸ºä¾‹ï¼Œå±•ç¤ºå®Œæ•´çš„æµå¼é€šä¿¡å®ç°ï¼š

### 1. æ™ºèƒ½ä½“åˆå§‹åŒ–

```python
def create_ci_agent(
    prompt_templates=None,
    max_tokens: int = 16000,
    return_full_result: bool = True,
    output_dir: str = "",
) -> CIAgent:
    # ä½¿ç”¨LiteLLMModelç±»å°è£…LLMæ¨¡å‹
    model = LiteLLMModel(
        max_tokens=max_tokens,
        model_id=os.getenv("CODE_INTEPRETER_MODEL","gpt-4.1")
    )

    return CIAgent(
        model=model,
        prompt_templates=prompt_templates,
        tools=[PythonInterpreterTool()],  # é…ç½®Pythonè§£é‡Šå™¨å·¥å…·
        return_full_result=return_full_result,
        additional_authorized_imports=[
            "pandas", "openpyxl", "numpy", "matplotlib", "seaborn",
        ],
        output_dir=output_dir,
    )
```

### 2. æµå¼æ‰§è¡Œé€»è¾‘

```python
async def code_interpreter_agent(
    task: str,
    file_names: Optional[List[str]] = None,
    max_tokens: int = 32000,
    request_id: str = "",
    stream: bool = True,
):
    # æ–‡ä»¶é¢„å¤„ç†
    files = await process_input_files(file_names, work_dir)
    
    # æ„å»ºæ™ºèƒ½ä½“
    agent = create_ci_agent(
        prompt_templates=ci_prompt_template,
        max_tokens=max_tokens,
        output_dir=output_dir,
    )
    
    # æµå¼æ‰§è¡Œ
    if stream:
        for step in agent.run(task=template_task, stream=True, max_steps=10):
            if isinstance(step, CodeOuput):
                # ä»£ç è¾“å‡ºæ­¥éª¤
                file_info = await upload_file(
                    content=step.code,
                    file_name=step.file_name,
                    file_type="py",
                    request_id=request_id,
                )
                step.file_list = [file_info]
                yield step
                
            elif isinstance(step, FinalAnswerStep):
                # æœ€ç»ˆç»“æœæ­¥éª¤
                output = ActionOutput(content=step.output, file_list=file_list)
                yield output
                
            elif isinstance(step, ChatMessageStreamDelta):
                # LLMæµå¼è¾“å‡ºæ­¥éª¤
                pass  # æ ¹æ®éœ€è¦å¤„ç†ä¸­é—´æ€è€ƒè¿‡ç¨‹
                
            await asyncio.sleep(0)  # è®©å‡ºæ§åˆ¶æƒï¼Œé¿å…é˜»å¡
```

### 3. APIæ¥å£å®ç°

```python
@router.post("/code_interpreter")
async def post_code_interpreter(body: CIRequest):
    
    async def _stream():
        async for chunk in code_interpreter_agent(
            task=body.task,
            file_names=body.file_names,
            request_id=body.request_id,
            stream=True,
        ):
            if isinstance(chunk, CodeOuput):
                # è¿”å›ä»£ç ç‰‡æ®µ
                yield ServerSentEvent(
                    data=json.dumps({
                        "requestId": body.request_id,
                        "code": chunk.code,
                        "fileInfo": chunk.file_list,
                        "isFinal": False,
                    }, ensure_ascii=False)
                )
            elif isinstance(chunk, ActionOutput):
                # è¿”å›æœ€ç»ˆç»“æœ
                yield ServerSentEvent(
                    data=json.dumps({
                        "requestId": body.request_id,
                        "codeOutput": chunk.content,
                        "fileInfo": chunk.file_list,
                        "isFinal": True,
                    }, ensure_ascii=False)
                )
                yield ServerSentEvent(data="[DONE]")

    return EventSourceResponse(
        _stream(),
        ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
        ping=15,
    )
```


å•æ™ºèƒ½ä½“åœ¨AIåº”ç”¨ä¸­çš„æµå¼æ•°æ®ä¼ è¾“çš„å®Œæ•´é“¾è·¯

## ğŸ”„ æµå¼æ•°æ®ä¼ è¾“çš„å®Œæ•´é“¾è·¯

### 1. æ•°æ®æµå‘åˆ†æ

"""
æ•°æ®æµå‘é“¾è·¯ï¼š

LLM API (OpenAI/Claude/DeepSeek)
    â†“ åŸå§‹æµå¼å“åº”
code_interpreter_agent() 
    â†“ å¤„ç†åçš„ CodeOutput/ActionOutput å¯¹è±¡
_stream() å¼‚æ­¥ç”Ÿæˆå™¨
    â†“ yield ServerSentEvent (ä½ é—®çš„è¿™ä¸€æ­¥ï¼)
EventSourceResponse (sse-starlette)
    â†“ HTTP SSE æµå¼å“åº”
Javaåç«¯ (æ¥æ”¶æ–¹)
    â†“ å†æ¬¡è½¬å‘
å‰ç«¯ç”¨æˆ·ç•Œé¢
"""
### 2. ServerSentEvent çš„æ•°æ®æ ¼å¼
```Python
             yield ServerSentEvent(
                    data=json.dumps(
                        {
                            "requestId": body.request_id,
                            "code": chunk.code,
                            "fileInfo": chunk.file_list,
                            "isFinal": False,
                        },
                        ensure_ascii=False,
                    )
                )

```


2.2 æµå¼å“åº”å¤„ç†æœºåˆ¶
```Python
  async with AsyncTimer(key=f"exec ask_llm"):
        if stream:
            async for chunk in response:
                if only_content:
                    if chunk.choices and chunk.choices[0] and chunk.choices[0].delta and chunk.choices[0].delta.content:
                        yield chunk.choices[0].delta.content
                else:
                    yield chunk
        else:
            yield response.choices[0].message.content if only_content else response
```
å…³é”®ç‰¹æ€§ï¼š
å¼‚æ­¥è¿­ä»£å™¨æ¨¡å¼ - async for chunk in response
å¢é‡å†…å®¹æå– - ä»delta.contentè·å–æµå¼ç‰‡æ®µ
çµæ´»è¾“å‡ºæ¨¡å¼ - æ”¯æŒçº¯å†…å®¹æˆ–å®Œæ•´å“åº”å¯¹è±¡



 ä¸‰ç§æµå¼æ¨¡å¼ï¼šGeneral(å®æ—¶)ã€Token(ç´¯ç§¯)ã€Time(å®šæ—¶)ï¼Œé€‚åº”ä¸åŒåº”ç”¨åœºæ™¯

### 1.Generalæ¨¡å¼ï¼ˆå®æ—¶æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š

- æ¯ä¸ªchunkç«‹å³æ¨é€åˆ°å‰ç«¯
- æœ€å¿«çš„ç”¨æˆ·åé¦ˆä½“éªŒ
- é€‚ç”¨äºä»£ç ç”Ÿæˆã€å®æ—¶å¯¹è¯åœºæ™¯

åº”ç”¨åœºæ™¯ï¼šÂ ä»£ç è§£é‡Šå™¨å·¥å…·ï¼Œç”¨æˆ·éœ€è¦å®æ—¶çœ‹åˆ°ä»£ç ç”Ÿæˆè¿‡ç¨‹
```Python
        acc_content += chunk
        acc_token += 1
        if body.stream_mode.mode == "general":
            yield ServerSentEvent(
                data=json.dumps(
                    {"requestId": body.request_id, "data": chunk, "isFinal": False},
                    ensure_ascii=False,
                )
            )
```


### 3.2 Tokenæ¨¡å¼ï¼ˆæ‰¹é‡ç´¯ç§¯æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š
- ç´¯ç§¯Nä¸ªtokenåæ‰¹é‡æ¨é€
- å¹³è¡¡å“åº”é€Ÿåº¦å’Œç½‘ç»œå¼€é”€
- é€‚ç”¨äºé•¿æ–‡æœ¬ç”Ÿæˆåœºæ™¯
åº”ç”¨åœºæ™¯ï¼šÂ æ·±åº¦æœç´¢å·¥å…·ï¼Œéœ€è¦å¤„ç†å¤§é‡æœç´¢ç»“æœ
```Python
                elif body.stream_mode.mode == "token":
                    if acc_token >= body.stream_mode.token:
                        yield ServerSentEvent(
                            data=json.dumps(
                                {
                                    "requestId": body.request_id,
                                    "data": acc_content,
                                    "isFinal": False,
                                },
                                ensure_ascii=False,
                            )
                        )
                        acc_token = 0
                        acc_content = ""
```
### 3.3 Timeæ¨¡å¼ï¼ˆå®šæ—¶æ‰¹é‡æ¨é€ï¼‰
ç‰¹ç‚¹ï¼š
æŒ‰å›ºå®šæ—¶é—´é—´éš”æ¨é€
ç¨³å®šçš„æ¨é€èŠ‚å¥
é€‚ç”¨äºæŠ¥å‘Šç”Ÿæˆåœºæ™¯
åº”ç”¨åœºæ™¯ï¼š HTML/PPTæŠ¥å‘Šç”Ÿæˆï¼Œé¿å…é¢‘ç¹æ¨é€å½±å“æ¸²æŸ“æ€§èƒ½

```Python
                elif body.stream_mode.mode == "time":
                    if time.time() - acc_time > body.stream_mode.time:
                        yield ServerSentEvent(
                            data=json.dumps(
                                {
                                    "requestId": body.request_id,
                                    "data": acc_content,
                                    "isFinal": False,
                                },
                                ensure_ascii=False,
                            )
                        )
                        acc_time = time.time()
                        acc_content = ""
```






### å®é™…åº”ç”¨åœºæ™¯

- ä»£ç è§£é‡Šå™¨ï¼šå®æ—¶ç”Ÿæˆå’Œæ‰§è¡ŒPythonä»£ç ï¼Œæµå¼æ˜¾ç¤ºè¿‡ç¨‹

- æ·±åº¦æœç´¢ï¼šæ‰¹é‡å¤„ç†æœç´¢ç»“æœï¼ŒTokenæ¨¡å¼ä¼˜åŒ–ç½‘ç»œå¼€é”€

- æŠ¥å‘Šç”Ÿæˆï¼šå®šæ—¶æ¨é€HTML/PPTå†…å®¹ï¼Œé¿å…é¢‘ç¹UIæ›´æ–°


## Agentæ‰§è¡ŒçŠ¶æ€çš„æµå¼åé¦ˆ

### Agentç”Ÿå‘½å‘¨æœŸä¸çŠ¶æ€æµ

AI Agentçš„æ‰§è¡Œè¿‡ç¨‹é€šå¸¸åŒ…å«å¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦å‘ç”¨æˆ·æä¾›å®æ—¶åé¦ˆï¼š

```java
public enum AgentState {
    INITIALIZING("åˆå§‹åŒ–ä¸­", "æ­£åœ¨å‡†å¤‡æ‰§è¡Œç¯å¢ƒ..."),
    PLANNING("åˆ¶å®šè®¡åˆ’", "æ­£åœ¨åˆ†æä»»åŠ¡å¹¶åˆ¶å®šæ‰§è¡Œè®¡åˆ’..."),
    TOOL_CALLING("è°ƒç”¨å·¥å…·", "æ­£åœ¨ä½¿ç”¨å·¥å…·æ‰§è¡Œå…·ä½“ä»»åŠ¡..."),
    THINKING("æ€è€ƒä¸­", "æ­£åœ¨åˆ†æä¸­é—´ç»“æœ..."),
    SUMMARIZING("æ€»ç»“ä¸­", "æ­£åœ¨æ•´ç†å’Œæ€»ç»“æ‰§è¡Œç»“æœ..."),
    COMPLETED("å·²å®Œæˆ", "ä»»åŠ¡æ‰§è¡Œå®Œæˆ"),
    ERROR("æ‰§è¡Œé”™è¯¯", "æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°é”™è¯¯");

    private final String displayName;
    private final String description;

    AgentState(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }
}

@Component
public class AgentStatusStreamer {
    
    public void streamAgentStatus(Printer printer, AgentState state, String detail) {
        AgentStatusMessage message = AgentStatusMessage.builder()
            .state(state.name())
            .displayName(state.getDisplayName())
            .description(state.getDescription())
            .detail(detail)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_status", message);
    }

    public void streamThinking(Printer printer, String thought) {
        ThinkingMessage message = ThinkingMessage.builder()
            .content(thought)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_thinking", message);
    }

    public void streamPlanUpdate(Printer printer, List<Plan> plans, int currentStep) {
        PlanUpdateMessage message = PlanUpdateMessage.builder()
            .plans(plans)
            .currentStep(currentStep)
            .progress(calculateProgress(plans, currentStep))
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("plan_update", message);
    }

    private double calculateProgress(List<Plan> plans, int currentStep) {
        if (plans == null || plans.isEmpty()) {
            return 0.0;
        }
        return Math.min(100.0, (double) currentStep / plans.size() * 100);
    }
}
```

### åˆ†å±‚çŠ¶æ€åé¦ˆæœºåˆ¶

```java
public abstract class BaseAgent {
    protected Printer printer;
    protected AgentStatusStreamer statusStreamer;
    
    protected void executeWithStatusFeedback(String operation, Runnable task) {
        try {
            // å¼€å§‹æ‰§è¡Œåé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.TOOL_CALLING, "å¼€å§‹æ‰§è¡Œ: " + operation);
            
            // æ‰§è¡Œå®é™…ä»»åŠ¡
            task.run();
            
            // å®Œæˆåé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.COMPLETED, "å®Œæˆ: " + operation);
                
        } catch (Exception e) {
            // é”™è¯¯åé¦ˆ
            statusStreamer.streamAgentStatus(printer, 
                AgentState.ERROR, "æ‰§è¡Œå¤±è´¥: " + operation + " - " + e.getMessage());
            throw e;
        }
    }

    protected <T> T executeWithProgressFeedback(String operation, 
                                               Supplier<T> task, 
                                               ProgressCallback callback) {
        statusStreamer.streamAgentStatus(printer, AgentState.TOOL_CALLING, operation);
        
        return task.get(); // å®é™…æ‰§è¡Œä¸­ä¼šç»“åˆcallbackæä¾›è¿›åº¦æ›´æ–°
    }
}

@Component
public class PlanningAgent extends BaseAgent {
    
    @Override
    public void handle(AgentContext context, AgentRequest request) {
        printer = context.getPrinter();
        statusStreamer = new AgentStatusStreamer();
        
        try {
            // é˜¶æ®µ1ï¼šåˆå§‹åŒ–
            statusStreamer.streamAgentStatus(printer, AgentState.INITIALIZING, 
                "å‡†å¤‡åˆ†æä»»åŠ¡: " + request.getQuery());
            
            // é˜¶æ®µ2ï¼šåˆ¶å®šè®¡åˆ’
            statusStreamer.streamAgentStatus(printer, AgentState.PLANNING, 
                "æ­£åœ¨åˆ¶å®šæ‰§è¡Œè®¡åˆ’...");
            
            List<Plan> plans = executeWithProgressFeedback("ç”Ÿæˆæ‰§è¡Œè®¡åˆ’", 
                () -> generatePlan(request), 
                (progress, detail) -> {
                    // è¿›åº¦å›è°ƒ
                    printer.send("plan_progress", Map.of(
                        "progress", progress,
                        "detail", detail
                    ));
                });
            
            // æµå¼å‘é€å®Œæ•´è®¡åˆ’
            statusStreamer.streamPlanUpdate(printer, plans, 0);
            
            // é˜¶æ®µ3ï¼šæ‰§è¡Œè®¡åˆ’
            executePlansWithStreaming(context, plans);
            
        } catch (Exception e) {
            statusStreamer.streamAgentStatus(printer, AgentState.ERROR, e.getMessage());
            throw e;
        }
    }

    private void executePlansWithStreaming(AgentContext context, List<Plan> plans) {
        for (int i = 0; i < plans.size(); i++) {
            Plan plan = plans.get(i);
            
            // æ›´æ–°å½“å‰æ‰§è¡Œè®¡åˆ’
            statusStreamer.streamPlanUpdate(printer, plans, i + 1);
            
            // æ‰§è¡Œå•ä¸ªè®¡åˆ’æ­¥éª¤
            executeWithStatusFeedback("æ‰§è¡Œæ­¥éª¤: " + plan.getAction(), () -> {
                executePlan(context, plan);
                plan.setStatus(PlanStatus.COMPLETED);
            });
            
            // å‘é€æ­¥éª¤å®Œæˆçš„æµå¼åé¦ˆ
            printer.send("plan_step_completed", Map.of(
                "stepIndex", i,
                "plan", plan,
                "progress", (i + 1.0) / plans.size() * 100
            ));
        }
    }
}
```

## å·¥å…·è°ƒç”¨ç»“æœçš„å¢é‡ä¼ è¾“

### å·¥å…·æ‰§è¡Œçš„æµå¼åŒ…è£…

```java
public abstract class BaseTool {
    protected AgentContext agentContext;

    /**
     * æµå¼æ‰§è¡Œå·¥å…·ï¼Œæ”¯æŒå¢é‡ç»“æœä¼ è¾“
     */
    protected <T> T executeStreamingly(String toolName, 
                                     Supplier<T> execution, 
                                     Function<T, Stream<Object>> resultStreamer) {
        Printer printer = agentContext.getPrinter();
        String requestId = agentContext.getRequestId();
        
        // å¼€å§‹æ‰§è¡Œé€šçŸ¥
        printer.send("tool_start", Map.of(
            "toolName", toolName,
            "requestId", requestId,
            "timestamp", System.currentTimeMillis()
        ));
        
        try {
            T result = execution.get();
            
            // æµå¼ä¼ è¾“ç»“æœ
            if (resultStreamer != null) {
                resultStreamer.apply(result).forEach(chunk -> {
                    printer.send("tool_stream", Map.of(
                        "toolName", toolName,
                        "chunk", chunk,
                        "requestId", requestId
                    ));
                });
            }
            
            // å®Œæˆé€šçŸ¥
            printer.send("tool_complete", Map.of(
                "toolName", toolName,
                "result", result,
                "requestId", requestId
            ));
            
            return result;
            
        } catch (Exception e) {
            // é”™è¯¯é€šçŸ¥
            printer.send("tool_error", Map.of(
                "toolName", toolName,
                "error", e.getMessage(),
                "requestId", requestId
            ));
            throw e;
        }
    }
}

@Component
public class DeepSearchTool extends BaseTool {
    
    @Override
    public String call(String query) {
        return executeStreamingly("æ·±åº¦æœç´¢", 
            () -> performDeepSearch(query),
            result -> streamSearchResults(result));
    }

    private DeepSearchResult performDeepSearch(String query) {
        Printer printer = agentContext.getPrinter();
        
        // ç¬¬ä¸€æ­¥ï¼šæŸ¥è¯¢ç†è§£
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "description", "ç†è§£æœç´¢æ„å›¾",
            "status", "in_progress"
        ));
        
        QueryIntent intent = analyzeQuery(query);
        
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "result", intent,
            "status", "completed"
        ));
        
        // ç¬¬äºŒæ­¥ï¼šå¤šæºæœç´¢
        printer.send("search_step", Map.of(
            "step", "multi_source_search",
            "description", "æ‰§è¡Œå¤šæºæœç´¢",
            "status", "in_progress"
        ));
        
        List<SearchSource> sources = getSearchSources();
        List<SearchResult> allResults = new ArrayList<>();
        
        for (int i = 0; i < sources.size(); i++) {
            SearchSource source = sources.get(i);
            
            printer.send("search_progress", Map.of(
                "source", source.getName(),
                "progress", (i + 1.0) / sources.size() * 100,
                "status", "searching"
            ));
            
            try {
                List<SearchResult> sourceResults = searchFromSource(source, query);
                allResults.addAll(sourceResults);
                
                // æµå¼å‘é€ä¸­é—´ç»“æœ
                printer.send("search_intermediate", Map.of(
                    "source", source.getName(),
                    "results", sourceResults,
                    "count", sourceResults.size()
                ));
                
            } catch (Exception e) {
                printer.send("search_error", Map.of(
                    "source", source.getName(),
                    "error", e.getMessage()
                ));
            }
        }
        
        // ç¬¬ä¸‰æ­¥ï¼šç»“æœæ•´åˆ
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "description", "æ•´åˆæœç´¢ç»“æœ",
            "status", "in_progress",
            "totalResults", allResults.size()
        ));
        
        DeepSearchResult finalResult = integrateResults(allResults, intent);
        
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "status", "completed",
            "finalResultCount", finalResult.getItems().size()
        ));
        
        return finalResult;
    }

    private Stream<Object> streamSearchResults(DeepSearchResult result) {
        return result.getItems().stream().map(item -> Map.of(
            "type", "search_item",
            "title", item.getTitle(),
            "content", item.getContent(),
            "source", item.getSource(),
            "relevance", item.getRelevance()
        ));
    }
}
```

### ä»£ç è§£é‡Šå™¨çš„æµå¼è¾“å‡º

```java
@Component
public class CodeInterpreterTool extends BaseTool {
    
    @Override
    public CodeInterpreterResponse call(CodeInterpreterRequest request) {
        return executeStreamingly("ä»£ç è§£é‡Šå™¨",
            () -> executeCode(request),
            result -> streamCodeExecution(result));
    }

    private CodeInterpreterResult executeCode(CodeInterpreterRequest request) {
        Printer printer = agentContext.getPrinter();
        String code = request.getCode();
        String language = request.getLanguage();
        
        // ä»£ç åˆ†æé˜¶æ®µ
        printer.send("code_analysis", Map.of(
            "phase", "analyzing",
            "language", language,
            "codeLength", code.length()
        ));
        
        CodeAnalysis analysis = analyzeCode(code, language);
        
        printer.send("code_analysis", Map.of(
            "phase", "completed",
            "analysis", analysis,
            "estimatedExecutionTime", analysis.getEstimatedTime()
        ));
        
        // æ‰§è¡Œç¯å¢ƒå‡†å¤‡
        printer.send("execution_env", Map.of(
            "phase", "preparing",
            "environment", language
        ));
        
        ExecutionEnvironment env = prepareEnvironment(language);
        
        printer.send("execution_env", Map.of(
            "phase", "ready",
            "environmentId", env.getId()
        ));
        
        // ä»£ç æ‰§è¡Œ - å®æ—¶è¾“å‡º
        printer.send("code_execution", Map.of(
            "phase", "running",
            "startTime", System.currentTimeMillis()
        ));
        
        CodeExecutionResult result = executeCodeWithStreaming(env, code, printer);
        
        return CodeInterpreterResult.builder()
            .analysis(analysis)
            .executionResult(result)
            .environment(env)
            .build();
    }

    private CodeExecutionResult executeCodeWithStreaming(ExecutionEnvironment env, 
                                                        String code, 
                                                        Printer printer) {
        StringBuilder stdout = new StringBuilder();
        StringBuilder stderr = new StringBuilder();
        
        // åˆ›å»ºæµå¼è¾“å‡ºå¤„ç†å™¨
        ProcessBuilder pb = new ProcessBuilder(env.getCommand(), code);
        pb.redirectErrorStream(false);
        
        try {
            Process process = pb.start();
            
            // å¼‚æ­¥è¯»å–æ ‡å‡†è¾“å‡º
            Thread stdoutReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stdout.append(line).append("\n");
                        
                        // å®æ—¶æµå¼è¾“å‡º
                        printer.send("code_stdout", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis()
                        ));
                    }
                } catch (IOException e) {
                    log.error("è¯»å–æ ‡å‡†è¾“å‡ºå¤±è´¥", e);
                }
            });
            
            // å¼‚æ­¥è¯»å–é”™è¯¯è¾“å‡º
            Thread stderrReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getErrorStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stderr.append(line).append("\n");
                        
                        // å®æ—¶æµå¼é”™è¯¯è¾“å‡º
                        printer.send("code_stderr", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis(),
                            "level", "error"
                        ));
                    }
                } catch (IOException e) {
                    log.error("è¯»å–é”™è¯¯è¾“å‡ºå¤±è´¥", e);
                }
            });
            
            stdoutReader.start();
            stderrReader.start();
            
            // ç­‰å¾…æ‰§è¡Œå®Œæˆ
            int exitCode = process.waitFor();
            
            stdoutReader.join();
            stderrReader.join();
            
            // å‘é€æ‰§è¡Œå®Œæˆé€šçŸ¥
            printer.send("code_execution", Map.of(
                "phase", "completed",
                "exitCode", exitCode,
                "endTime", System.currentTimeMillis()
            ));
            
            return CodeExecutionResult.builder()
                .exitCode(exitCode)
                .stdout(stdout.toString())
                .stderr(stderr.toString())
                .executionTime(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            printer.send("code_execution", Map.of(
                "phase", "error",
                "error", e.getMessage()
            ));
            throw new RuntimeException("ä»£ç æ‰§è¡Œå¤±è´¥", e);
        }
    }

    private Stream<Object> streamCodeExecution(CodeInterpreterResult result) {
        List<Object> streamItems = new ArrayList<>();
        
        // åˆ†æç»“æœ
        streamItems.add(Map.of(
            "type", "analysis",
            "data", result.getAnalysis()
        ));
        
        // æ‰§è¡Œç»“æœ
        streamItems.add(Map.of(
            "type", "execution_result",
            "data", result.getExecutionResult()
        ));
        
        // å¦‚æœæœ‰ç”Ÿæˆçš„æ–‡ä»¶ï¼Œé€ä¸ªæµå¼ä¼ è¾“
        if (result.getGeneratedFiles() != null) {
            result.getGeneratedFiles().forEach(file -> {
                streamItems.add(Map.of(
                    "type", "generated_file",
                    "data", file
                ));
            });
        }
        
        return streamItems.stream();
    }
}
```

## å¤šAgentåä½œçš„æµå¼æ¶ˆæ¯ä¼ é€’

### Agenté—´é€šä¿¡æ¶æ„

```java
@Component
public class AgentCommunicationBus {
    private final Map<String, Agent> activeAgents = new ConcurrentHashMap<>();
    private final Map<String, List<AgentMessageListener>> listeners = new ConcurrentHashMap<>();
    private final ExecutorService messageDispatcher = Executors.newFixedThreadPool(5);

    /**
     * æ³¨å†ŒAgentåˆ°é€šä¿¡æ€»çº¿
     */
    public void registerAgent(String agentId, Agent agent) {
        activeAgents.put(agentId, agent);
        
        // å‘é€Agentæ³¨å†Œé€šçŸ¥
        broadcastMessage(AgentMessage.builder()
            .fromAgent("system")
            .toAgent("all")
            .messageType("agent_registered")
            .data(Map.of("agentId", agentId, "agentType", agent.getType()))
            .build());
    }

    /**
     * å‘é€Agenté—´æ¶ˆæ¯
     */
    public void sendMessage(AgentMessage message) {
        messageDispatcher.submit(() -> {
            try {
                // è®°å½•æ¶ˆæ¯æ—¥å¿—
                logMessage(message);
                
                // æµå¼é€šçŸ¥ç”¨æˆ·
                notifyUserOfAgentCommunication(message);
                
                if ("all".equals(message.getToAgent())) {
                    // å¹¿æ’­æ¶ˆæ¯
                    activeAgents.forEach((agentId, agent) -> {
                        if (!agentId.equals(message.getFromAgent())) {
                            deliverMessage(agent, message);
                        }
                    });
                } else {
                    // ç‚¹å¯¹ç‚¹æ¶ˆæ¯
                    Agent targetAgent = activeAgents.get(message.getToAgent());
                    if (targetAgent != null) {
                        deliverMessage(targetAgent, message);
                    }
                }
                
                // é€šçŸ¥ç›‘å¬å™¨
                notifyListeners(message);
                
            } catch (Exception e) {
                log.error("æ¶ˆæ¯å‘é€å¤±è´¥", e);
            }
        });
    }

    private void notifyUserOfAgentCommunication(AgentMessage message) {
        // è·å–ç›¸å…³çš„Printerï¼ˆé€šè¿‡è¯·æ±‚IDå…³è”ï¼‰
        Printer printer = getPrinterForMessage(message);
        if (printer != null) {
            printer.send("agent_communication", Map.of(
                "fromAgent", message.getFromAgent(),
                "toAgent", message.getToAgent(),
                "messageType", message.getMessageType(),
                "summary", summarizeMessage(message),
                "timestamp", message.getTimestamp()
            ));
        }
    }

    private void deliverMessage(Agent agent, AgentMessage message) {
        try {
            agent.receiveMessage(message);
        } catch (Exception e) {
            log.error("æ¶ˆæ¯æŠ•é€’å¤±è´¥: {} -> {}", message.getFromAgent(), 
                     agent.getId(), e);
        }
    }

    /**
     * å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰Agent
     */
    public void broadcastMessage(AgentMessage message) {
        message.setToAgent("all");
        sendMessage(message);
    }

    /**
     * æ·»åŠ æ¶ˆæ¯ç›‘å¬å™¨
     */
    public void addMessageListener(String messageType, AgentMessageListener listener) {
        listeners.computeIfAbsent(messageType, k -> new ArrayList<>()).add(listener);
    }

    private void notifyListeners(AgentMessage message) {
        List<AgentMessageListener> typeListeners = listeners.get(message.getMessageType());
        if (typeListeners != null) {
            typeListeners.forEach(listener -> {
                try {
                    listener.onMessage(message);
                } catch (Exception e) {
                    log.error("æ¶ˆæ¯ç›‘å¬å™¨æ‰§è¡Œå¤±è´¥", e);
                }
            });
        }
    }
}

@Data
@Builder
public class AgentMessage {
    private String messageId;
    private String fromAgent;
    private String toAgent;
    private String messageType;
    private Object data;
    private long timestamp;
    private String requestId; // å…³è”ç”¨æˆ·è¯·æ±‚
}
```

### åä½œæµç¨‹çš„å¯è§†åŒ–æµå¼ä¼ è¾“

```java
@Component
public class CollaborationVisualizer {
    
    public void visualizeCollaboration(String requestId, List<Agent> agents, Printer printer) {
        // åˆå§‹åŒ–åä½œå›¾
        CollaborationGraph graph = new CollaborationGraph();
        agents.forEach(agent -> graph.addNode(agent.getId(), agent.getType()));
        
        printer.send("collaboration_init", Map.of(
            "graph", graph,
            "agents", agents.stream().map(this::serializeAgent).collect(Collectors.toList())
        ));
        
        // ç›‘å¬Agenté—´é€šä¿¡
        AgentCommunicationBus bus = getAgentCommunicationBus();
        bus.addMessageListener("all", message -> {
            if (requestId.equals(message.getRequestId())) {
                // æ›´æ–°åä½œå›¾
                graph.addEdge(message.getFromAgent(), message.getToAgent(), message.getMessageType());
                
                // æµå¼å‘é€åä½œæ›´æ–°
                printer.send("collaboration_update", Map.of(
                    "edge", Map.of(
                        "from", message.getFromAgent(),
                        "to", message.getToAgent(),
                        "type", message.getMessageType(),
                        "timestamp", message.getTimestamp()
                    ),
                    "graph", graph.getSnapshot()
                ));
            }
        });
    }

    private Map<String, Object> serializeAgent(Agent agent) {
        return Map.of(
            "id", agent.getId(),
            "type", agent.getType(),
            "status", agent.getStatus(),
            "capabilities", agent.getCapabilities()
        );
    }
}

@Component 
public class MultiAgentOrchestrator {
    private final AgentCommunicationBus communicationBus;
    private final CollaborationVisualizer visualizer;

    public void executeCollaborativeTask(AgentContext context, CollaborativeTask task) {
        String requestId = context.getRequestId();
        Printer printer = context.getPrinter();
        
        // åˆå§‹åŒ–åä½œç¯å¢ƒ
        printer.send("collaboration_start", Map.of(
            "taskId", task.getId(),
            "description", task.getDescription(),
            "requiredAgents", task.getRequiredAgentTypes()
        ));
        
        // åˆ›å»ºå¹¶æ³¨å†Œæ‰€éœ€çš„Agent
        List<Agent> agents = createRequiredAgents(task, context);
        agents.forEach(agent -> communicationBus.registerAgent(agent.getId(), agent));
        
        // å¯åŠ¨åä½œå¯è§†åŒ–
        visualizer.visualizeCollaboration(requestId, agents, printer);
        
        // åˆ†é…ä»»åŠ¡ç»™å„ä¸ªAgent
        distributeTasksWithStreaming(task, agents, printer);
        
        // ç›‘æ§åä½œè¿›åº¦
        monitorCollaborationProgress(requestId, agents, printer);
    }

    private void distributeTasksWithStreaming(CollaborativeTask task, 
                                           List<Agent> agents, 
                                           Printer printer) {
        List<SubTask> subTasks = task.decomposeToSubTasks();
        
        for (int i = 0; i < subTasks.size(); i++) {
            SubTask subTask = subTasks.get(i);
            Agent assignedAgent = findBestAgent(subTask, agents);
            
            // æµå¼å‘é€ä»»åŠ¡åˆ†é…ä¿¡æ¯
            printer.send("task_assignment", Map.of(
                "subTaskId", subTask.getId(),
                "description", subTask.getDescription(),
                "assignedAgent", assignedAgent.getId(),
                "priority", subTask.getPriority(),
                "dependencies", subTask.getDependencies()
            ));
            
            // å‘é€ä»»åŠ¡ç»™Agent
            AgentMessage taskMessage = AgentMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .fromAgent("orchestrator")
                .toAgent(assignedAgent.getId())
                .messageType("task_assignment")
                .data(subTask)
                .timestamp(System.currentTimeMillis())
                .requestId(task.getRequestId())
                .build();
                
            communicationBus.sendMessage(taskMessage);
        }
    }

    private void monitorCollaborationProgress(String requestId, 
                                           List<Agent> agents, 
                                           Printer printer) {
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        
        monitor.scheduleAtFixedRate(() -> {
            // æ”¶é›†å„AgentçŠ¶æ€
            Map<String, AgentStatus> agentStatuses = agents.stream()
                .collect(Collectors.toMap(Agent::getId, Agent::getStatus));
            
            // è®¡ç®—æ•´ä½“è¿›åº¦
            double overallProgress = calculateOverallProgress(agentStatuses);
            
            // æµå¼å‘é€è¿›åº¦æ›´æ–°
            printer.send("collaboration_progress", Map.of(
                "overallProgress", overallProgress,
                "agentStatuses", agentStatuses,
                "timestamp", System.currentTimeMillis()
            ));
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (isCollaborationComplete(agentStatuses)) {
                printer.send("collaboration_complete", Map.of(
                    "completionTime", System.currentTimeMillis(),
                    "finalResults", collectFinalResults(agents)
                ));
                monitor.shutdown();
            }
            
        }, 5, 5, TimeUnit.SECONDS); // æ¯5ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦
    }
}
```

## æµå¼Tokenè®¡æ•°ä¸é™æµæ§åˆ¶

### å®æ—¶Tokenæ¶ˆè€—ç›‘æ§

```java
@Component
public class TokenMonitor {
    private final Map<String, TokenUsageTracker> sessionTrackers = new ConcurrentHashMap<>();
    private final TokenLimitConfig limitConfig;

    public TokenUsageTracker getOrCreateTracker(String requestId) {
        return sessionTrackers.computeIfAbsent(requestId, 
            k -> new TokenUsageTracker(k, limitConfig));
    }

    @EventListener
    public void handleTokenUsage(TokenUsageEvent event) {
        TokenUsageTracker tracker = getOrCreateTracker(event.getRequestId());
        tracker.addUsage(event.getTokens(), event.getModel());
        
        // æµå¼å‘é€Tokenä½¿ç”¨æƒ…å†µ
        if (event.getPrinter() != null) {
            event.getPrinter().send("token_usage", Map.of(
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit(),
                "percentage", tracker.getUsagePercentage(),
                "model", event.getModel(),
                "timestamp", System.currentTimeMillis()
            ));
        }
        
        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘é™åˆ¶
        if (tracker.isNearLimit(0.9)) { // 90%
            event.getPrinter().send("token_warning", Map.of(
                "message", "Tokenä½¿ç”¨é‡å·²è¾¾åˆ°90%",
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit()
            ));
        }
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if (tracker.isOverLimit()) {
            throw new TokenLimitExceeded(event.getRequestId(), 
                tracker.getCurrentUsage(), tracker.getLimit());
        }
    }

    public void cleanupTracker(String requestId) {
        sessionTrackers.remove(requestId);
    }
}

public class TokenUsageTracker {
    private final String requestId;
    private final TokenLimitConfig limitConfig;
    private final Map<String, AtomicLong> modelUsage = new ConcurrentHashMap<>();
    private final AtomicLong totalUsage = new AtomicLong(0);

    public void addUsage(long tokens, String model) {
        modelUsage.computeIfAbsent(model, k -> new AtomicLong(0)).addAndGet(tokens);
        totalUsage.addAndGet(tokens);
    }

    public boolean isNearLimit(double threshold) {
        return getUsagePercentage() >= threshold * 100;
    }

    public boolean isOverLimit() {
        return totalUsage.get() > limitConfig.getMaxTokensPerSession();
    }

    public double getUsagePercentage() {
        return (double) totalUsage.get() / limitConfig.getMaxTokensPerSession() * 100;
    }

    public long getCurrentUsage() {
        return totalUsage.get();
    }

    public long getLimit() {
        return limitConfig.getMaxTokensPerSession();
    }

    public Map<String, Long> getModelUsageBreakdown() {
        return modelUsage.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> entry.getValue().get()
            ));
    }
}
```

### åŠ¨æ€é™æµç­–ç•¥

```java
@Component
public class AdaptiveThrottleController {
    private final TokenMonitor tokenMonitor;
    private final Map<String, ThrottleState> sessionThrottles = new ConcurrentHashMap<>();

    public void checkAndApplyThrottle(String requestId, Printer printer) {
        TokenUsageTracker tracker = tokenMonitor.getOrCreateTracker(requestId);
        ThrottleState throttle = sessionThrottles.computeIfAbsent(requestId, 
            k -> new ThrottleState());

        double usagePercentage = tracker.getUsagePercentage();
        
        if (usagePercentage > 95) {
            // ä¸¥é‡é™æµï¼šæš‚åœæ‰€æœ‰éå…³é”®æ“ä½œ
            throttle.setLevel(ThrottleLevel.SEVERE);
            printer.send("throttle_applied", Map.of(
                "level", "severe",
                "message", "Tokenä½¿ç”¨é‡è¿‡é«˜ï¼Œæš‚åœéå…³é”®æ“ä½œ",
                "estimatedDelay", "30-60ç§’"
            ));
            
        } else if (usagePercentage > 80) {
            // ä¸­ç­‰é™æµï¼šå»¶é•¿æ“ä½œé—´éš”
            throttle.setLevel(ThrottleLevel.MODERATE);
            printer.send("throttle_applied", Map.of(
                "level", "moderate", 
                "message", "é€‚åº¦é™ä½å¤„ç†é€Ÿåº¦ä»¥æ§åˆ¶Tokenæ¶ˆè€—",
                "slowdownFactor", 2.0
            ));
            
        } else if (usagePercentage > 60) {
            // è½»å¾®é™æµï¼šä¼˜åŒ–è¯·æ±‚
            throttle.setLevel(ThrottleLevel.LIGHT);
            printer.send("throttle_applied", Map.of(
                "level", "light",
                "message", "å¼€å¯Tokenä¼˜åŒ–æ¨¡å¼",
                "optimization", "enabled"
            ));
        }

        // åº”ç”¨é™æµå»¶è¿Ÿ
        if (throttle.getLevel() != ThrottleLevel.NONE) {
            long delayMs = calculateThrottleDelay(throttle.getLevel(), usagePercentage);
            if (delayMs > 0) {
                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private long calculateThrottleDelay(ThrottleLevel level, double usagePercentage) {
        switch (level) {
            case LIGHT:
                return Math.round(500 * (usagePercentage / 100)); // 0-5ç§’
            case MODERATE:
                return Math.round(2000 * (usagePercentage / 100)); // 0-20ç§’  
            case SEVERE:
                return Math.round(10000 * (usagePercentage / 100)); // 0-100ç§’
            default:
                return 0;
        }
    }
}

enum ThrottleLevel {
    NONE, LIGHT, MODERATE, SEVERE
}

@Data
class ThrottleState {
    private ThrottleLevel level = ThrottleLevel.NONE;
    private long lastThrottleTime = 0;
    private int consecutiveThrottles = 0;
}
```

## Agentæ‰§è¡Œè¿›åº¦çš„å¯è§†åŒ–å±•ç¤º

### è¿›åº¦å¯è§†åŒ–ç»„ä»¶

```typescript
interface AgentProgress {
    agentId: string;
    agentType: string;
    currentStep: string;
    totalSteps: number;
    completedSteps: number;
    progress: number;
    status: 'idle' | 'running' | 'completed' | 'error';
    lastUpdate: number;
    estimatedTimeRemaining?: number;
}

interface CollaborationState {
    requestId: string;
    agents: AgentProgress[];
    overallProgress: number;
    activeConnections: Array<{
        from: string;
        to: string;
        type: string;
        timestamp: number;
    }>;
    timeline: Array<{
        timestamp: number;
        event: string;
        agent?: string;
        details: any;
    }>;
}

export const AgentCollaborationDashboard: React.FC<{
  requestId: string;
}> = ({ requestId }) => {
  const [collaborationState, setCollaborationState] = useState<CollaborationState | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const sseClient = new AdvancedSSEClient({
      body: { requestId, agentType: 'collaboration' },
      handleMessage: (message) => {
        handleCollaborationMessage(message);
      },
      handleError: (error) => {
        console.error('åä½œç›‘æ§è¿æ¥é”™è¯¯:', error);
        setIsConnected(false);
      },
      handleClose: () => {
        setIsConnected(false);
      }
    });

    sseClient.connect('/web/api/v1/agent/collaboration/stream');
    setIsConnected(true);

    return () => {
      sseClient.disconnect();
    };
  }, [requestId]);

  const handleCollaborationMessage = (message: any) => {
    switch (message.messageType) {
      case 'collaboration_init':
        setCollaborationState({
          requestId: message.requestId,
          agents: message.agents.map(formatAgentProgress),
          overallProgress: 0,
          activeConnections: [],
          timeline: []
        });
        break;

      case 'collaboration_progress':
        setCollaborationState(prev => prev ? {
          ...prev,
          agents: updateAgentProgress(prev.agents, message.agentStatuses),
          overallProgress: message.overallProgress
        } : null);
        break;

      case 'agent_communication':
        setCollaborationState(prev => prev ? {
          ...prev,
          activeConnections: [
            ...prev.activeConnections.slice(-10), // ä¿ç•™æœ€è¿‘10ä¸ªè¿æ¥
            {
              from: message.fromAgent,
              to: message.toAgent,
              type: message.messageType,
              timestamp: message.timestamp
            }
          ],
          timeline: [
            ...prev.timeline,
            {
              timestamp: message.timestamp,
              event: 'agent_communication',
              agent: message.fromAgent,
              details: {
                to: message.toAgent,
                type: message.messageType,
                summary: message.summary
              }
            }
          ]
        } : null);
        break;

      case 'task_assignment':
        setCollaborationState(prev => prev ? {
          ...prev,
          timeline: [
            ...prev.timeline,
            {
              timestamp: Date.now(),
              event: 'task_assignment',
              agent: message.assignedAgent,
              details: {
                taskId: message.subTaskId,
                description: message.description,
                priority: message.priority
              }
            }
          ]
        } : null);
        break;
    }
  };

  if (!collaborationState) {
    return <div className="loading">åˆå§‹åŒ–åä½œç›‘æ§...</div>;
  }

  return (
    <div className="collaboration-dashboard">
      {/* æ•´ä½“è¿›åº¦ */}
      <div className="overall-progress">
        <h3>æ•´ä½“è¿›åº¦</h3>
        <ProgressRing 
          progress={collaborationState.overallProgress} 
          size={120}
          strokeWidth={8}
        />
        <div className="status-indicator">
          <StatusDot connected={isConnected} />
          <span>{isConnected ? 'å·²è¿æ¥' : 'è¿æ¥æ–­å¼€'}</span>
        </div>
      </div>

      {/* AgentçŠ¶æ€ç½‘æ ¼ */}
      <div className="agents-grid">
        {collaborationState.agents.map(agent => (
          <AgentCard key={agent.agentId} agent={agent} />
        ))}
      </div>

      {/* åä½œå›¾ */}
      <div className="collaboration-graph">
        <h3>Agentåä½œå…³ç³»</h3>
        <CollaborationNetwork 
          agents={collaborationState.agents}
          connections={collaborationState.activeConnections}
        />
      </div>

      {/* æ—¶é—´çº¿ */}
      <div className="timeline">
        <h3>æ‰§è¡Œæ—¶é—´çº¿</h3>
        <Timeline events={collaborationState.timeline} />
      </div>
    </div>
  );
};

const AgentCard: React.FC<{ agent: AgentProgress }> = ({ agent }) => {
  return (
    <div className={`agent-card ${agent.status}`}>
      <div className="agent-header">
        <div className="agent-icon">{getAgentIcon(agent.agentType)}</div>
        <div className="agent-info">
          <h4>{agent.agentId}</h4>
          <span className="agent-type">{agent.agentType}</span>
        </div>
        <StatusBadge status={agent.status} />
      </div>
      
      <div className="agent-progress">
        <div className="progress-bar">
          <div 
            className="progress-fill" 
            style={{ width: `${agent.progress}%` }}
          />
        </div>
        <span className="progress-text">
          {agent.completedSteps}/{agent.totalSteps} æ­¥éª¤
        </span>
      </div>
      
      <div className="current-step">
        <span>å½“å‰: {agent.currentStep}</span>
        {agent.estimatedTimeRemaining && (
          <span className="time-remaining">
            é¢„è®¡å‰©ä½™: {formatDuration(agent.estimatedTimeRemaining)}
          </span>
        )}
      </div>
    </div>
  );
};
```

## å°ç»“

AI-Agentä¸­çš„æµå¼äº¤äº’æ¨¡å¼å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **çŠ¶æ€æµå¼åé¦ˆ**ï¼šAgentæ‰§è¡Œçš„æ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦å®æ—¶åé¦ˆç»™ç”¨æˆ·
2. **å·¥å…·è°ƒç”¨é€æ˜åŒ–**ï¼šå·¥å…·æ‰§è¡Œè¿‡ç¨‹å’Œç»“æœéœ€è¦å¢é‡ä¼ è¾“
3. **å¤šAgentåä½œå¯è§†åŒ–**ï¼šå¤æ‚çš„åä½œå…³ç³»éœ€è¦å®æ—¶å±•ç¤º
4. **Tokenä½¿ç”¨ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å’Œæ§åˆ¶Tokenæ¶ˆè€—
5. **è¿›åº¦å¯è§†åŒ–**ï¼šæä¾›ç›´è§‚çš„æ‰§è¡Œè¿›åº¦å’ŒçŠ¶æ€å±•ç¤º

è¿™äº›æ¨¡å¼ä½¿ç”¨æˆ·èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£AI Agentçš„"æ€è€ƒ"å’Œæ‰§è¡Œè¿‡ç¨‹ï¼Œæä¾›äº†å‰æ‰€æœªæœ‰çš„é€æ˜åº¦å’Œäº¤äº’ä½“éªŒã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨å¦‚ä½•ä¼˜åŒ–æµå¼é€šä¿¡çš„æ€§èƒ½å¹¶å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ã€‚

---

**æœ¬èŠ‚å…³é”®è¦ç‚¹ï¼š**
- Agentç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„æµå¼åé¦ˆæœºåˆ¶
- å·¥å…·è°ƒç”¨ç»“æœçš„å¢é‡ä¼ è¾“ç­–ç•¥
- å¤šAgentåä½œçš„å®æ—¶é€šä¿¡å’Œå¯è§†åŒ–
- æµå¼Tokenè®¡æ•°å’ŒåŠ¨æ€é™æµæ§åˆ¶
- Agentæ‰§è¡Œè¿›åº¦çš„å¯è§†åŒ–å±•ç¤ºæ–¹æ¡ˆ
