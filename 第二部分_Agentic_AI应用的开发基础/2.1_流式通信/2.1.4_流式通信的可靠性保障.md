# 2.1.4 流式通信的可靠性保障

**学习目标：** 掌握保障流式通信稳定性的关键技术，学会处理各种异常情况

## 1. 概述


心跳机制是SSE流式通信中最基础也是最重要的连接保活技术。通过定期发送心跳消息，系统能够有效维持长连接稳定性，防止网络代理或负载均衡器因空闲超时而断开连接。

**设计目标：**
1. **连接活性检测**：及时发现连接断开，避免"假死"连接
2. **中间设备保活**：防止代理服务器、防火墙、NAT设备关闭空闲连接  
3. **网络质量监控**：通过心跳响应时间监测网络延迟和稳定性
4. **资源管理触发**：为连接清理和故障转移提供准确的触发信号


JoyAgent-JDGenie项目展示了**两种截然不同的心跳实现策略**，体现了分布式系统中技术选型的多样性：

- **库内置心跳**（Python工具服务）：基于`sse_starlette`库的`ping_message_factory`参数，简单配置自动管理
- **手动实现心跳**（Java后端服务）：基于`ScheduledExecutorService`线程池，完全自主控制生命周期

这两种方式分别代表了**"开发效率优先"**与**"精确控制优先"**的技术哲学，为不同的业务场景提供了最适配的解决方案。

#### Python工具服务心跳实现

```python
# genie-tool/genie_tool/api/tool.py
from sse_starlette import ServerSentEvent, EventSourceResponse

@router.post("/code_interpreter")
async def post_code_interpreter(body: CIRequest):
    """代码解释器工具接口"""

    ....接口逻辑
    if body.stream:
        # sse_starlette库内置心跳机制：库自动管理
        return EventSourceResponse(
            _stream(),
            ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
            ping=15,  # 每15秒自动发送心跳
        )

@router.post("/report")  
async def post_report(body: ReportRequest):
    """报告生成工具接口"""
    # 同样使用sse_starlette的心跳机制
    return EventSourceResponse(
        _stream(),
        ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
        ping=15,
    )
```

**Python异步心跳特点**：
- **专业库支持**：sse_starlette是ASGI生态的专业SSE库，EventSourceResponse自动处理心跳
- **零配置**：仅需指定间隔时间和心跳工厂函数，无需复杂设置
- **异步原生**：基于Starlette/FastAPI的ASGI异步架构，与asyncio事件循环完美集成
- **自动清理**：连接结束时库自动停止心跳，避免资源泄漏


#### Java后端心跳实现

```java
// genie-backend/src/main/java/com/jd/genie/controller/GenieController.java
@RestController
public class GenieController {
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
    private static final long HEARTBEAT_INTERVAL = 10_000L; // 10秒心跳间隔

    /**
     * 开启SSE心跳机制
     * @param emitter SSE发射器
     * @param requestId 请求唯一标识
     * @return 心跳任务句柄
     */
    private ScheduledFuture<?> startHeartbeat(SseEmitter emitter, String requestId) {
        return executor.scheduleAtFixedRate(() -> {
            try {
                // 发送心跳消息，保持连接活跃
                log.debug("{} send heartbeat", requestId);
                emitter.send("heartbeat");
                
            } catch (IllegalStateException e) {
                // 连接已关闭异常：SseEmitter已经完成或超时
                log.warn("{} connection already closed: {}", requestId, e.getMessage());
                throw new RuntimeException("Connection closed", e); // 停止心跳任务
                
            } catch (IOException e) {
                // IO异常：网络断开、用户关闭浏览器、代理服务器断开连接
                log.error("{} heartbeat IO error, triggering onError: {}", requestId, e.getMessage());
                emitter.completeWithError(e); // 触发onError事件监听器
                throw new RuntimeException("Heartbeat failed", e); // 停止心跳任务
                
            } catch (Exception e) {
                // 其他未预期异常
                log.error("{} unexpected heartbeat error", requestId, e);
                emitter.completeWithError(e);
                throw new RuntimeException("Heartbeat failed", e);
            }
        }, HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL, TimeUnit.MILLISECONDS);
    }
}
```

**Java手动心跳特点**：
- **完全控制**：手动实现心跳线程池
- **精确异常处理**：区分IOException、IllegalStateException等不同异常类型
- **资源管理**：需要手动取消心跳任务，防止资源泄漏
- **灵活定制**：可以携带业务信息、动态调整间隔

#### 两种心跳实现机制对比

| 维度 | Python (genie-tool) | Java (genie-backend) | 说明 |
|------|-------------------|---------------------|------|
| **实现复杂度** | ✅ 一行配置 | ❌ 需要60+行代码 | sse_starlette封装 vs Spring原生 |
| **资源管理** | ✅ 框架自动 | ❌ 手动管理线程池 | asyncio vs ScheduledExecutorService |
| **异常处理** | ✅ 框架处理 | ❌ 需详细编写 | 内置容错 vs 手动容错 |
| **性能开销** | ✅ 单线程事件循环 | ❌ 多线程上下文切换 | 异步 vs 同步模型 |
| **定制化程度** | ❌ 受框架限制 | ✅ 完全自主控制 | 便利性 vs 灵活性 |
| **心跳间隔** | 15秒 | 10秒 | 可配置但默认不同 |
| **错误恢复** | ✅ 自动重连 | ❌ 需手动实现 | 框架能力差异 |

#### 前端心跳处理

```typescript
// ui/src/components/ChatView/index.tsx
const handleMessage = (data: MESSAGE.Answer) => {
    const { finished, resultMap, packageType, status } = data;
    
    // 关键：过滤心跳消息，避免无效渲染
    if (packageType !== "heartbeat") {
        requestAnimationFrame(() => {
            if (resultMap?.eventData) {
                // 处理实际业务数据
                currentChat = combineData(resultMap.eventData || {}, currentChat);
                // ...业务逻辑处理
            }
        });
    }
    // 心跳消息被静默处理，不触发UI更新
};
```

### 2.2 心跳机制的关键技术特性

#### 2.2.1 精确的时间控制

10秒的心跳间隔是经过生产环境验证的最佳实践配置：
- **过短间隔**（<5秒）：增加网络开销，影响系统性能
- **过长间隔**（>30秒）：可能被代理服务器提前断开
- **10秒配置**：平衡性能与稳定性，适应大多数网络环境


#### 2.3.2 网络代理环境适配

心跳机制特别针对企业网络环境中的各种代理服务器进行了优化：

| 代理类型 | 默认空闲超时 | 心跳间隔适配 | 兼容性 |
|:----:|:----:|:----:|:----:|
| Nginx | 60秒 | 10秒心跳 | ✅ 完全兼容 |
| Apache | 300秒 | 10秒心跳 | ✅ 完全兼容 |
| ALB/ELB | 60秒 | 10秒心跳 | ✅ 完全兼容 |
| CDN | 30-120秒 | 10秒心跳 | ✅ 完全兼容 |
| 企业网关 | 15-30秒 | 10秒心跳 | ✅ 完全兼容 |

---


### SSE事件监听器

SSE连接的事件监听器是防止资源泄漏和确保系统稳定性的关键机制。在JoyAgent-JDGenie项目中，每个SSE连接都伴随着心跳任务，如果不正确处理连接生命周期，会导致严重的资源泄漏问题。

##### **核心问题：心跳任务的生命周期管理**

**问题场景**：
```java
// 危险情况：连接已断开，但心跳线程仍在运行
SseEmitter emitter = new SseEmitter(timeout);
ScheduledFuture<?> heartbeat = startHeartbeat(emitter, requestId);

// 如果用户关闭浏览器或网络中断，SSE连接断开
// 但没有人告诉心跳任务停止，它会继续尝试发送：
emitter.send("heartbeat"); // 抛出IllegalStateException
// 结果：线程池被占用，内存泄漏，系统性能下降
```

**影响**：
- **线程池资源耗尽**：未取消的心跳任务持续占用线程
- **内存泄漏**：SseEmitter对象无法被垃圾回收
- **日志爆炸**：心跳失败产生大量异常日志
- **系统性能下降**：无效的心跳尝试消耗CPU资源

##### **解决方案：完整的事件监听机制**

```java
// SSE连接异常处理策略
private void registerSSEMonitor(SseEmitter emitter, String requestId, 
                                ScheduledFuture<?> heartbeatFuture) {
    
    // 正常完成：清理心跳任务
    emitter.onCompletion(() -> {
        log.info("{} SSE connection completed normally", requestId);
        heartbeatFuture.cancel(true); // 关键：立即停止心跳任务
        // 防止：智能体任务完成后，心跳任务继续无意义运行
    });

    // 超时处理：主动完成连接，而不是让它悬挂
    emitter.onTimeout(() -> {
        log.info("{} SSE connection timed out", requestId);
        heartbeatFuture.cancel(true); // 关键：避免超时后心跳任务继续运行
        emitter.complete(); // 优雅关闭，通知前端连接结束
        // 防止：连接超时但前端不知道，无法触发重连
    });

    // 错误处理：立即终止连接和心跳，带错误信息完成，便于前端重连
    emitter.onError((ex) -> {
        log.error("{} SSE connection error: ", requestId, ex);
        heartbeatFuture.cancel(true); // 关键：错误时立即停止心跳避免级联错误
        emitter.completeWithError(ex); // 错误信息传递给前端，触发重连逻辑
        // 防止：网络错误导致连接断开，但前端不知道具体错误原因
    });
}
```

##### **事件监听器的三重保障机制**

| 事件类型 | 触发场景 | 技术原理 | 处理策略 | 防止的问题 |
|---------|----------|----------|----------|-----------|
| **onCompletion** | 智能体任务正常完成 | emitter.complete()被调用 | 取消心跳+日志记录 | 任务完成后心跳任务继续运行 |
| **onTimeout** | 连接超时(1小时无数据) | SseEmitter内部超时检测 | 取消心跳+主动关闭 | 僵死连接占用资源+前端无感知 |
| **onError** | IO异常/连接断开 | IOException捕获 | 取消心跳+错误传递 | 断开连接继续心跳+前端无法重连 |

**详细触发条件说明**：

- **onError触发时机**：
  - 用户关闭浏览器 → TCP连接断开 → 心跳发送IOException → onError
  - 网络中断 → 数据传输失败 → IOException → onError  
  - 代理服务器强制断开 → 连接重置 → ConnectionResetException → onError

- **onTimeout触发时机**：
  - 连接建立1小时后，如果没有任何数据发送（包括心跳）
  - 实际场景中很少触发，因为10秒心跳会持续发送数据

- **onCompletion触发时机**：
  - 业务逻辑主动调用emitter.complete()
  - 智能体任务正常结束时的标准流程

##### **实际生产场景的价值**

**场景1：用户关闭浏览器**
```java
// 技术细节：用户关闭浏览器时的事件触发机制
// 
// 1. 用户关闭浏览器标签页
// 2. 客户端发送TCP FIN包，连接关闭
// 3. 服务端检测方式和触发事件：
//    - 情况A：立即检测到连接关闭 → 触发onError (ConnectionResetException)
//    - 情况B：心跳发送时检测到 → startHeartbeat中catch IOException → 触发onError  
//    - 情况C：长时间无活动且无心跳 → 触发onTimeout (少见)
//
// 在JoyAgent-JDGenie中：由于10秒心跳机制，最多10秒内必定触发onError

// 没有事件监听器的危险：
// 1. 用户关闭浏览器标签页
// 2. 10秒后心跳任务检测到IOException，但没有清理机制
// 3. 心跳任务继续运行，每10秒产生一次IOException
// 4. 1小时后积累360次异常，线程和内存泄漏

// 有事件监听器的正确处理：
// 1. 用户关闭浏览器标签页  
// 2. 心跳任务发送时触发IOException → emitter.completeWithError() → onError
// 3. onError立即取消心跳任务，释放所有资源
// 4. 系统保持健康状态，无资源泄漏
```

**场景2：网络抖动恢复**
```java
// 智能体执行45分钟的复杂任务过程中发生网络抖动：
// 
// 时间线：
// 0min:    建立SSE连接，开始智能体任务
// 30min:   网络短暂中断(5秒)
// 30min5s: 网络恢复
//
// 没有事件监听器：断开的连接无法清理，新连接建立但旧连接占用资源
// 有事件监听器：断开时onError立即清理，前端收到错误信息后重连
```

##### **资源清理的完整性保障**

```java
/**
 * 确保无论何种情况下，心跳任务都能被正确清理
 * 这是防止生产环境资源泄漏的关键机制
 */
private void ensureHeartbeatCleanup(ScheduledFuture<?> heartbeatFuture) {
    // 所有事件处理器都必须执行此操作
    if (heartbeatFuture != null && !heartbeatFuture.isCancelled()) {
        heartbeatFuture.cancel(true); // 立即中断心跳线程
        log.debug("Heartbeat task cancelled successfully");
    }
}
```

**总结**：事件监听器不仅仅是"良好实践"，而是**生产环境稳定性的必需品**。它确保了SSE连接的每一种结束方式都能正确清理资源，避免了内存泄漏和线程池耗尽等严重问题。


### 服务端心跳实现

让我们分析项目中的心跳机制实现：


```java
@RestController
public class GenieController {
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
    private static final long HEARTBEAT_INTERVAL = 10_000L; // 10秒心跳间隔

    /**
     * 启动SSE心跳机制
     */
    private ScheduledFuture<?> startHeartbeat(SseEmitter emitter, String requestId) {
        return executor.scheduleAtFixedRate(() -> {
            try {
                // 发送心跳消息
                log.info("{} 发送心跳", requestId);
                emitter.send("heartbeat");
            } catch (Exception e) {
                // 发送心跳失败，说明连接已断开
                log.error("{} 心跳发送失败，关闭连接", requestId, e);
                emitter.completeWithError(e);
            }
        }, HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL, TimeUnit.MILLISECONDS);
    }

    /**
     * 注册SSE事件监听器
     */
    private void registerSSEMonitor(SseEmitter emitter, String requestId, ScheduledFuture<?> heartbeatFuture) {
        // 正常完成监听
        emitter.onCompletion(() -> {
            log.info("{} SSE连接正常完成", requestId);
            heartbeatFuture.cancel(true);
            // 清理相关资源
            cleanupResources(requestId);
        });

        // 超时监听
        emitter.onTimeout(() -> {
            log.info("{} SSE连接超时", requestId);
            heartbeatFuture.cancel(true);
            emitter.complete();
        });

        // 错误监听
        emitter.onError((ex) -> {
            log.info("{} SSE连接错误: ", requestId, ex);
            heartbeatFuture.cancel(true);
            emitter.completeWithError(ex);
        });
    }

    private void cleanupResources(String requestId) {
        // 清理缓存数据
        // 释放临时文件
        // 停止后台任务等
    }
}
```

### 客户端心跳处理

客户端需要正确处理服务端发送的心跳消息，并监控心跳的连续性：

```typescript
class HeartbeatMonitor {
    private lastHeartbeatTime: number = Date.now();
    private heartbeatTimeout: NodeJS.Timeout | null = null;
    private maxHeartbeatInterval: number;
    private onHeartbeatTimeout: () => void;

    constructor(maxInterval: number = 30000, onTimeout: () => void) {
        this.maxHeartbeatInterval = maxInterval;
        this.onHeartbeatTimeout = onTimeout;
        this.startMonitoring();
    }

    // 接收到心跳时调用
    onHeartbeatReceived() {
        this.lastHeartbeatTime = Date.now();
        this.resetTimeout();
    }

    private startMonitoring() {
        this.resetTimeout();
    }

    private resetTimeout() {
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }

        this.heartbeatTimeout = setTimeout(() => {
            const timeSinceLastHeartbeat = Date.now() - this.lastHeartbeatTime;
            
            if (timeSinceLastHeartbeat > this.maxHeartbeatInterval) {
                console.warn(`心跳超时: ${timeSinceLastHeartbeat}ms`);
                this.onHeartbeatTimeout();
            }
        }, this.maxHeartbeatInterval);
    }

    stop() {
        if (this.heartbeatTimeout) {
            clearTimeout(this.heartbeatTimeout);
        }
    }

    getLastHeartbeatTime(): number {
        return this.lastHeartbeatTime;
    }

    isHealthy(): boolean {
        return (Date.now() - this.lastHeartbeatTime) < this.maxHeartbeatInterval;
    }
}
```

### 双向心跳机制

在需要检测客户端状态的场景中，可以实现双向心跳：

```typescript
class BidirectionalHeartbeat {
    private sendInterval: NodeJS.Timeout | null = null;
    private receiveMonitor: HeartbeatMonitor;
    private sendHeartbeat: () => void;

    constructor(
        sendIntervalMs: number = 30000,
        maxReceiveIntervalMs: number = 45000,
        sendCallback: () => void,
        onReceiveTimeout: () => void
    ) {
        this.sendHeartbeat = sendCallback;
        this.receiveMonitor = new HeartbeatMonitor(maxReceiveIntervalMs, onReceiveTimeout);
        
        // 启动发送心跳
        this.startSending(sendIntervalMs);
    }

    private startSending(intervalMs: number) {
        this.sendInterval = setInterval(() => {
            try {
                this.sendHeartbeat();
            } catch (error) {
                console.error('发送心跳失败:', error);
            }
        }, intervalMs);
    }

    onHeartbeatReceived() {
        this.receiveMonitor.onHeartbeatReceived();
    }

    stop() {
        if (this.sendInterval) {
            clearInterval(this.sendInterval);
        }
        this.receiveMonitor.stop();
    }

    getStatus() {
        return {
            isHealthy: this.receiveMonitor.isHealthy(),
            lastHeartbeatTime: this.receiveMonitor.getLastHeartbeatTime()
        };
    }
}
```


## 3. 重连机制：网络中断的智能恢复

### 3.1 前端自动重连策略
JoyAgent-JDGenie采用基于`@microsoft/fetch-event-source`库的增强重连机制，提供比浏览器原生EventSource更强大的重连能力。

## 连接断线重连策略

#### 3.1.2 fetch-event-source内置重连机制
需要重试的错误类型：
网络错误（连接失败、超时）
HTTP 5xx 服务器错误
HTTP 429（Too Many Requests）
连接意外关闭

不会重试的错误：
HTTP 4xx 客户端错误（401、403、404等）
用户手动取消
解析错误
```typescript
// ui/src/utils/querySSE.ts
import { fetchEventSource, EventSourceMessage } from '@microsoft/fetch-event-source';

export default (config: SSEConfig, url: string = DEFAULT_SSE_URL): void => {
    const { body, handleMessage, handleError, handleClose } = config;

    fetchEventSource(url, {
        method: 'POST',
        credentials: 'include',
        headers: SSE_HEADERS,
        body: JSON.stringify(body),
        openWhenHidden: true, // 页面隐藏时保持连接
        
        // 连接建立处理
        async onopen(response) {
            if (response.ok && response.headers.get('content-type') === 'text/event-stream') {
                return; // 连接成功，继续处理
            } else if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                // 4xx错误（除429）：客户端错误，不重试
                // 注意：虽然也是throw Error，但fetch-event-source库会根据错误消息判断重试策略
                // "Client error"消息会被库识别为永久性错误，不会触发重试
                // 原因：401(认证失败)、403(权限不足)、404(路径错误)等重试无意义
                throw new Error(`Client error: ${response.status}`);
            } else {
                // 5xx错误或429：服务器错误，触发重试
                // "Server error"消息会被库识别为临时性错误，会触发自动重试
                // 原因：500(服务器内部错误)、502(网关错误)、503(服务不可用)等可能通过重试恢复
                throw new Error(`Server error: ${response.status}`);
            }
        },

        onmessage(event: EventSourceMessage) {
            if (event.data) {
                try {
                    const parsedData = JSON.parse(event.data);
                    handleMessage(parsedData);
                } catch (error) {
                    console.error('Error parsing SSE message:', error);
                    handleError(new Error('Failed to parse SSE message'));
                }
            }
        },

        onerror(error: Error) {
            console.error('SSE error:', error);
            handleError(error);
            // fetch-event-source会自动重连，无需手动处理
        },

        onclose() {
            console.log('SSE connection closed');
            handleClose();
        }
    });
};
```


### 指数退避重连算法

```typescript
interface ReconnectConfig {
    initialDelay: number;        // 初始重连延迟
    maxDelay: number;           // 最大重连延迟
    maxRetries: number;         // 最大重连次数
    backoffMultiplier: number;  // 退避倍数
    jitterRange: number;        // 抖动范围（0-1）
}

class ExponentialBackoffReconnect {
    private config: ReconnectConfig;
    private retryCount: number = 0;
    private reconnectTimer: NodeJS.Timeout | null = null;
    private isReconnecting: boolean = false;

    constructor(config: ReconnectConfig) {
        this.config = config;
    }

    async attemptReconnect(connectFn: () => Promise<void>): Promise<boolean> {
        if (this.isReconnecting || this.retryCount >= this.config.maxRetries) {
            return false;
        }

        this.isReconnecting = true;
        
        try {
            // 计算延迟时间
            const delay = this.calculateDelay();
            console.log(`第${this.retryCount + 1}次重连，延迟${delay}ms`);
            
            // 等待延迟
            await this.sleep(delay);
            
            // 尝试连接
            await connectFn();
            
            // 连接成功，重置重试计数
            this.retryCount = 0;
            this.isReconnecting = false;
            return true;
            
        } catch (error) {
            this.retryCount++;
            this.isReconnecting = false;
            
            console.error(`第${this.retryCount}次重连失败:`, error);
            
            if (this.retryCount >= this.config.maxRetries) {
                console.error('达到最大重连次数，停止重连');
                return false;
            }
            
            // 递归重试
            return this.attemptReconnect(connectFn);
        }
    }

    private calculateDelay(): number {
        // 基础延迟：初始延迟 * (退避倍数 ^ 重试次数)
        let delay = this.config.initialDelay * Math.pow(this.config.backoffMultiplier, this.retryCount);
        
        // 限制最大延迟
        delay = Math.min(delay, this.config.maxDelay);
        
        // 添加随机抖动，避免雷群效应
        if (this.config.jitterRange > 0) {
            const jitter = delay * this.config.jitterRange * Math.random();
            delay += jitter;
        }
        
        return Math.round(delay);
    }

    private sleep(ms: number): Promise<void> {
        return new Promise(resolve => {
            this.reconnectTimer = setTimeout(resolve, ms);
        });
    }

    cancel() {
        this.isReconnecting = false;
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }
    }

    reset() {
        this.retryCount = 0;
        this.cancel();
    }

    getStats() {
        return {
            retryCount: this.retryCount,
            isReconnecting: this.isReconnecting,
            maxRetries: this.config.maxRetries
        };
    }
}
```

### 智能重连策略

```typescript
enum DisconnectReason {
    NETWORK_ERROR = 'network_error',
    SERVER_ERROR = 'server_error', 
    CLIENT_ERROR = 'client_error',
    TIMEOUT = 'timeout',
    UNKNOWN = 'unknown'
}

class IntelligentReconnect {
    private reconnectStrategy: Map<DisconnectReason, ReconnectConfig> = new Map();
    private reconnector: ExponentialBackoffReconnect | null = null;
    private networkMonitor: NetworkMonitor;

    constructor() {
        this.initializeStrategies();
        this.networkMonitor = new NetworkMonitor();
    }

    private initializeStrategies() {
        // 网络错误：快速重连
        this.reconnectStrategy.set(DisconnectReason.NETWORK_ERROR, {
            initialDelay: 1000,
            maxDelay: 10000,
            maxRetries: 10,
            backoffMultiplier: 1.5,
            jitterRange: 0.2
        });

        // 服务器错误：保守重连
        this.reconnectStrategy.set(DisconnectReason.SERVER_ERROR, {
            initialDelay: 5000,
            maxDelay: 60000,
            maxRetries: 5,
            backoffMultiplier: 2,
            jitterRange: 0.3
        });

        // 客户端错误：不重连
        this.reconnectStrategy.set(DisconnectReason.CLIENT_ERROR, {
            initialDelay: 0,
            maxDelay: 0,
            maxRetries: 0,
            backoffMultiplier: 1,
            jitterRange: 0
        });

        // 超时：中等策略
        this.reconnectStrategy.set(DisconnectReason.TIMEOUT, {
            initialDelay: 2000,
            maxDelay: 30000,
            maxRetries: 8,
            backoffMultiplier: 2,
            jitterRange: 0.25
        });
    }

    async handleDisconnect(
        error: Error, 
        connectFn: () => Promise<void>
    ): Promise<boolean> {
        const reason = this.analyzeDisconnectReason(error);
        const config = this.reconnectStrategy.get(reason) || 
                       this.reconnectStrategy.get(DisconnectReason.UNKNOWN)!;

        console.log(`连接断开原因: ${reason}, 使用重连策略:`, config);

        // 如果是客户端错误，不重连
        if (reason === DisconnectReason.CLIENT_ERROR) {
            return false;
        }

        // 检查网络状态
        if (!await this.networkMonitor.isNetworkAvailable()) {
            console.log('网络不可用，等待网络恢复...');
            await this.networkMonitor.waitForNetwork();
        }

        // 执行重连
        this.reconnector = new ExponentialBackoffReconnect(config);
        return this.reconnector.attemptReconnect(connectFn);
    }

    private analyzeDisconnectReason(error: Error): DisconnectReason {
        const message = error.message.toLowerCase();

        if (message.includes('network') || message.includes('connection')) {
            return DisconnectReason.NETWORK_ERROR;
        }
        
        if (message.includes('timeout')) {
            return DisconnectReason.TIMEOUT;
        }

        if (message.includes('400') || message.includes('401') || message.includes('403')) {
            return DisconnectReason.CLIENT_ERROR;
        }

        if (message.includes('500') || message.includes('502') || message.includes('503')) {
            return DisconnectReason.SERVER_ERROR;
        }

        return DisconnectReason.UNKNOWN;
    }

    cancel() {
        this.reconnector?.cancel();
    }
}
```

### 网络状态监控

```typescript
class NetworkMonitor {
    private isOnline: boolean = navigator.onLine;
    private listeners: Set<(online: boolean) => void> = new Set();

    constructor() {
        this.setupEventListeners();
    }

    private setupEventListeners() {
        window.addEventListener('online', () => {
            console.log('网络连接已恢复');
            this.isOnline = true;
            this.notifyListeners(true);
        });

        window.addEventListener('offline', () => {
            console.log('网络连接已断开');
            this.isOnline = false;
            this.notifyListeners(false);
        });

        // 定期网络探测
        setInterval(() => {
            this.probeNetwork();
        }, 30000);
    }

    private async probeNetwork(): Promise<void> {
        try {
            // 发送轻量级探测请求
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            await fetch('/health', { 
                method: 'HEAD',
                signal: controller.signal,
                cache: 'no-cache'
            });

            clearTimeout(timeoutId);
            
            if (!this.isOnline) {
                this.isOnline = true;
                this.notifyListeners(true);
            }
        } catch (error) {
            if (this.isOnline) {
                this.isOnline = false;
                this.notifyListeners(false);
            }
        }
    }

    async isNetworkAvailable(): Promise<boolean> {
        if (!this.isOnline) {
            return false;
        }

        // 主动探测网络可用性
        try {
            await this.probeNetwork();
            return this.isOnline;
        } catch {
            return false;
        }
    }

    async waitForNetwork(timeoutMs: number = 60000): Promise<boolean> {
        if (this.isOnline) {
            return true;
        }

        return new Promise((resolve) => {
            const timeout = setTimeout(() => {
                this.removeListener(onlineListener);
                resolve(false);
            }, timeoutMs);

            const onlineListener = (online: boolean) => {
                if (online) {
                    clearTimeout(timeout);
                    this.removeListener(onlineListener);
                    resolve(true);
                }
            };

            this.addListener(onlineListener);
        });
    }

    addListener(listener: (online: boolean) => void) {
        this.listeners.add(listener);
    }

    removeListener(listener: (online: boolean) => void) {
        this.listeners.delete(listener);
    }

    private notifyListeners(online: boolean) {
        this.listeners.forEach(listener => {
            try {
                listener(online);
            } catch (error) {
                console.error('网络状态监听器执行失败:', error);
            }
        });
    }
}
```

## 超时处理与错误恢复

### 分层超时策略

```java
public class TimeoutConfiguration {
    
    // 连接建立超时
    public static final long CONNECTION_TIMEOUT = 10_000L; // 10秒
    
    // 读取超时
    public static final long READ_TIMEOUT = 30_000L; // 30秒
    
    // SSE流超时 
    public static final long SSE_TIMEOUT = 60 * 60 * 1000L; // 1小时
    
    // 心跳超时
    public static final long HEARTBEAT_TIMEOUT = 15_000L; // 15秒
    
    // 任务执行超时
    public static final long TASK_TIMEOUT = 30 * 60 * 1000L; // 30分钟
}

@Service
public class TimeoutManager {
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final Map<String, ScheduledFuture<?>> taskTimeouts = new ConcurrentHashMap<>();

    /**
     * 设置任务超时
     */
    public void setTaskTimeout(String requestId, long timeoutMs, Runnable timeoutAction) {
        // 取消之前的超时任务
        cancelTimeout(requestId);
        
        ScheduledFuture<?> future = scheduler.schedule(() -> {
            log.warn("任务超时: {}", requestId);
            taskTimeouts.remove(requestId);
            timeoutAction.run();
        }, timeoutMs, TimeUnit.MILLISECONDS);
        
        taskTimeouts.put(requestId, future);
    }

    /**
     * 取消超时任务
     */
    public void cancelTimeout(String requestId) {
        ScheduledFuture<?> future = taskTimeouts.remove(requestId);
        if (future != null && !future.isDone()) {
            future.cancel(false);
        }
    }

    /**
     * 延长超时时间
     */
    public void extendTimeout(String requestId, long additionalMs) {
        ScheduledFuture<?> future = taskTimeouts.get(requestId);
        if (future != null) {
            // 获取剩余时间并延长
            long remainingMs = future.getDelay(TimeUnit.MILLISECONDS);
            if (remainingMs > 0) {
                future.cancel(false);
                // 重新设置超时时间
                // 这里需要从原始的超时动作中获取回调，实际实现中需要存储这些信息
            }
        }
    }

    @PreDestroy
    public void shutdown() {
        taskTimeouts.values().forEach(future -> future.cancel(true));
        scheduler.shutdown();
    }
}
```

### 客户端超时处理

```typescript
interface TimeoutConfig {
    connection: number;
    message: number;
    heartbeat: number;
    total: number;
}

class ClientTimeoutManager {
    private config: TimeoutConfig;
    private timers: Map<string, NodeJS.Timeout> = new Map();
    private startTime: number = 0;

    constructor(config: TimeoutConfig) {
        this.config = config;
    }

    startSession() {
        this.startTime = Date.now();
        
        // 设置总体会话超时
        this.setTimer('session', this.config.total, () => {
            throw new Error('会话总体超时');
        });
    }

    onConnectionEstablished() {
        // 连接建立成功，清除连接超时
        this.clearTimer('connection');
        
        // 设置消息接收超时
        this.resetMessageTimeout();
    }

    onMessageReceived() {
        // 重置消息超时
        this.resetMessageTimeout();
        
        // 重置心跳超时
        this.resetHeartbeatTimeout();
    }

    onHeartbeatReceived() {
        // 重置心跳超时
        this.resetHeartbeatTimeout();
    }

    private resetMessageTimeout() {
        this.setTimer('message', this.config.message, () => {
            throw new Error('消息接收超时');
        });
    }

    private resetHeartbeatTimeout() {
        this.setTimer('heartbeat', this.config.heartbeat, () => {
            throw new Error('心跳超时');
        });
    }

    private setTimer(name: string, timeoutMs: number, callback: () => void) {
        this.clearTimer(name);
        
        const timer = setTimeout(() => {
            this.timers.delete(name);
            callback();
        }, timeoutMs);
        
        this.timers.set(name, timer);
    }

    private clearTimer(name: string) {
        const timer = this.timers.get(name);
        if (timer) {
            clearTimeout(timer);
            this.timers.delete(name);
        }
    }

    getElapsedTime(): number {
        return Date.now() - this.startTime;
    }

    getRemainingTime(): number {
        const elapsed = this.getElapsedTime();
        return Math.max(0, this.config.total - elapsed);
    }

    cleanup() {
        this.timers.forEach(timer => clearTimeout(timer));
        this.timers.clear();
    }
}
```

## 流式数据的完整性校验

### 消息序号机制

```java
public class StreamMessage {
    private String messageId;
    private Long sequenceNumber;
    private String requestId;
    private String messageType;
    private Object data;
    private String checksum;
    private Long timestamp;

    // 生成消息校验和
    public void generateChecksum() {
        String content = requestId + sequenceNumber + messageType + 
                        JSON.toJSONString(data) + timestamp;
        this.checksum = DigestUtils.md5DigestAsHex(content.getBytes());
    }

    // 验证消息完整性
    public boolean verifyChecksum() {
        String content = requestId + sequenceNumber + messageType + 
                        JSON.toJSONString(data) + timestamp;
        String calculatedChecksum = DigestUtils.md5DigestAsHex(content.getBytes());
        return Objects.equals(this.checksum, calculatedChecksum);
    }
}

@Component
public class StreamIntegrityManager {
    private final Map<String, AtomicLong> sequenceCounters = new ConcurrentHashMap<>();
    private final Map<String, Set<Long>> receivedMessages = new ConcurrentHashMap<>();

    /**
     * 生成下一个序号
     */
    public long getNextSequence(String requestId) {
        return sequenceCounters.computeIfAbsent(requestId, k -> new AtomicLong(0))
                               .incrementAndGet();
    }

    /**
     * 验证消息序号
     */
    public boolean verifySequence(String requestId, long sequenceNumber) {
        Set<Long> received = receivedMessages.computeIfAbsent(requestId, k -> new HashSet<>());
        
        // 检查是否重复
        if (received.contains(sequenceNumber)) {
            log.warn("检测到重复消息: requestId={}, sequence={}", requestId, sequenceNumber);
            return false;
        }
        
        received.add(sequenceNumber);
        return true;
    }

    /**
     * 检查消息缺失
     */
    public List<Long> findMissingSequences(String requestId, long maxSequence) {
        Set<Long> received = receivedMessages.get(requestId);
        if (received == null) {
            return Collections.emptyList();
        }

        List<Long> missing = new ArrayList<>();
        for (long i = 1; i <= maxSequence; i++) {
            if (!received.contains(i)) {
                missing.add(i);
            }
        }
        return missing;
    }

    /**
     * 清理会话数据
     */
    public void cleanup(String requestId) {
        sequenceCounters.remove(requestId);
        receivedMessages.remove(requestId);
    }
}
```

### 客户端数据校验

```typescript
interface MessageIntegrity {
    sequenceNumber: number;
    checksum: string;
    timestamp: number;
}

class ClientStreamVerifier {
    private expectedSequence: Map<string, number> = new Map();
    private receivedMessages: Map<string, Set<number>> = new Map();
    private missingMessages: Map<string, Set<number>> = new Map();

    verifyMessage(requestId: string, message: any): boolean {
        // 验证序号
        if (!this.verifySequence(requestId, message.sequenceNumber)) {
            return false;
        }

        // 验证校验和
        if (!this.verifyChecksum(message)) {
            console.error('消息校验和验证失败:', message);
            return false;
        }

        // 验证时间戳（防止重放攻击）
        if (!this.verifyTimestamp(message.timestamp)) {
            console.error('消息时间戳异常:', message);
            return false;
        }

        return true;
    }

    private verifySequence(requestId: string, sequenceNumber: number): boolean {
        const expected = this.expectedSequence.get(requestId) || 1;
        const received = this.receivedMessages.get(requestId) || new Set();

        if (sequenceNumber === expected) {
            // 正常的下一个消息
            received.add(sequenceNumber);
            this.receivedMessages.set(requestId, received);
            this.expectedSequence.set(requestId, expected + 1);
            
            // 检查是否有之前缺失的消息现在到达了
            this.checkForLateMessages(requestId, sequenceNumber);
            
            return true;
        } else if (sequenceNumber > expected) {
            // 消息乱序或丢失
            this.handleMissingMessages(requestId, expected, sequenceNumber);
            received.add(sequenceNumber);
            this.receivedMessages.set(requestId, received);
            return true;
        } else {
            // 重复消息或过期消息
            if (received.has(sequenceNumber)) {
                console.warn(`重复消息: requestId=${requestId}, sequence=${sequenceNumber}`);
            } else {
                console.warn(`过期消息: requestId=${requestId}, sequence=${sequenceNumber}`);
            }
            return false;
        }
    }

    private verifyChecksum(message: any): boolean {
        if (!message.checksum) {
            return true; // 如果没有校验和，跳过验证
        }

        const content = message.requestId + message.sequenceNumber + 
                       message.messageType + JSON.stringify(message.data) + 
                       message.timestamp;
        
        const calculatedChecksum = this.calculateMD5(content);
        return calculatedChecksum === message.checksum;
    }

    private verifyTimestamp(timestamp: number): boolean {
        const now = Date.now();
        const maxAge = 5 * 60 * 1000; // 5分钟
        
        // 消息不能太旧
        if (now - timestamp > maxAge) {
            return false;
        }
        
        // 消息不能来自未来（考虑时钟偏差）
        const maxClockSkew = 30 * 1000; // 30秒
        if (timestamp - now > maxClockSkew) {
            return false;
        }
        
        return true;
    }

    private handleMissingMessages(requestId: string, expectedSeq: number, receivedSeq: number) {
        const missing = this.missingMessages.get(requestId) || new Set();
        
        for (let i = expectedSeq; i < receivedSeq; i++) {
            missing.add(i);
            console.warn(`检测到缺失消息: requestId=${requestId}, sequence=${i}`);
        }
        
        this.missingMessages.set(requestId, missing);
        this.expectedSequence.set(requestId, receivedSeq + 1);
    }

    private checkForLateMessages(requestId: string, sequenceNumber: number) {
        const missing = this.missingMessages.get(requestId);
        if (missing && missing.has(sequenceNumber)) {
            missing.delete(sequenceNumber);
            console.log(`延迟消息到达: requestId=${requestId}, sequence=${sequenceNumber}`);
        }
    }

    private calculateMD5(content: string): string {
        // 在实际应用中，使用crypto库计算MD5
        // 这里简化实现
        return btoa(content).substring(0, 32);
    }

    getMissingMessages(requestId: string): number[] {
        const missing = this.missingMessages.get(requestId);
        return missing ? Array.from(missing) : [];
    }

    cleanup(requestId: string) {
        this.expectedSequence.delete(requestId);
        this.receivedMessages.delete(requestId);
        this.missingMessages.delete(requestId);
    }
}
```

## 并发控制与资源管理

### 连接池管理

```java
@Configuration
public class SSEConnectionPoolConfig {
    
    @Bean
    public SSEConnectionPool sseConnectionPool() {
        return new SSEConnectionPool(
            1000,    // 最大连接数
            60000,   // 连接超时时间
            300000   // 连接最大生存时间
        );
    }
}

@Component
public class SSEConnectionPool {
    private final int maxConnections;
    private final long connectionTimeout;
    private final long maxConnectionAge;
    private final Map<String, SSEConnectionInfo> activeConnections = new ConcurrentHashMap<>();
    private final AtomicInteger connectionCount = new AtomicInteger(0);

    public SSEConnectionPool(int maxConnections, long connectionTimeout, long maxConnectionAge) {
        this.maxConnections = maxConnections;
        this.connectionTimeout = connectionTimeout;
        this.maxConnectionAge = maxConnectionAge;
        
        // 启动清理任务
        startCleanupTask();
    }

    public boolean canCreateConnection(String requestId) {
        // 检查是否达到最大连接数
        if (connectionCount.get() >= maxConnections) {
            log.warn("连接池已满，当前连接数: {}", connectionCount.get());
            return false;
        }

        // 检查是否已存在相同的连接
        if (activeConnections.containsKey(requestId)) {
            log.warn("连接已存在: {}", requestId);
            return false;
        }

        return true;
    }

    public void registerConnection(String requestId, SseEmitter emitter) {
        if (canCreateConnection(requestId)) {
            SSEConnectionInfo info = new SSEConnectionInfo(
                requestId, emitter, System.currentTimeMillis()
            );
            
            activeConnections.put(requestId, info);
            connectionCount.incrementAndGet();
            
            log.info("注册SSE连接: {}, 当前连接数: {}", requestId, connectionCount.get());
            
            // 设置连接关闭回调
            emitter.onCompletion(() -> removeConnection(requestId));
            emitter.onTimeout(() -> removeConnection(requestId));
            emitter.onError((ex) -> removeConnection(requestId));
        }
    }

    public void removeConnection(String requestId) {
        SSEConnectionInfo info = activeConnections.remove(requestId);
        if (info != null) {
            connectionCount.decrementAndGet();
            log.info("移除SSE连接: {}, 当前连接数: {}", requestId, connectionCount.get());
        }
    }

    private void startCleanupTask() {
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(() -> {
            cleanupExpiredConnections();
        }, 60, 60, TimeUnit.SECONDS); // 每分钟清理一次
    }

    private void cleanupExpiredConnections() {
        long now = System.currentTimeMillis();
        
        activeConnections.entrySet().removeIf(entry -> {
            SSEConnectionInfo info = entry.getValue();
            
            // 检查连接年龄
            if (now - info.getCreateTime() > maxConnectionAge) {
                log.info("清理过期连接: {}", entry.getKey());
                info.getEmitter().complete();
                connectionCount.decrementAndGet();
                return true;
            }
            
            return false;
        });
    }

    public int getActiveConnectionCount() {
        return connectionCount.get();
    }

    public Set<String> getActiveConnectionIds() {
        return new HashSet<>(activeConnections.keySet());
    }
}

@Data
class SSEConnectionInfo {
    private final String requestId;
    private final SseEmitter emitter;
    private final long createTime;
    private volatile long lastActivityTime;

    public SSEConnectionInfo(String requestId, SseEmitter emitter, long createTime) {
        this.requestId = requestId;
        this.emitter = emitter;
        this.createTime = createTime;
        this.lastActivityTime = createTime;
    }

    public void updateActivity() {
        this.lastActivityTime = System.currentTimeMillis();
    }
}
```

### 资源隔离与限流

```java
@Component
public class StreamingResourceManager {
    private final Map<String, Semaphore> userSemaphores = new ConcurrentHashMap<>();
    private final RateLimiter globalRateLimiter;
    private final Map<String, RateLimiter> userRateLimiters = new ConcurrentHashMap<>();

    public StreamingResourceManager() {
        // 全局限流：每秒最多100个连接
        this.globalRateLimiter = RateLimiter.create(100.0);
    }

    public boolean acquireConnection(String userId) {
        // 全局限流检查
        if (!globalRateLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
            log.warn("全局连接限流触发");
            return false;
        }

        // 用户级别限流检查
        RateLimiter userLimiter = userRateLimiters.computeIfAbsent(userId, 
            k -> RateLimiter.create(5.0)); // 每个用户每秒最多5个连接

        if (!userLimiter.tryAcquire(1, TimeUnit.SECONDS)) {
            log.warn("用户连接限流触发: {}", userId);
            return false;
        }

        // 用户并发连接数限制
        Semaphore userSemaphore = userSemaphores.computeIfAbsent(userId, 
            k -> new Semaphore(3)); // 每个用户最多3个并发连接

        if (!userSemaphore.tryAcquire()) {
            log.warn("用户并发连接数超限: {}", userId);
            return false;
        }

        return true;
    }

    public void releaseConnection(String userId) {
        Semaphore userSemaphore = userSemaphores.get(userId);
        if (userSemaphore != null) {
            userSemaphore.release();
        }
    }

    // 内存使用监控
    @Scheduled(fixedRate = 30000) // 30秒检查一次
    public void monitorMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        double memoryUsagePercent = (double) usedMemory / totalMemory * 100;
        
        if (memoryUsagePercent > 80) {
            log.warn("内存使用率过高: {}%", memoryUsagePercent);
            // 触发一些保护措施，比如拒绝新连接或清理缓存
            triggerMemoryProtection();
        }
    }

    private void triggerMemoryProtection() {
        // 强制垃圾回收
        System.gc();
        
        // 清理过期的用户限制器
        cleanupExpiredRateLimiters();
        
        // 可以考虑临时降低连接限制等措施
    }

    private void cleanupExpiredRateLimiters() {
        // 清理长时间未使用的限流器
        // 实际实现中需要记录最后使用时间
    }
}
```

## 小结

流式通信的可靠性保障是一个多层次的工程问题：

1. **心跳机制**：保证连接活性检测和及时发现断线
2. **重连策略**：智能化的断线重连，适应不同的失败场景
3. **超时处理**：分层的超时策略，避免资源无限等待
4. **完整性校验**：确保数据的完整性和顺序性
5. **资源管理**：连接池和限流机制，防止资源耗尽

这些机制需要在服务端和客户端协同工作，形成完整的可靠性保障体系。在下一节中，我们将重点探讨AI Agent场景下的特殊流式交互模式。

---

**本节关键要点：**
- 心跳机制的设计原理和双向实现
- 指数退避重连算法和智能重连策略
- 分层超时处理和客户端超时管理
- 流式数据的完整性校验和序号机制
- 并发控制、资源隔离和限流策略
