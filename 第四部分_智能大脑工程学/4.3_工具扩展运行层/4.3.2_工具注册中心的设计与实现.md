# 4.3.2 å·¥å…·æ³¨å†Œä¸­å¿ƒçš„è®¾è®¡ä¸å®ç°

> "å·¥å…·æ³¨å†Œä¸­å¿ƒæ˜¯AGIåº”ç”¨å·¥å…·ç”Ÿæ€çš„å¿ƒè„ï¼Œå®ƒä¸ä»…æ˜¯å·¥å…·çš„ä»“åº“ï¼Œæ›´æ˜¯æ™ºèƒ½å·¥å…·å‘ç°ã€åŒ¹é…å’ŒååŒçš„æ™ºèƒ½å¤§è„‘ã€‚"

## ğŸ¯ æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- âœ… è®¾è®¡é«˜å¯ç”¨çš„åˆ†å¸ƒå¼å·¥å…·æ³¨å†Œä¸­å¿ƒæ¶æ„
- âœ… å®ç°æ™ºèƒ½å·¥å…·å‘ç°å’Œèƒ½åŠ›åŒ¹é…æœºåˆ¶
- âœ… æ„å»ºå®Œå–„çš„å·¥å…·ç‰ˆæœ¬ç®¡ç†å’Œä¾èµ–è§£æç³»ç»Ÿ
- âœ… å»ºç«‹å·¥å…·æƒé™ç®¡ç†å’Œå®‰å…¨è®¿é—®æ§åˆ¶æœºåˆ¶

## å·¥å…·æ³¨å†Œä¸­å¿ƒæ¦‚è¿°

### æ ¸å¿ƒå®šä½ä¸èŒè´£

å·¥å…·æ³¨å†Œä¸­å¿ƒä½œä¸ºå·¥å…·æ‰©å±•è¿è¡Œå±‚çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œæ‰¿æ‹…ç€å·¥å…·ç”Ÿæ€ç³»ç»Ÿçš„ç®¡ç†èŒè´£ï¼š

```mermaid
graph TB
    subgraph "å·¥å…·æ³¨å†Œä¸­å¿ƒæ¶æ„"
        REGISTRY[ğŸ›ï¸ å·¥å…·æ³¨å†Œä¸­å¿ƒ<br/>Tool Registry Center]
        
        subgraph "æ ¸å¿ƒåŠŸèƒ½æ¨¡å—"
            CATALOG[ğŸ“š å·¥å…·ç›®å½•ç®¡ç†<br/>Tool Catalog Management]
            VERSION[ğŸ”„ ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ<br/>Version Control System]
            DISCOVERY[ğŸ” æ™ºèƒ½å‘ç°å¼•æ“<br/>Intelligent Discovery Engine]
            METADATA[ğŸ“‹ å…ƒæ•°æ®ç®¡ç†å™¨<br/>Metadata Manager]
            SECURITY[ğŸ”’ å®‰å…¨è®¿é—®æ§åˆ¶<br/>Security Access Control]
        end
        
        REGISTRY --> CATALOG
        REGISTRY --> VERSION
        REGISTRY --> DISCOVERY
        REGISTRY --> METADATA
        REGISTRY --> SECURITY
    end
    
    subgraph "å¤–éƒ¨äº¤äº’"
        TOOLS[ğŸ”§ å·¥å…·ç”Ÿæ€ç³»ç»Ÿ]
        ORCHESTRATOR[âš¡ ç¼–æ’å¼•æ“]
        CREATORS[ğŸ¨ å·¥å…·åˆ›é€ å¼•æ“]
        USERS[ğŸ‘¥ å¼€å‘è€…/ç”¨æˆ·]
    end
    
    TOOLS --> REGISTRY
    REGISTRY --> ORCHESTRATOR
    REGISTRY --> CREATORS
    USERS --> REGISTRY
```

### æ ¸å¿ƒåŠŸèƒ½ç‰¹æ€§

#### 1. ç»Ÿä¸€å·¥å…·ç›®å½•ç®¡ç†
- **å…¨å±€å·¥å…·æ¸…å•**ï¼šç»´æŠ¤ç³»ç»Ÿä¸­æ‰€æœ‰å¯ç”¨å·¥å…·çš„å®Œæ•´æ¸…å•
- **åˆ†ç±»ä½“ç³»**ï¼šå»ºç«‹å¤šç»´åº¦çš„å·¥å…·åˆ†ç±»å’Œæ ‡ç­¾ä½“ç³»
- **æœç´¢ç´¢å¼•**ï¼šæ„å»ºé«˜æ•ˆçš„å·¥å…·æœç´¢å’Œæ£€ç´¢æœºåˆ¶

#### 2. æ™ºèƒ½ç‰ˆæœ¬æ§åˆ¶
- **è¯­ä¹‰ç‰ˆæœ¬ç®¡ç†**ï¼šæ”¯æŒç¬¦åˆSemantic Versioningçš„ç‰ˆæœ¬æ§åˆ¶
- **å‘åå…¼å®¹æ€§**ï¼šç»´æŠ¤ç‰ˆæœ¬é—´çš„å…¼å®¹æ€§æ˜ å°„å…³ç³»
- **ä¾èµ–è§£æ**ï¼šè‡ªåŠ¨è§£æå’Œç®¡ç†å·¥å…·é—´çš„ä¾èµ–å…³ç³»

#### 3. åŠ¨æ€æœåŠ¡å‘ç°
- **å®æ—¶çŠ¶æ€ç›‘æ§**ï¼šç›‘æ§å·¥å…·çš„å¥åº·çŠ¶æ€å’Œå¯ç”¨æ€§
- **è´Ÿè½½æ„ŸçŸ¥**ï¼šåŸºäºå·¥å…·è´Ÿè½½æƒ…å†µè¿›è¡Œæ™ºèƒ½è·¯ç”±
- **æ•…éšœåˆ‡æ¢**ï¼šè‡ªåŠ¨å¤„ç†å·¥å…·æ•…éšœå’ŒæœåŠ¡è¿ç§»

## åˆ†å¸ƒå¼æ¶æ„è®¾è®¡

### é«˜å¯ç”¨æ¶æ„æ¨¡å¼

å·¥å…·æ³¨å†Œä¸­å¿ƒé‡‡ç”¨åˆ†å¸ƒå¼å¾®æœåŠ¡æ¶æ„ï¼Œç¡®ä¿é«˜å¯ç”¨æ€§å’Œå¯æ‰©å±•æ€§ï¼š

```mermaid
graph TB
    subgraph "åˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒé›†ç¾¤"
        subgraph "ä¸»èŠ‚ç‚¹é›†ç¾¤"
            M1[Master Node 1]
            M2[Master Node 2] 
            M3[Master Node 3]
        end
        
        subgraph "æ•°æ®å­˜å‚¨å±‚"
            ETCD[(etcdé›†ç¾¤)]
            REDIS[(Redisç¼“å­˜)]
            PG[(PostgreSQL)]
        end
        
        subgraph "è´Ÿè½½å‡è¡¡å±‚"
            LB[è´Ÿè½½å‡è¡¡å™¨]
            GW[APIç½‘å…³]
        end
    end
    
    LB --> M1
    LB --> M2
    LB --> M3
    
    M1 --> ETCD
    M2 --> ETCD
    M3 --> ETCD
    
    M1 --> REDIS
    M2 --> REDIS
    M3 --> REDIS
    
    ETCD --> PG
    
    subgraph "å®¢æˆ·ç«¯"
        CLIENT[å·¥å…·å®¢æˆ·ç«¯]
        ORCHESTRATOR[ç¼–æ’å¼•æ“]
    end
    
    CLIENT --> GW
    ORCHESTRATOR --> GW
    GW --> LB
```

### æ ¸å¿ƒç»„ä»¶å®ç°

#### 1. å·¥å…·æ³¨å†Œç®¡ç†å™¨

```python
import asyncio
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
import json
from datetime import datetime

@dataclass
class ToolMetadata:
    """å·¥å…·å…ƒæ•°æ®ç»“æ„"""
    id: str
    name: str
    version: str
    description: str
    capabilities: List[str]
    input_schema: Dict
    output_schema: Dict
    dependencies: List[str]
    resource_requirements: Dict
    author: str
    created_at: datetime
    updated_at: datetime
    tags: List[str]
    documentation_url: Optional[str] = None
    source_url: Optional[str] = None

class ToolRegistrationManager:
    """å·¥å…·æ³¨å†Œç®¡ç†å™¨"""
    
    def __init__(self, storage_backend, event_bus):
        self.storage = storage_backend
        self.event_bus = event_bus
        self.validation_rules = ValidationRuleSet()
        
    async def register_tool(self, tool_metadata: ToolMetadata) -> bool:
        """æ³¨å†Œæ–°å·¥å…·"""
        try:
            # 1. å…ƒæ•°æ®éªŒè¯
            validation_result = await self.validate_metadata(tool_metadata)
            if not validation_result.is_valid:
                raise ValidationError(validation_result.errors)
            
            # 2. ä¾èµ–æ£€æŸ¥
            dependency_check = await self.check_dependencies(tool_metadata.dependencies)
            if not dependency_check.all_satisfied:
                raise DependencyError(dependency_check.missing_dependencies)
            
            # 3. ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
            compatibility_check = await self.check_version_compatibility(
                tool_metadata.id, tool_metadata.version
            )
            if not compatibility_check.is_compatible:
                raise CompatibilityError(compatibility_check.conflicts)
            
            # 4. å­˜å‚¨å·¥å…·å…ƒæ•°æ®
            await self.storage.store_tool_metadata(tool_metadata)
            
            # 5. æ›´æ–°æœç´¢ç´¢å¼•
            await self.update_search_index(tool_metadata)
            
            # 6. å‘å¸ƒæ³¨å†Œäº‹ä»¶
            await self.event_bus.publish(
                "tool.registered", 
                {"tool_id": tool_metadata.id, "version": tool_metadata.version}
            )
            
            self.logger.info(f"Tool {tool_metadata.id}:{tool_metadata.version} registered successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Tool registration failed: {e}")
            return False
    
    async def unregister_tool(self, tool_id: str, version: str) -> bool:
        """å¸è½½å·¥å…·"""
        try:
            # 1. æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å·¥å…·ä¾èµ–
            dependents = await self.find_dependents(tool_id, version)
            if dependents:
                raise DependencyError(f"Tool has dependents: {dependents}")
            
            # 2. æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„æ‰§è¡Œå®ä¾‹
            active_instances = await self.get_active_instances(tool_id, version)
            if active_instances:
                # ç­‰å¾…å®ä¾‹å®Œæˆæˆ–å¼ºåˆ¶ç»ˆæ­¢
                await self.wait_for_completion_or_terminate(active_instances)
            
            # 3. ä»å­˜å‚¨ä¸­åˆ é™¤
            await self.storage.remove_tool_metadata(tool_id, version)
            
            # 4. æ›´æ–°æœç´¢ç´¢å¼•
            await self.remove_from_search_index(tool_id, version)
            
            # 5. å‘å¸ƒå¸è½½äº‹ä»¶
            await self.event_bus.publish(
                "tool.unregistered",
                {"tool_id": tool_id, "version": version}
            )
            
            return True
            
        except Exception as e:
            self.logger.error(f"Tool unregistration failed: {e}")
            return False

    async def validate_metadata(self, metadata: ToolMetadata) -> ValidationResult:
        """éªŒè¯å·¥å…·å…ƒæ•°æ®"""
        errors = []
        
        # åŸºæœ¬å­—æ®µéªŒè¯
        if not metadata.id:
            errors.append("Tool ID is required")
        
        if not metadata.version:
            errors.append("Tool version is required")
            
        # ç‰ˆæœ¬æ ¼å¼éªŒè¯
        if not self.validation_rules.is_valid_version(metadata.version):
            errors.append(f"Invalid version format: {metadata.version}")
        
        # SchemaéªŒè¯
        if not self.validation_rules.is_valid_schema(metadata.input_schema):
            errors.append("Invalid input schema")
            
        if not self.validation_rules.is_valid_schema(metadata.output_schema):
            errors.append("Invalid output schema")
        
        return ValidationResult(len(errors) == 0, errors)
```

#### 2. æ™ºèƒ½å‘ç°å¼•æ“

```python
class IntelligentDiscoveryEngine:
    """æ™ºèƒ½å·¥å…·å‘ç°å¼•æ“"""
    
    def __init__(self, vector_store, semantic_search_model):
        self.vector_store = vector_store
        self.semantic_model = semantic_search_model
        self.capability_index = CapabilityIndex()
        self.performance_tracker = PerformanceTracker()
        
    async def discover_tools(self, query: ToolQuery) -> List[ToolMatch]:
        """æ™ºèƒ½å·¥å…·å‘ç°"""
        
        # 1. å¤šç»´åº¦æœç´¢ç­–ç•¥
        search_results = await self.multi_dimensional_search(query)
        
        # 2. è¯­ä¹‰ç›¸ä¼¼åº¦è®¡ç®—
        semantic_scores = await self.compute_semantic_similarity(query, search_results)
        
        # 3. æ€§èƒ½å†å²æƒé‡
        performance_weights = self.performance_tracker.get_performance_weights(
            [tool.id for tool in search_results]
        )
        
        # 4. ç»¼åˆè¯„åˆ†æ’åº
        ranked_matches = self.rank_matches(
            search_results, semantic_scores, performance_weights
        )
        
        return ranked_matches
    
    async def multi_dimensional_search(self, query: ToolQuery) -> List[Tool]:
        """å¤šç»´åº¦å·¥å…·æœç´¢"""
        
        results = []
        
        # 1. åŸºäºèƒ½åŠ›çš„ç²¾ç¡®åŒ¹é…
        if query.required_capabilities:
            capability_matches = await self.capability_index.search(
                query.required_capabilities
            )
            results.extend(capability_matches)
        
        # 2. åŸºäºæ ‡ç­¾çš„æ¨¡ç³ŠåŒ¹é…
        if query.tags:
            tag_matches = await self.search_by_tags(query.tags)
            results.extend(tag_matches)
        
        # 3. åŸºäºæè¿°çš„è¯­ä¹‰æœç´¢
        if query.description:
            semantic_matches = await self.semantic_search(query.description)
            results.extend(semantic_matches)
        
        # 4. å»é‡å’Œåˆå¹¶
        unique_results = self.deduplicate_and_merge(results)
        
        return unique_results
    
    async def compute_semantic_similarity(self, 
                                        query: ToolQuery, 
                                        tools: List[Tool]) -> Dict[str, float]:
        """è®¡ç®—è¯­ä¹‰ç›¸ä¼¼åº¦"""
        
        similarities = {}
        
        # æ„å»ºæŸ¥è¯¢å‘é‡
        query_text = self.build_query_text(query)
        query_vector = await self.semantic_model.encode(query_text)
        
        for tool in tools:
            # æ„å»ºå·¥å…·æè¿°å‘é‡
            tool_text = self.build_tool_text(tool)
            tool_vector = await self.semantic_model.encode(tool_text)
            
            # è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
            similarity = self.cosine_similarity(query_vector, tool_vector)
            similarities[tool.id] = similarity
        
        return similarities
    
    def rank_matches(self, 
                    tools: List[Tool],
                    semantic_scores: Dict[str, float],
                    performance_weights: Dict[str, float]) -> List[ToolMatch]:
        """ç»¼åˆè¯„åˆ†å’Œæ’åº"""
        
        matches = []
        
        for tool in tools:
            # ç»¼åˆè¯„åˆ†è®¡ç®—
            semantic_score = semantic_scores.get(tool.id, 0.0)
            performance_score = performance_weights.get(tool.id, 0.5)
            
            # åŠ æƒè®¡ç®—æœ€ç»ˆè¯„åˆ†
            final_score = (
                0.4 * semantic_score + 
                0.3 * performance_score + 
                0.3 * self.calculate_popularity_score(tool)
            )
            
            match = ToolMatch(
                tool=tool,
                semantic_score=semantic_score,
                performance_score=performance_score,
                final_score=final_score
            )
            matches.append(match)
        
        # æŒ‰æœ€ç»ˆè¯„åˆ†æ’åº
        return sorted(matches, key=lambda m: m.final_score, reverse=True)
```

#### 3. ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿ

```python
class VersionControlSystem:
    """å·¥å…·ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ"""
    
    def __init__(self, storage_backend):
        self.storage = storage_backend
        self.compatibility_matrix = CompatibilityMatrix()
        self.dependency_resolver = DependencyResolver()
        
    async def manage_tool_version(self, 
                                tool_id: str, 
                                new_version: str,
                                metadata: ToolMetadata) -> VersionManagementResult:
        """ç®¡ç†å·¥å…·ç‰ˆæœ¬"""
        
        try:
            # 1. è·å–ç°æœ‰ç‰ˆæœ¬ä¿¡æ¯
            existing_versions = await self.get_tool_versions(tool_id)
            
            # 2. ç‰ˆæœ¬å†²çªæ£€æŸ¥
            if new_version in existing_versions:
                raise VersionConflictError(f"Version {new_version} already exists")
            
            # 3. å…¼å®¹æ€§åˆ†æ
            compatibility_analysis = await self.analyze_compatibility(
                tool_id, new_version, existing_versions, metadata
            )
            
            # 4. ä¾èµ–å½±å“åˆ†æ
            dependency_impact = await self.analyze_dependency_impact(
                tool_id, new_version, metadata.dependencies
            )
            
            # 5. ç‰ˆæœ¬ç­–ç•¥å†³ç­–
            version_strategy = self.determine_version_strategy(
                compatibility_analysis, dependency_impact
            )
            
            # 6. æ‰§è¡Œç‰ˆæœ¬ç®¡ç†ç­–ç•¥
            result = await self.execute_version_strategy(
                tool_id, new_version, metadata, version_strategy
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Version management failed: {e}")
            return VersionManagementResult(success=False, error=str(e))
    
    async def analyze_compatibility(self, 
                                  tool_id: str,
                                  new_version: str,
                                  existing_versions: List[str],
                                  metadata: ToolMetadata) -> CompatibilityAnalysis:
        """åˆ†æç‰ˆæœ¬å…¼å®¹æ€§"""
        
        compatibility_issues = []
        breaking_changes = []
        
        for existing_version in existing_versions:
            existing_metadata = await self.storage.get_tool_metadata(
                tool_id, existing_version
            )
            
            # æ¥å£å…¼å®¹æ€§æ£€æŸ¥
            interface_compatibility = self.check_interface_compatibility(
                existing_metadata, metadata
            )
            
            if not interface_compatibility.is_compatible:
                breaking_changes.extend(interface_compatibility.breaking_changes)
            
            # ä¾èµ–å…¼å®¹æ€§æ£€æŸ¥
            dependency_compatibility = self.check_dependency_compatibility(
                existing_metadata.dependencies, metadata.dependencies
            )
            
            if not dependency_compatibility.is_compatible:
                compatibility_issues.extend(dependency_compatibility.issues)
        
        return CompatibilityAnalysis(
            has_breaking_changes=len(breaking_changes) > 0,
            breaking_changes=breaking_changes,
            compatibility_issues=compatibility_issues
        )
    
    def determine_version_strategy(self, 
                                 compatibility_analysis: CompatibilityAnalysis,
                                 dependency_impact: DependencyImpact) -> VersionStrategy:
        """ç¡®å®šç‰ˆæœ¬ç®¡ç†ç­–ç•¥"""
        
        if compatibility_analysis.has_breaking_changes:
            # æœ‰ç ´åæ€§å˜æ›´ï¼Œé‡‡ç”¨å¹¶è¡Œç‰ˆæœ¬ç­–ç•¥
            return VersionStrategy(
                type="parallel",
                migration_plan=self.create_migration_plan(compatibility_analysis),
                deprecation_timeline=self.create_deprecation_timeline()
            )
        elif dependency_impact.has_significant_impact:
            # æœ‰é‡å¤§ä¾èµ–å½±å“ï¼Œé‡‡ç”¨æ¸è¿›å¼å‡çº§ç­–ç•¥
            return VersionStrategy(
                type="gradual_upgrade",
                rollout_phases=self.create_rollout_phases(dependency_impact)
            )
        else:
            # å…¼å®¹æ€§å˜æ›´ï¼Œé‡‡ç”¨çƒ­æ›¿æ¢ç­–ç•¥
            return VersionStrategy(
                type="hot_replacement",
                rollback_plan=self.create_rollback_plan()
            )
```

## æ™ºèƒ½èƒ½åŠ›åŒ¹é…æœºåˆ¶

### å¤šå±‚æ¬¡èƒ½åŠ›å»ºæ¨¡

å·¥å…·æ³¨å†Œä¸­å¿ƒé‡‡ç”¨å¤šå±‚æ¬¡çš„èƒ½åŠ›å»ºæ¨¡æ–¹æ³•ï¼š

```mermaid
graph TB
    subgraph "èƒ½åŠ›å»ºæ¨¡å±‚æ¬¡"
        L1[ğŸ¯ åŠŸèƒ½å±‚èƒ½åŠ›<br/>Functional Capabilities]
        L2[âš™ï¸ æŠ€æœ¯å±‚èƒ½åŠ›<br/>Technical Capabilities]
        L3[ğŸ“Š æ€§èƒ½å±‚èƒ½åŠ›<br/>Performance Capabilities]
        L4[ğŸ”’ å®‰å…¨å±‚èƒ½åŠ›<br/>Security Capabilities]
    end
    
    L1 --> F1[æ•°æ®å¤„ç†]
    L1 --> F2[APIè°ƒç”¨]
    L1 --> F3[æ–‡ä»¶æ“ä½œ]
    L1 --> F4[è®¡ç®—åˆ†æ]
    
    L2 --> T1[ç¼–ç¨‹è¯­è¨€]
    L2 --> T2[è¿è¡Œæ—¶ç¯å¢ƒ]
    L2 --> T3[ä¾èµ–åº“]
    L2 --> T4[åè®®æ”¯æŒ]
    
    L3 --> P1[æ‰§è¡Œé€Ÿåº¦]
    L3 --> P2[å†…å­˜æ¶ˆè€—]
    L3 --> P3[å¹¶å‘èƒ½åŠ›]
    L3 --> P4[å¯æ‰©å±•æ€§]
    
    L4 --> S1[æƒé™è¦æ±‚]
    L4 --> S2[åŠ å¯†æ”¯æŒ]
    L4 --> S3[å®¡è®¡èƒ½åŠ›]
    L4 --> S4[éš”ç¦»çº§åˆ«]
```

### æ™ºèƒ½åŒ¹é…ç®—æ³•å®ç°

```python
class IntelligentMatchingEngine:
    """æ™ºèƒ½èƒ½åŠ›åŒ¹é…å¼•æ“"""
    
    def __init__(self):
        self.capability_graph = CapabilityGraph()
        self.matching_algorithms = {
            'exact': ExactMatcher(),
            'semantic': SemanticMatcher(),
            'fuzzy': FuzzyMatcher(),
            'structural': StructuralMatcher()
        }
        
    async def match_capabilities(self, 
                               required_capabilities: List[str],
                               available_tools: List[Tool]) -> List[CapabilityMatch]:
        """æ™ºèƒ½èƒ½åŠ›åŒ¹é…"""
        
        matches = []
        
        for tool in available_tools:
            match_scores = {}
            
            # 1. å¤šç§åŒ¹é…ç­–ç•¥å¹¶è¡Œè®¡ç®—
            for strategy, matcher in self.matching_algorithms.items():
                score = await matcher.calculate_match_score(
                    required_capabilities, tool.capabilities
                )
                match_scores[strategy] = score
            
            # 2. åŠ æƒè®¡ç®—ç»¼åˆåŒ¹é…åº¦
            combined_score = self.combine_match_scores(match_scores)
            
            # 3. ä¸Šä¸‹æ–‡ç›¸å…³æ€§è°ƒæ•´
            context_adjusted_score = self.adjust_for_context(
                combined_score, tool, required_capabilities
            )
            
            if context_adjusted_score > self.match_threshold:
                match = CapabilityMatch(
                    tool=tool,
                    match_scores=match_scores,
                    combined_score=context_adjusted_score,
                    explanation=self.generate_match_explanation(
                        tool, required_capabilities, match_scores
                    )
                )
                matches.append(match)
        
        return sorted(matches, key=lambda m: m.combined_score, reverse=True)
    
    def combine_match_scores(self, match_scores: Dict[str, float]) -> float:
        """ç»„åˆå¤šç§åŒ¹é…ç­–ç•¥çš„å¾—åˆ†"""
        
        # åŠ¨æ€æƒé‡è®¡ç®—
        weights = {
            'exact': 0.4,      # ç²¾ç¡®åŒ¹é…æƒé‡æœ€é«˜
            'semantic': 0.3,   # è¯­ä¹‰åŒ¹é…æ¬¡ä¹‹
            'fuzzy': 0.2,      # æ¨¡ç³ŠåŒ¹é…è¾ƒä½
            'structural': 0.1  # ç»“æ„åŒ¹é…æœ€ä½
        }
        
        combined_score = sum(
            weights.get(strategy, 0) * score 
            for strategy, score in match_scores.items()
        )
        
        return min(combined_score, 1.0)  # ç¡®ä¿å¾—åˆ†ä¸è¶…è¿‡1
    
    def generate_match_explanation(self, 
                                 tool: Tool,
                                 required_capabilities: List[str],
                                 match_scores: Dict[str, float]) -> str:
        """ç”ŸæˆåŒ¹é…è§£é‡Š"""
        
        explanations = []
        
        # ç²¾ç¡®åŒ¹é…çš„èƒ½åŠ›
        exact_matches = set(tool.capabilities) & set(required_capabilities)
        if exact_matches:
            explanations.append(f"ç²¾ç¡®åŒ¹é…èƒ½åŠ›: {', '.join(exact_matches)}")
        
        # è¯­ä¹‰ç›¸ä¼¼çš„èƒ½åŠ›
        semantic_matches = self.find_semantic_matches(
            tool.capabilities, required_capabilities
        )
        if semantic_matches:
            explanations.append(f"è¯­ä¹‰ç›¸ä¼¼èƒ½åŠ›: {', '.join(semantic_matches)}")
        
        # ç¼ºå¤±çš„èƒ½åŠ›
        missing_capabilities = set(required_capabilities) - set(tool.capabilities)
        if missing_capabilities:
            explanations.append(f"ç¼ºå¤±èƒ½åŠ›: {', '.join(missing_capabilities)}")
        
        return "; ".join(explanations)
```

## å®‰å…¨è®¿é—®æ§åˆ¶

### å¤šå±‚å®‰å…¨æ¨¡å‹

```python
class SecurityAccessController:
    """å®‰å…¨è®¿é—®æ§åˆ¶å™¨"""
    
    def __init__(self):
        self.rbac_manager = RBACManager()
        self.policy_engine = PolicyEngine()
        self.audit_logger = AuditLogger()
        
    async def authorize_tool_access(self, 
                                  user_context: UserContext,
                                  tool_id: str,
                                  operation: str) -> AuthorizationResult:
        """å·¥å…·è®¿é—®æˆæƒ"""
        
        try:
            # 1. èº«ä»½éªŒè¯
            if not await self.authenticate_user(user_context):
                return AuthorizationResult(authorized=False, reason="Authentication failed")
            
            # 2. è§’è‰²æƒé™æ£€æŸ¥
            if not await self.rbac_manager.check_permission(
                user_context.user_id, f"tool:{tool_id}:{operation}"
            ):
                return AuthorizationResult(authorized=False, reason="Insufficient permissions")
            
            # 3. ç­–ç•¥è¯„ä¼°
            policy_result = await self.policy_engine.evaluate_policies(
                user_context, tool_id, operation
            )
            
            if not policy_result.allowed:
                return AuthorizationResult(
                    authorized=False, 
                    reason=f"Policy violation: {policy_result.violation_reason}"
                )
            
            # 4. è®°å½•è®¿é—®å®¡è®¡
            await self.audit_logger.log_access_attempt(
                user_context, tool_id, operation, "ALLOWED"
            )
            
            return AuthorizationResult(authorized=True, reason="Access granted")
            
        except Exception as e:
            await self.audit_logger.log_access_attempt(
                user_context, tool_id, operation, "ERROR", str(e)
            )
            return AuthorizationResult(authorized=False, reason=f"Authorization error: {e}")
    
    async def create_access_token(self, 
                                user_context: UserContext,
                                tool_id: str,
                                permissions: List[str]) -> AccessToken:
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        
        token_payload = {
            "user_id": user_context.user_id,
            "tool_id": tool_id,
            "permissions": permissions,
            "issued_at": datetime.utcnow().isoformat(),
            "expires_at": (datetime.utcnow() + timedelta(hours=1)).isoformat()
        }
        
        token = jwt.encode(token_payload, self.secret_key, algorithm='HS256')
        
        # å­˜å‚¨ä»¤ç‰Œç”¨äºæ’¤é”€æ£€æŸ¥
        await self.token_store.store_token(token, token_payload)
        
        return AccessToken(token=token, expires_at=token_payload["expires_at"])
```

## æœ¬èŠ‚æ€»ç»“

æœ¬èŠ‚è¯¦ç»†ä»‹ç»äº†å·¥å…·æ³¨å†Œä¸­å¿ƒçš„è®¾è®¡ä¸å®ç°ï¼š

### ğŸ¯ æ ¸å¿ƒæ¶æ„ç‰¹ç‚¹
1. **åˆ†å¸ƒå¼é«˜å¯ç”¨**ï¼šé‡‡ç”¨ä¸»ä»é›†ç¾¤ç¡®ä¿æœåŠ¡å¯ç”¨æ€§
2. **æ™ºèƒ½å‘ç°æœºåˆ¶**ï¼šå¤šç»´åº¦æœç´¢å’Œè¯­ä¹‰åŒ¹é…
3. **ç‰ˆæœ¬ç®¡ç†ä½“ç³»**ï¼šå®Œå–„çš„ç‰ˆæœ¬æ§åˆ¶å’Œå…¼å®¹æ€§ç®¡ç†
4. **å®‰å…¨è®¿é—®æ§åˆ¶**ï¼šå¤šå±‚æ¬¡çš„æƒé™ç®¡ç†å’Œå®¡è®¡æœºåˆ¶

### ğŸ”§ å…³é”®æŠ€æœ¯å®ç°
- å·¥å…·å…ƒæ•°æ®çš„ç»“æ„åŒ–ç®¡ç†
- æ™ºèƒ½åŒ¹é…ç®—æ³•çš„å¤šç­–ç•¥èåˆ
- ç‰ˆæœ¬å…¼å®¹æ€§çš„è‡ªåŠ¨åŒ–åˆ†æ
- åŸºäºRBACçš„è®¿é—®æ§åˆ¶æœºåˆ¶

### ğŸš€ åˆ›æ–°ç‰¹æ€§
- **æ™ºèƒ½åŒ–**ï¼šåŸºäºAIçš„å·¥å…·å‘ç°å’ŒåŒ¹é…
- **è‡ªåŠ¨åŒ–**ï¼šç‰ˆæœ¬ç®¡ç†å’Œä¾èµ–è§£æçš„è‡ªåŠ¨åŒ–
- **å®‰å…¨æ€§**ï¼šå…¨æ–¹ä½çš„å®‰å…¨è®¿é—®æ§åˆ¶
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒå¤§è§„æ¨¡å·¥å…·ç”Ÿæ€ç³»ç»Ÿ

---

**ä¸‹ä¸€æ­¥å­¦ä¹ **ï¼šå»ºç«‹äº†å·¥å…·æ³¨å†Œä¸­å¿ƒçš„åŸºç¡€åï¼Œæˆ‘ä»¬å°†åœ¨4.3.3èŠ‚å­¦ä¹ æ™ºèƒ½ç¼–æ’å¼•æ“çš„è®¾è®¡å®ç°ï¼Œäº†è§£å¦‚ä½•åŸºäºå·¥å…·æ³¨å†Œä¿¡æ¯è¿›è¡Œæ™ºèƒ½åŒ–çš„å·¥å…·ç¼–æ’å’Œæ‰§è¡Œæ§åˆ¶ã€‚

> **ğŸ’¡ å®è·µå»ºè®®**ï¼šåœ¨å®é™…é¡¹ç›®ä¸­ï¼Œå»ºè®®ä»å°è§„æ¨¡çš„å·¥å…·æ³¨å†Œå¼€å§‹ï¼Œé€æ­¥æ‰©å±•åˆ°å®Œæ•´çš„åˆ†å¸ƒå¼æ³¨å†Œä¸­å¿ƒï¼Œå¹¶æŒç»­ä¼˜åŒ–åŒ¹é…ç®—æ³•çš„å‡†ç¡®æ€§ã€‚
