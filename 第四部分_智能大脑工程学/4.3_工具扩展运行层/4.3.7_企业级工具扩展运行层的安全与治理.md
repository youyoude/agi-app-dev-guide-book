# 4.3.7 ä¼ä¸šçº§å·¥å…·æ‰©å±•è¿è¡Œå±‚çš„å®‰å…¨ä¸æ²»ç†

> "å®‰å…¨å’Œæ²»ç†æ˜¯ä¼ä¸šçº§AIåº”ç”¨çš„ç”Ÿå‘½çº¿ã€‚æ²¡æœ‰å®‰å…¨ä¿éšœçš„æ™ºèƒ½ç³»ç»Ÿå¦‚åŒè„±ç¼°é‡é©¬ï¼Œè€Œç¼ºä¹æ²»ç†çš„å·¥å…·ç”Ÿæ€ç»ˆå°†èµ°å‘æ··ä¹±ã€‚"

## ğŸ¯ æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- âœ… æ„å»ºå®Œå–„çš„å·¥å…·æƒé™ç®¡ç†å’Œè®¿é—®æ§åˆ¶ä½“ç³»
- âœ… å®ç°å…¨é¢çš„å·¥å…·æ‰§è¡Œå®¡è®¡å’Œåˆè§„ç›‘æ§
- âœ… å»ºç«‹ä¼ä¸šçº§çš„å®‰å…¨é£é™©é˜²æ§æœºåˆ¶
- âœ… è®¾è®¡å¯æ‰©å±•çš„å·¥å…·æ²»ç†å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ä½“ç³»

## ä¼ä¸šçº§å®‰å…¨æ¶æ„

### å¤šå±‚æ¬¡å®‰å…¨é˜²æŠ¤ä½“ç³»

ä¼ä¸šçº§å·¥å…·æ‰©å±•è¿è¡Œå±‚éœ€è¦å»ºç«‹çºµæ·±é˜²å¾¡çš„å®‰å…¨æ¶æ„ï¼Œç¡®ä¿æ¯ä¸€ä¸ªå±‚æ¬¡éƒ½æœ‰ç›¸åº”çš„å®‰å…¨æ§åˆ¶æªæ–½ï¼š

```mermaid
graph TB
    subgraph "ä¼ä¸šçº§å®‰å…¨æ¶æ„"
        subgraph "èº«ä»½ä¸è®¿é—®ç®¡ç†å±‚"
            IAM[ğŸ” èº«ä»½è®¤è¯]
            RBAC[ğŸ‘¥ è§’è‰²æƒé™æ§åˆ¶]
            SSO[ğŸ« å•ç‚¹ç™»å½•]
        end
        
        subgraph "å·¥å…·å®‰å…¨æ§åˆ¶å±‚"
            TOOL_AUTH[ğŸ”§ å·¥å…·çº§æƒé™æ§åˆ¶]
            SANDBOX[ğŸ›ï¸ æ²™ç®±éš”ç¦»]
            VALIDATION[âœ… è¾“å…¥éªŒè¯]
        end
        
        subgraph "æ‰§è¡Œå®‰å…¨ç›‘æ§å±‚"
            RUNTIME_MONITOR[ğŸ“Š è¿è¡Œæ—¶ç›‘æ§]
            BEHAVIOR_DETECT[ğŸ•µï¸ è¡Œä¸ºæ£€æµ‹]
            THREAT_INTEL[âš ï¸ å¨èƒæƒ…æŠ¥]
        end
        
        subgraph "æ•°æ®å®‰å…¨ä¿æŠ¤å±‚"
            ENCRYPTION[ğŸ”’ æ•°æ®åŠ å¯†]
            DLP[ğŸ›¡ï¸ æ•°æ®é˜²æ³„æ¼]
            BACKUP[ğŸ’¾ å®‰å…¨å¤‡ä»½]
        end
        
        subgraph "å®¡è®¡ä¸åˆè§„å±‚"
            AUDIT_LOG[ğŸ“‹ å®¡è®¡æ—¥å¿—]
            COMPLIANCE[ğŸ“œ åˆè§„æ£€æŸ¥]
            FORENSICS[ğŸ” å–è¯åˆ†æ]
        end
    end
    
    IAM --> TOOL_AUTH
    RBAC --> TOOL_AUTH
    TOOL_AUTH --> RUNTIME_MONITOR
    SANDBOX --> RUNTIME_MONITOR
    RUNTIME_MONITOR --> AUDIT_LOG
    ENCRYPTION --> DLP
    DLP --> AUDIT_LOG
```

### èº«ä»½ä¸è®¿é—®ç®¡ç† (IAM)

```python
import jwt
import hashlib
import secrets
import time
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, field
from enum import Enum
import asyncio
from datetime import datetime, timedelta

class PermissionLevel(Enum):
    READ = "read"
    WRITE = "write"
    EXECUTE = "execute"
    ADMIN = "admin"

class ResourceType(Enum):
    TOOL = "tool"
    REGISTRY = "registry"
    EXECUTION = "execution"
    MONITORING = "monitoring"
    CONFIGURATION = "configuration"

@dataclass
class Permission:
    """æƒé™å®šä¹‰"""
    resource_type: ResourceType
    resource_id: str
    permission_level: PermissionLevel
    conditions: Dict[str, Any] = field(default_factory=dict)
    expires_at: Optional[datetime] = None

@dataclass
class Role:
    """è§’è‰²å®šä¹‰"""
    role_id: str
    role_name: str
    description: str
    permissions: List[Permission] = field(default_factory=list)
    inherits_from: List[str] = field(default_factory=list)

@dataclass
class User:
    """ç”¨æˆ·ä¿¡æ¯"""
    user_id: str
    username: str
    email: str
    roles: List[str] = field(default_factory=list)
    direct_permissions: List[Permission] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    last_login: Optional[datetime] = None
    is_active: bool = True

class EnterpriseIAMManager:
    """ä¼ä¸šçº§èº«ä»½ä¸è®¿é—®ç®¡ç†å™¨"""
    
    def __init__(self, jwt_secret: str, token_expiry_hours: int = 8):
        self.jwt_secret = jwt_secret
        self.token_expiry_hours = token_expiry_hours
        self.users = {}
        self.roles = {}
        self.active_sessions = {}
        self.permission_cache = {}
        self.audit_logger = AuditLogger()
        
        # åˆå§‹åŒ–é»˜è®¤è§’è‰²
        self._initialize_default_roles()
    
    def _initialize_default_roles(self):
        """åˆå§‹åŒ–é»˜è®¤è§’è‰²"""
        
        # ç³»ç»Ÿç®¡ç†å‘˜è§’è‰²
        admin_role = Role(
            role_id="system_admin",
            role_name="ç³»ç»Ÿç®¡ç†å‘˜",
            description="æ‹¥æœ‰ç³»ç»Ÿå…¨éƒ¨æƒé™",
            permissions=[
                Permission(ResourceType.TOOL, "*", PermissionLevel.ADMIN),
                Permission(ResourceType.REGISTRY, "*", PermissionLevel.ADMIN),
                Permission(ResourceType.EXECUTION, "*", PermissionLevel.ADMIN),
                Permission(ResourceType.MONITORING, "*", PermissionLevel.ADMIN),
                Permission(ResourceType.CONFIGURATION, "*", PermissionLevel.ADMIN)
            ]
        )
        
        # å·¥å…·å¼€å‘è€…è§’è‰²
        developer_role = Role(
            role_id="tool_developer",
            role_name="å·¥å…·å¼€å‘è€…", 
            description="å¯ä»¥å¼€å‘å’Œç®¡ç†å·¥å…·",
            permissions=[
                Permission(ResourceType.TOOL, "*", PermissionLevel.WRITE),
                Permission(ResourceType.REGISTRY, "*", PermissionLevel.WRITE),
                Permission(ResourceType.EXECUTION, "*", PermissionLevel.EXECUTE),
                Permission(ResourceType.MONITORING, "*", PermissionLevel.READ)
            ]
        )
        
        # æ™®é€šç”¨æˆ·è§’è‰²
        user_role = Role(
            role_id="regular_user",
            role_name="æ™®é€šç”¨æˆ·",
            description="å¯ä»¥ä½¿ç”¨å·¥å…·æ‰§è¡Œä»»åŠ¡",
            permissions=[
                Permission(ResourceType.TOOL, "*", PermissionLevel.EXECUTE),
                Permission(ResourceType.EXECUTION, "*", PermissionLevel.READ),
                Permission(ResourceType.MONITORING, "self", PermissionLevel.READ)
            ]
        )
        
        self.roles.update({
            "system_admin": admin_role,
            "tool_developer": developer_role,
            "regular_user": user_role
        })
    
    async def authenticate_user(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """ç”¨æˆ·è®¤è¯"""
        
        user = self.users.get(username)
        if not user or not user.is_active:
            await self.audit_logger.log_security_event(
                "LOGIN_FAILED", 
                {"username": username, "reason": "user_not_found_or_inactive"}
            )
            return None
        
        # éªŒè¯å¯†ç  (å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨bcryptç­‰å®‰å…¨å“ˆå¸Œ)
        password_hash = hashlib.sha256(f"{password}{user.user_id}".encode()).hexdigest()
        stored_hash = getattr(user, 'password_hash', '')
        
        if not secrets.compare_digest(password_hash, stored_hash):
            await self.audit_logger.log_security_event(
                "LOGIN_FAILED",
                {"username": username, "reason": "invalid_password"}
            )
            return None
        
        # ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
        token = await self._generate_access_token(user)
        
        # æ›´æ–°æœ€åç™»å½•æ—¶é—´
        user.last_login = datetime.now()
        
        # è®°å½•æˆåŠŸç™»å½•
        await self.audit_logger.log_security_event(
            "LOGIN_SUCCESS",
            {"username": username, "user_id": user.user_id}
        )
        
        return {
            "user": user,
            "access_token": token,
            "expires_in": self.token_expiry_hours * 3600
        }
    
    async def _generate_access_token(self, user: User) -> str:
        """ç”Ÿæˆè®¿é—®ä»¤ç‰Œ"""
        
        now = datetime.utcnow()
        payload = {
            "user_id": user.user_id,
            "username": user.username,
            "roles": user.roles,
            "iat": int(now.timestamp()),
            "exp": int((now + timedelta(hours=self.token_expiry_hours)).timestamp()),
            "jti": secrets.token_hex(16)  # JWT ID
        }
        
        token = jwt.encode(payload, self.jwt_secret, algorithm="HS256")
        
        # å­˜å‚¨æ´»è·ƒä¼šè¯
        self.active_sessions[payload["jti"]] = {
            "user_id": user.user_id,
            "created_at": now,
            "last_activity": now
        }
        
        return token
    
    async def validate_token(self, token: str) -> Optional[Dict[str, Any]]:
        """éªŒè¯è®¿é—®ä»¤ç‰Œ"""
        
        try:
            payload = jwt.decode(token, self.jwt_secret, algorithms=["HS256"])
            
            # æ£€æŸ¥ä¼šè¯æ˜¯å¦ä»ç„¶æ´»è·ƒ
            jti = payload.get("jti")
            if jti not in self.active_sessions:
                return None
            
            # æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            self.active_sessions[jti]["last_activity"] = datetime.utcnow()
            
            return payload
            
        except jwt.ExpiredSignatureError:
            await self.audit_logger.log_security_event(
                "TOKEN_EXPIRED", {"token": token[:20] + "..."}
            )
            return None
        except jwt.InvalidTokenError:
            await self.audit_logger.log_security_event(
                "INVALID_TOKEN", {"token": token[:20] + "..."}
            )
            return None
    
    async def check_permission(self, 
                             user_id: str, 
                             resource_type: ResourceType,
                             resource_id: str,
                             permission_level: PermissionLevel) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""
        
        # ä½¿ç”¨ç¼“å­˜æé«˜æ€§èƒ½
        cache_key = f"{user_id}:{resource_type.value}:{resource_id}:{permission_level.value}"
        if cache_key in self.permission_cache:
            cached_result = self.permission_cache[cache_key]
            if time.time() - cached_result["timestamp"] < 300:  # 5åˆ†é’Ÿç¼“å­˜
                return cached_result["result"]
        
        user = self.users.get(user_id)
        if not user or not user.is_active:
            return False
        
        # æ”¶é›†ç”¨æˆ·çš„æ‰€æœ‰æƒé™
        all_permissions = set()
        
        # æ·»åŠ ç›´æ¥æƒé™
        all_permissions.update(user.direct_permissions)
        
        # æ·»åŠ è§’è‰²æƒé™
        for role_id in user.roles:
            role = self.roles.get(role_id)
            if role:
                all_permissions.update(role.permissions)
                
                # å¤„ç†è§’è‰²ç»§æ‰¿
                inherited_permissions = self._get_inherited_permissions(role)
                all_permissions.update(inherited_permissions)
        
        # æ£€æŸ¥æƒé™åŒ¹é…
        has_permission = self._match_permission(
            all_permissions, resource_type, resource_id, permission_level
        )
        
        # ç¼“å­˜ç»“æœ
        self.permission_cache[cache_key] = {
            "result": has_permission,
            "timestamp": time.time()
        }
        
        # è®°å½•æƒé™æ£€æŸ¥
        await self.audit_logger.log_access_check(
            user_id, resource_type.value, resource_id, 
            permission_level.value, has_permission
        )
        
        return has_permission
    
    def _get_inherited_permissions(self, role: Role) -> Set[Permission]:
        """è·å–è§’è‰²ç»§æ‰¿çš„æƒé™"""
        
        inherited_permissions = set()
        
        for parent_role_id in role.inherits_from:
            parent_role = self.roles.get(parent_role_id)
            if parent_role:
                inherited_permissions.update(parent_role.permissions)
                # é€’å½’å¤„ç†å¤šå±‚ç»§æ‰¿
                inherited_permissions.update(self._get_inherited_permissions(parent_role))
        
        return inherited_permissions
    
    def _match_permission(self,
                         permissions: Set[Permission],
                         resource_type: ResourceType,
                         resource_id: str, 
                         required_level: PermissionLevel) -> bool:
        """åŒ¹é…æƒé™"""
        
        permission_hierarchy = {
            PermissionLevel.READ: 1,
            PermissionLevel.WRITE: 2, 
            PermissionLevel.EXECUTE: 3,
            PermissionLevel.ADMIN: 4
        }
        
        required_level_value = permission_hierarchy.get(required_level, 0)
        
        for permission in permissions:
            # æ£€æŸ¥èµ„æºç±»å‹
            if permission.resource_type != resource_type:
                continue
            
            # æ£€æŸ¥èµ„æºID (æ”¯æŒé€šé…ç¬¦)
            if permission.resource_id != "*" and permission.resource_id != resource_id:
                continue
            
            # æ£€æŸ¥æƒé™çº§åˆ«
            permission_level_value = permission_hierarchy.get(permission.permission_level, 0)
            if permission_level_value >= required_level_value:
                # æ£€æŸ¥æ¡ä»¶çº¦æŸ
                if self._check_permission_conditions(permission, resource_id):
                    return True
        
        return False
    
    def _check_permission_conditions(self, permission: Permission, resource_id: str) -> bool:
        """æ£€æŸ¥æƒé™æ¡ä»¶"""
        
        if not permission.conditions:
            return True
        
        # æ£€æŸ¥æ—¶é—´çº¦æŸ
        if permission.expires_at and datetime.now() > permission.expires_at:
            return False
        
        # æ£€æŸ¥IPçº¦æŸ
        if "allowed_ips" in permission.conditions:
            # è¿™é‡Œéœ€è¦ä»è¯·æ±‚ä¸Šä¸‹æ–‡è·å–å®¢æˆ·ç«¯IP
            # current_ip = get_client_ip()
            # if current_ip not in permission.conditions["allowed_ips"]:
            #     return False
            pass
        
        # æ£€æŸ¥æ—¶é—´çª—å£çº¦æŸ
        if "time_window" in permission.conditions:
            current_hour = datetime.now().hour
            allowed_hours = permission.conditions["time_window"]
            if current_hour not in allowed_hours:
                return False
        
        return True
```

### å·¥å…·æ‰§è¡Œæ²™ç®±

```python
import subprocess
import tempfile
import os
import resource
import signal
import psutil
from contextlib import contextmanager
import docker
from typing import Dict, List, Any, Optional, Union

class SandboxSecurityPolicy:
    """æ²™ç®±å®‰å…¨ç­–ç•¥"""
    
    def __init__(self):
        self.max_memory_mb = 512
        self.max_cpu_time = 30  # ç§’
        self.max_processes = 10
        self.allowed_syscalls = set()
        self.blocked_network_ports = [22, 23, 25, 53, 80, 443]
        self.allowed_file_paths = set()
        self.blocked_file_paths = {"/etc/passwd", "/etc/shadow", "/root"}
        self.max_file_size_mb = 100
        self.execution_timeout = 60  # ç§’

class DockerSandbox:
    """Dockerå®¹å™¨æ²™ç®±"""
    
    def __init__(self, security_policy: SandboxSecurityPolicy):
        self.policy = security_policy
        self.docker_client = docker.from_env()
        self.active_containers = {}
        
    @contextmanager
    def create_sandbox(self, tool_name: str, execution_context: Dict[str, Any]):
        """åˆ›å»ºæ²™ç®±ç¯å¢ƒ"""
        
        container = None
        container_name = f"tool_sandbox_{tool_name}_{int(time.time())}"
        
        try:
            # å‡†å¤‡å®¹å™¨é…ç½®
            container_config = self._build_container_config(
                tool_name, container_name, execution_context
            )
            
            # åˆ›å»ºå¹¶å¯åŠ¨å®¹å™¨
            container = self.docker_client.containers.run(
                **container_config,
                detach=True
            )
            
            self.active_containers[container_name] = container
            
            # ç­‰å¾…å®¹å™¨å°±ç»ª
            self._wait_for_container_ready(container)
            
            yield SandboxEnvironment(container, self.policy)
            
        except Exception as e:
            self.logger.error(f"Sandbox creation failed: {e}")
            raise SandboxError(f"Failed to create sandbox: {e}")
            
        finally:
            # æ¸…ç†å®¹å™¨
            if container:
                try:
                    container.stop(timeout=5)
                    container.remove()
                except Exception as e:
                    self.logger.error(f"Container cleanup failed: {e}")
                
                if container_name in self.active_containers:
                    del self.active_containers[container_name]
    
    def _build_container_config(self, 
                              tool_name: str,
                              container_name: str,
                              execution_context: Dict[str, Any]) -> Dict[str, Any]:
        """æ„å»ºå®¹å™¨é…ç½®"""
        
        # åŸºç¡€é•œåƒé€‰æ‹©
        base_image = self._select_base_image(tool_name, execution_context)
        
        # ç¯å¢ƒå˜é‡
        environment = {
            "TOOL_NAME": tool_name,
            "EXECUTION_ID": execution_context.get("execution_id", ""),
            "PYTHONPATH": "/sandbox/tools",
        }
        
        # æŒ‚è½½å·
        volumes = {
            "/tmp/sandbox_data": {"bind": "/sandbox/data", "mode": "rw"},
            "/tmp/sandbox_tools": {"bind": "/sandbox/tools", "mode": "ro"}
        }
        
        # ç½‘ç»œé…ç½®
        network_mode = "bridge"
        if execution_context.get("network_isolated", True):
            network_mode = "none"
        
        return {
            "image": base_image,
            "name": container_name,
            "environment": environment,
            "volumes": volumes,
            "network_mode": network_mode,
            "mem_limit": f"{self.policy.max_memory_mb}m",
            "cpu_quota": int(self.policy.max_cpu_time * 100000),  # 100% CPU = 100000
            "cpu_period": 100000,
            "pids_limit": self.policy.max_processes,
            "read_only": True,
            "tmpfs": {"/tmp": "rw,size=100m"},
            "security_opt": ["no-new-privileges:true"],
            "cap_drop": ["ALL"],
            "cap_add": ["SETUID", "SETGID"],  # æœ€å°æƒé™
            "user": "1000:1000",  # érootç”¨æˆ·
            "working_dir": "/sandbox",
            "command": ["python3", "-c", "import time; time.sleep(3600)"]  # ä¿æŒå®¹å™¨è¿è¡Œ
        }
    
    def _select_base_image(self, tool_name: str, execution_context: Dict[str, Any]) -> str:
        """é€‰æ‹©åŸºç¡€é•œåƒ"""
        
        # æ ¹æ®å·¥å…·ç±»å‹é€‰æ‹©ä¸åŒçš„åŸºç¡€é•œåƒ
        tool_type = execution_context.get("tool_type", "python")
        
        image_mapping = {
            "python": "python:3.9-slim",
            "nodejs": "node:16-alpine", 
            "java": "openjdk:11-jre-slim",
            "go": "golang:1.19-alpine",
            "rust": "rust:1.70-slim"
        }
        
        return image_mapping.get(tool_type, "python:3.9-slim")
    
    def _wait_for_container_ready(self, container, timeout: int = 30):
        """ç­‰å¾…å®¹å™¨å°±ç»ª"""
        
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                container.reload()
                if container.status == "running":
                    # æ‰§è¡Œå¥åº·æ£€æŸ¥
                    exit_code, output = container.exec_run("echo 'container ready'")
                    if exit_code == 0:
                        return
                        
            except Exception as e:
                self.logger.debug(f"Container not ready yet: {e}")
                
            time.sleep(1)
        
        raise SandboxError("Container failed to become ready within timeout")

class SandboxEnvironment:
    """æ²™ç®±æ‰§è¡Œç¯å¢ƒ"""
    
    def __init__(self, container, security_policy: SandboxSecurityPolicy):
        self.container = container
        self.policy = security_policy
        
    async def execute_command(self, command: str, input_data: str = None) -> Dict[str, Any]:
        """åœ¨æ²™ç®±ä¸­æ‰§è¡Œå‘½ä»¤"""
        
        try:
            # å‘½ä»¤å®‰å…¨æ£€æŸ¥
            if not self._validate_command_security(command):
                raise SecurityError("Command failed security validation")
            
            # å‡†å¤‡æ‰§è¡Œç¯å¢ƒ
            exec_config = {
                "cmd": ["bash", "-c", command],
                "environment": {"EXECUTION_TIMEOUT": str(self.policy.execution_timeout)},
                "user": "1000:1000",
                "workdir": "/sandbox"
            }
            
            # æ‰§è¡Œå‘½ä»¤
            start_time = time.time()
            exec_result = self.container.exec_run(**exec_config, stream=True, demux=True)
            
            # æ”¶é›†è¾“å‡º
            stdout_data = []
            stderr_data = []
            
            for stdout, stderr in exec_result.output:
                if stdout:
                    stdout_data.append(stdout.decode('utf-8'))
                if stderr:
                    stderr_data.append(stderr.decode('utf-8'))
                    
                # æ£€æŸ¥æ‰§è¡Œè¶…æ—¶
                if time.time() - start_time > self.policy.execution_timeout:
                    self._terminate_execution()
                    raise ExecutionTimeoutError("Command execution timed out")
            
            execution_time = time.time() - start_time
            
            return {
                "exit_code": exec_result.exit_code,
                "stdout": "".join(stdout_data),
                "stderr": "".join(stderr_data),
                "execution_time": execution_time,
                "resource_usage": self._get_resource_usage()
            }
            
        except Exception as e:
            return {
                "exit_code": -1,
                "stdout": "",
                "stderr": str(e),
                "execution_time": 0,
                "error": str(e)
            }
    
    def _validate_command_security(self, command: str) -> bool:
        """éªŒè¯å‘½ä»¤å®‰å…¨æ€§"""
        
        # å±é™©å‘½ä»¤é»‘åå•
        dangerous_commands = [
            "rm -rf", "dd if=", "mkfs", "format", "fdisk",
            "iptables", "ufw", "firewall", "sudo", "su",
            "chmod +s", "chown root", "passwd", "useradd",
            "wget", "curl", "nc", "netcat", "ssh", "scp"
        ]
        
        command_lower = command.lower()
        
        for dangerous_cmd in dangerous_commands:
            if dangerous_cmd in command_lower:
                self.logger.warning(f"Dangerous command detected: {dangerous_cmd}")
                return False
        
        # æ£€æŸ¥æ–‡ä»¶è·¯å¾„è®¿é—®
        sensitive_paths = ["/etc/", "/proc/", "/sys/", "/dev/", "/root/"]
        
        for path in sensitive_paths:
            if path in command_lower:
                self.logger.warning(f"Sensitive path access detected: {path}")
                return False
        
        return True
    
    def _get_resource_usage(self) -> Dict[str, float]:
        """è·å–èµ„æºä½¿ç”¨æƒ…å†µ"""
        
        try:
            stats = self.container.stats(stream=False)
            
            # CPUä½¿ç”¨ç‡
            cpu_stats = stats["cpu_stats"]
            precpu_stats = stats["precpu_stats"]
            
            cpu_delta = cpu_stats["cpu_usage"]["total_usage"] - precpu_stats["cpu_usage"]["total_usage"]
            system_delta = cpu_stats["system_cpu_usage"] - precpu_stats["system_cpu_usage"]
            
            cpu_percent = 0.0
            if system_delta > 0:
                cpu_percent = (cpu_delta / system_delta) * len(cpu_stats["cpu_usage"]["percpu_usage"]) * 100
            
            # å†…å­˜ä½¿ç”¨
            memory_stats = stats["memory_stats"]
            memory_usage = memory_stats.get("usage", 0)
            memory_limit = memory_stats.get("limit", 0)
            memory_percent = (memory_usage / memory_limit * 100) if memory_limit > 0 else 0
            
            return {
                "cpu_percent": cpu_percent,
                "memory_usage_mb": memory_usage / 1024 / 1024,
                "memory_percent": memory_percent
            }
            
        except Exception as e:
            self.logger.error(f"Failed to get resource usage: {e}")
            return {"cpu_percent": 0, "memory_usage_mb": 0, "memory_percent": 0}
    
    def _terminate_execution(self):
        """ç»ˆæ­¢æ‰§è¡Œ"""
        try:
            # å‘é€SIGTERMä¿¡å·
            self.container.exec_run("pkill -TERM -P 1", user="root")
            time.sleep(2)
            
            # å¦‚æœè¿›ç¨‹ä»åœ¨è¿è¡Œï¼Œå‘é€SIGKILL
            self.container.exec_run("pkill -KILL -P 1", user="root")
            
        except Exception as e:
            self.logger.error(f"Failed to terminate execution: {e}")
```

## å®¡è®¡ä¸åˆè§„ç›‘æ§

### å…¨é¢å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

```python
import json
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
from dataclasses import dataclass, asdict
from enum import Enum

class AuditEventType(Enum):
    USER_LOGIN = "user_login"
    USER_LOGOUT = "user_logout" 
    TOOL_ACCESS = "tool_access"
    TOOL_EXECUTION = "tool_execution"
    PERMISSION_CHECK = "permission_check"
    SECURITY_VIOLATION = "security_violation"
    DATA_ACCESS = "data_access"
    CONFIGURATION_CHANGE = "configuration_change"
    SYSTEM_ERROR = "system_error"

class Severity(Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

@dataclass
class AuditEvent:
    """å®¡è®¡äº‹ä»¶"""
    event_id: str
    event_type: AuditEventType
    timestamp: datetime
    user_id: Optional[str]
    session_id: Optional[str]
    source_ip: Optional[str]
    user_agent: Optional[str]
    resource_type: Optional[str]
    resource_id: Optional[str]
    action: str
    result: str  # SUCCESS, FAILURE, ERROR
    details: Dict[str, Any]
    severity: Severity = Severity.INFO

class ComprehensiveAuditLogger:
    """å…¨é¢å®¡è®¡æ—¥å¿—ç³»ç»Ÿ"""
    
    def __init__(self, storage_backend):
        self.storage = storage_backend
        self.event_queue = asyncio.Queue(maxsize=10000)
        self.running = False
        self.compliance_rules = {}
        self.alert_thresholds = {}
        
        # åˆå§‹åŒ–åˆè§„è§„åˆ™
        self._initialize_compliance_rules()
        
    async def start_audit_logging(self):
        """å¯åŠ¨å®¡è®¡æ—¥å¿—è®°å½•"""
        self.running = True
        
        # å¯åŠ¨äº‹ä»¶å¤„ç†ä»»åŠ¡
        asyncio.create_task(self._process_audit_events())
        asyncio.create_task(self._compliance_monitoring())
        
    async def stop_audit_logging(self):
        """åœæ­¢å®¡è®¡æ—¥å¿—è®°å½•"""
        self.running = False
        
        # å¤„ç†å‰©ä½™äº‹ä»¶
        while not self.event_queue.empty():
            await asyncio.sleep(0.1)
    
    async def log_user_activity(self, 
                              event_type: AuditEventType,
                              user_id: str,
                              action: str,
                              result: str,
                              details: Dict[str, Any],
                              context: Dict[str, Any] = None):
        """è®°å½•ç”¨æˆ·æ´»åŠ¨"""
        
        event = AuditEvent(
            event_id=self._generate_event_id(),
            event_type=event_type,
            timestamp=datetime.utcnow(),
            user_id=user_id,
            session_id=context.get("session_id") if context else None,
            source_ip=context.get("source_ip") if context else None,
            user_agent=context.get("user_agent") if context else None,
            resource_type=context.get("resource_type") if context else None,
            resource_id=context.get("resource_id") if context else None,
            action=action,
            result=result,
            details=details,
            severity=self._determine_severity(event_type, result)
        )
        
        await self._enqueue_event(event)
        
    async def log_tool_execution(self,
                               tool_name: str,
                               user_id: str,
                               execution_context: Dict[str, Any],
                               execution_result: Dict[str, Any]):
        """è®°å½•å·¥å…·æ‰§è¡Œ"""
        
        details = {
            "tool_name": tool_name,
            "input_data_hash": self._hash_sensitive_data(execution_context.get("input_data")),
            "execution_time": execution_result.get("execution_time", 0),
            "resource_usage": execution_result.get("resource_usage", {}),
            "output_data_hash": self._hash_sensitive_data(execution_result.get("output"))
        }
        
        result = "SUCCESS" if execution_result.get("success", False) else "FAILURE"
        
        await self.log_user_activity(
            AuditEventType.TOOL_EXECUTION,
            user_id,
            f"execute_{tool_name}",
            result,
            details,
            execution_context
        )
    
    async def log_security_event(self,
                               event_type: str,
                               details: Dict[str, Any],
                               severity: Severity = Severity.WARNING):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        
        event = AuditEvent(
            event_id=self._generate_event_id(),
            event_type=AuditEventType.SECURITY_VIOLATION,
            timestamp=datetime.utcnow(),
            user_id=details.get("user_id"),
            session_id=details.get("session_id"),
            source_ip=details.get("source_ip"),
            user_agent=details.get("user_agent"),
            resource_type="security",
            resource_id=event_type,
            action=event_type,
            result="VIOLATION",
            details=details,
            severity=severity
        )
        
        await self._enqueue_event(event)
        
        # å®‰å…¨äº‹ä»¶ç«‹å³å¤„ç†
        if severity in [Severity.ERROR, Severity.CRITICAL]:
            await self._handle_critical_security_event(event)
    
    async def _process_audit_events(self):
        """å¤„ç†å®¡è®¡äº‹ä»¶"""
        
        batch_size = 100
        events_batch = []
        
        while self.running:
            try:
                # æ”¶é›†äº‹ä»¶æ‰¹æ¬¡
                while len(events_batch) < batch_size and self.running:
                    try:
                        event = await asyncio.wait_for(
                            self.event_queue.get(), timeout=5.0
                        )
                        events_batch.append(event)
                    except asyncio.TimeoutError:
                        break
                
                # æ‰¹é‡å­˜å‚¨äº‹ä»¶
                if events_batch:
                    await self._store_events_batch(events_batch)
                    
                    # å®æ—¶åˆè§„æ£€æŸ¥
                    await self._check_compliance_violations(events_batch)
                    
                    events_batch.clear()
                
            except Exception as e:
                self.logger.error(f"Audit event processing error: {e}")
                await asyncio.sleep(1)
    
    async def _store_events_batch(self, events: List[AuditEvent]):
        """æ‰¹é‡å­˜å‚¨å®¡è®¡äº‹ä»¶"""
        
        try:
            # è½¬æ¢ä¸ºå­˜å‚¨æ ¼å¼
            events_data = [asdict(event) for event in events]
            
            # å­˜å‚¨åˆ°åç«¯
            await self.storage.store_audit_events(events_data)
            
            # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            await self._update_audit_statistics(events)
            
        except Exception as e:
            self.logger.error(f"Failed to store audit events: {e}")
            # å®ç°é™çº§å­˜å‚¨ç­–ç•¥ï¼ˆå¦‚æœ¬åœ°æ–‡ä»¶ï¼‰
            await self._fallback_storage(events)
    
    def _initialize_compliance_rules(self):
        """åˆå§‹åŒ–åˆè§„è§„åˆ™"""
        
        self.compliance_rules = {
            # æ•°æ®ä¿æŠ¤è§„åˆ™ (GDPRç±»ä¼¼)
            "data_protection": {
                "sensitive_data_access_logging": True,
                "data_retention_days": 2555,  # 7å¹´
                "anonymization_required": True,
                "cross_border_transfer_approval": True
            },
            
            # è®¿é—®æ§åˆ¶è§„åˆ™ (SOXç±»ä¼¼)
            "access_control": {
                "privileged_access_logging": True,
                "admin_activity_review": True,
                "access_certification_period": 90,  # å¤©
                "segregation_of_duties": True
            },
            
            # ç³»ç»Ÿå®Œæ•´æ€§è§„åˆ™
            "system_integrity": {
                "configuration_change_approval": True,
                "emergency_access_logging": True,
                "backup_verification": True,
                "integrity_monitoring": True
            }
        }
    
    async def _check_compliance_violations(self, events: List[AuditEvent]):
        """æ£€æŸ¥åˆè§„è¿è§„"""
        
        for event in events:
            violations = []
            
            # æ£€æŸ¥æ•°æ®ä¿æŠ¤åˆè§„
            if event.event_type == AuditEventType.DATA_ACCESS:
                if not self._check_data_protection_compliance(event):
                    violations.append("data_protection_violation")
            
            # æ£€æŸ¥è®¿é—®æ§åˆ¶åˆè§„
            if event.event_type in [AuditEventType.USER_LOGIN, AuditEventType.PERMISSION_CHECK]:
                if not self._check_access_control_compliance(event):
                    violations.append("access_control_violation")
            
            # æ£€æŸ¥ç³»ç»Ÿå®Œæ•´æ€§åˆè§„
            if event.event_type == AuditEventType.CONFIGURATION_CHANGE:
                if not self._check_system_integrity_compliance(event):
                    violations.append("system_integrity_violation")
            
            # å¤„ç†è¿è§„
            if violations:
                await self._handle_compliance_violations(event, violations)
    
    def _check_data_protection_compliance(self, event: AuditEvent) -> bool:
        """æ£€æŸ¥æ•°æ®ä¿æŠ¤åˆè§„"""
        
        rules = self.compliance_rules["data_protection"]
        
        # æ£€æŸ¥æ•æ„Ÿæ•°æ®è®¿é—®æ˜¯å¦æœ‰é€‚å½“çš„æ—¥å¿—è®°å½•
        if event.details.get("data_classification") == "sensitive":
            if not event.details.get("access_justification"):
                return False
            
            if not event.details.get("data_minimization_applied"):
                return False
        
        return True
    
    def _check_access_control_compliance(self, event: AuditEvent) -> bool:
        """æ£€æŸ¥è®¿é—®æ§åˆ¶åˆè§„"""
        
        # æ£€æŸ¥ç‰¹æƒè®¿é—®æ˜¯å¦æœ‰é€‚å½“å®¡æ‰¹
        if event.details.get("privilege_level") == "admin":
            if not event.details.get("approval_id"):
                return False
        
        return True
    
    async def _handle_compliance_violations(self, 
                                         event: AuditEvent, 
                                         violations: List[str]):
        """å¤„ç†åˆè§„è¿è§„"""
        
        violation_details = {
            "original_event_id": event.event_id,
            "violation_types": violations,
            "severity": "HIGH",
            "requires_immediate_action": True
        }
        
        await self.log_security_event(
            "COMPLIANCE_VIOLATION",
            violation_details,
            Severity.ERROR
        )
        
        # å‘é€è¿è§„é€šçŸ¥
        await self._send_compliance_alert(event, violations)
        
    async def generate_compliance_report(self, 
                                       start_date: datetime,
                                       end_date: datetime,
                                       compliance_framework: str) -> Dict[str, Any]:
        """ç”Ÿæˆåˆè§„æŠ¥å‘Š"""
        
        # æŸ¥è¯¢å®¡è®¡äº‹ä»¶
        events = await self.storage.query_audit_events(start_date, end_date)
        
        # åˆ†æåˆè§„çŠ¶æ€
        compliance_analysis = self._analyze_compliance_status(events, compliance_framework)
        
        # ç”ŸæˆæŠ¥å‘Š
        report = {
            "report_id": self._generate_report_id(),
            "framework": compliance_framework,
            "period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat()
            },
            "summary": compliance_analysis["summary"],
            "violations": compliance_analysis["violations"],
            "recommendations": compliance_analysis["recommendations"],
            "evidence": compliance_analysis["evidence"],
            "generated_at": datetime.utcnow().isoformat()
        }
        
        return report
```

## æœ¬èŠ‚æ€»ç»“

æœ¬èŠ‚æ·±å…¥ä»‹ç»äº†ä¼ä¸šçº§å·¥å…·æ‰©å±•è¿è¡Œå±‚çš„å®‰å…¨ä¸æ²»ç†ï¼š

### ğŸ¯ æ ¸å¿ƒå®‰å…¨ä½“ç³»
1. **å¤šå±‚é˜²æŠ¤**ï¼šèº«ä»½è®¤è¯ã€æƒé™æ§åˆ¶ã€æ²™ç®±éš”ç¦»ã€æ‰§è¡Œç›‘æ§çš„å…¨æ–¹ä½å®‰å…¨é˜²æŠ¤
2. **ç²¾ç»†æƒé™**ï¼šåŸºäºRBACçš„ç»†ç²’åº¦æƒé™ç®¡ç†å’ŒåŠ¨æ€æƒé™æ£€æŸ¥
3. **å®‰å…¨éš”ç¦»**ï¼šDockerå®¹å™¨æ²™ç®±æä¾›çš„å®‰å…¨æ‰§è¡Œç¯å¢ƒ
4. **å…¨é¢å®¡è®¡**ï¼šè¦†ç›–æ‰€æœ‰å…³é”®æ“ä½œçš„å®¡è®¡æ—¥å¿—å’Œåˆè§„ç›‘æ§

### ğŸ”§ å…³é”®å®ç°æŠ€æœ¯
- åŸºäºJWTçš„å®‰å…¨ä»¤ç‰Œå’Œä¼šè¯ç®¡ç†æœºåˆ¶
- RBACæƒé™æ¨¡å‹çš„åˆ†å±‚ç»§æ‰¿å’Œæ¡ä»¶çº¦æŸ
- Dockerå®¹å™¨çš„èµ„æºé™åˆ¶å’Œå®‰å…¨é…ç½®
- å®æ—¶å®¡è®¡æ—¥å¿—æ”¶é›†å’Œåˆè§„è§„åˆ™æ£€æŸ¥

### ğŸš€ ä¼ä¸šçº§ä»·å€¼
- **åˆè§„æ€§**ï¼šæ»¡è¶³å„ç§æ³•è§„è¦æ±‚çš„å®¡è®¡å’Œç›‘æ§èƒ½åŠ›
- **å®‰å…¨æ€§**ï¼šå¤šå±‚æ¬¡å®‰å…¨é˜²æŠ¤ç¡®ä¿ç³»ç»Ÿå®‰å…¨å¯é 
- **å¯æ§æ€§**ï¼šç»†ç²’åº¦çš„æƒé™ç®¡ç†å’Œèµ„æºæ§åˆ¶
- **å¯è¿½æº¯æ€§**ï¼šå®Œæ•´çš„æ“ä½œè½¨è¿¹å’Œè¯æ®é“¾ç®¡ç†

---

**ä¸‹ä¸€æ­¥å±•æœ›**ï¼šå®Œæˆå·¥å…·æ‰©å±•è¿è¡Œå±‚çš„å­¦ä¹ åï¼Œæˆ‘ä»¬å°†è¿›å…¥ç¬¬4.4ç« æ™ºèƒ½ç¯å¢ƒå±‚çš„å­¦ä¹ ï¼Œäº†è§£å¦‚ä½•ä¸ºAIåº”ç”¨æ„å»ºç¨³å®šå¯é çš„åŸºç¡€è®¾æ–½ç¯å¢ƒã€‚

> **ğŸ’¡ å®‰å…¨è¦è¯€**ï¼šä¼ä¸šçº§å®‰å…¨ä¸ä»…æ˜¯æŠ€æœ¯é—®é¢˜ï¼Œæ›´æ˜¯ç®¡ç†é—®é¢˜ã€‚æŠ€æœ¯æ‰‹æ®µæä¾›é˜²æŠ¤èƒ½åŠ›ï¼Œè€Œåˆ¶åº¦æµç¨‹ç¡®ä¿é˜²æŠ¤æªæ–½çš„æœ‰æ•ˆæ‰§è¡Œï¼Œä¸¤è€…ç¼ºä¸€ä¸å¯ã€‚
