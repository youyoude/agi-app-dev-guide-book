# 4.2.2.2 Plan-Solveæ€ç»´æ¨¡å¼ï¼šå…ˆè§„åˆ’åæ‰§è¡Œ

> "Plan-Solveæ¨¡å¼ç±»ä¼¼äºé¡¹ç›®ç®¡ç†ä¸­çš„'å…ˆåšè®¡åˆ’ï¼Œå†æ‰§è¡Œ'æ€è·¯ã€‚é¢å¯¹å¤æ‚ä»»åŠ¡æ—¶ï¼Œç³»ç»Ÿä¼šå…ˆè¿›è¡Œå…¨å±€åˆ†æå’Œè§„åˆ’ï¼Œåˆ¶å®šè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼Œç„¶åæŒ‰è®¡åˆ’é€æ­¥æ‰§è¡Œã€‚"

## å­¦ä¹ ç›®æ ‡

- ç†è§£åˆ†å±‚è§„åˆ’æ€ç»´çš„æ ¸å¿ƒä¼˜åŠ¿å’Œè®¾è®¡æ€è·¯
- æŒæ¡è§„åˆ’ä¸æ‰§è¡Œåˆ†ç¦»çš„ç³»ç»Ÿæ¶æ„æ–¹æ³•
- å­¦ä¼šæ„å»ºå¯æ‰©å±•çš„ä»»åŠ¡åˆ†è§£å’Œåä½œä½“ç³»
- æŒæ¡Plan-Solveæ¨¡å¼åœ¨ä¼ä¸šçº§åº”ç”¨ä¸­çš„ä¼˜åŒ–ç­–ç•¥

## Plan-Solveæ¨¡å¼çš„ç†è®ºåŸºç¡€

### è§„åˆ’ç†è®ºçš„å‘å±•å†ç¨‹

Plan-Solveæ¨¡å¼æºäºäººå·¥æ™ºèƒ½ä¸­çš„ç»å…¸è§„åˆ’ç†è®ºï¼Œå…¶å‘å±•å¯ä»¥è¿½æº¯åˆ°ï¼š

1. **STRIPSç³»ç»Ÿï¼ˆ1971ï¼‰**ï¼šæœ€æ—©çš„è‡ªåŠ¨è§„åˆ’ç³»ç»Ÿï¼Œå»ºç«‹äº†çŠ¶æ€-æ“ä½œ-ç›®æ ‡çš„åŸºæœ¬æ¡†æ¶
2. **åˆ†å±‚ä»»åŠ¡ç½‘ç»œï¼ˆHTNï¼‰**ï¼šå°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå­ä»»åŠ¡çš„å±‚æ¬¡åŒ–è§„åˆ’æ–¹æ³•
3. **éƒ¨åˆ†æœ‰åºè§„åˆ’**ï¼šå…è®¸å¹¶è¡Œæ‰§è¡Œçš„çµæ´»è§„åˆ’ç­–ç•¥
4. **ç°ä»£è§„åˆ’ç®—æ³•**ï¼šç»“åˆæœç´¢ä¼˜åŒ–å’Œçº¦æŸæ»¡è¶³çš„é«˜æ•ˆè§„åˆ’æ–¹æ³•

### Plan-Solveçš„æ ¸å¿ƒç†å¿µ

Plan-Solveæ¨¡å¼å°†å¤æ‚é—®é¢˜çš„è§£å†³è¿‡ç¨‹åˆ†ä¸ºä¸¤ä¸ªæ˜ç¡®é˜¶æ®µã€‚åœ¨åŸºäºLLMé©±åŠ¨çš„AGIåº”ç”¨ä¸­ï¼ŒPlan-Solveæ¨¡å¼å……åˆ†å‘æŒ¥äº†LLMçš„å…¨å±€åˆ†æå’Œç³»ç»Ÿè§„åˆ’èƒ½åŠ›ï¼š

```
é—®é¢˜è¾“å…¥ â†’ è§„åˆ’é˜¶æ®µ â†’ æ‰§è¡Œé˜¶æ®µ â†’ ç»“æœè¾“å‡º
           â†“           â†“
        åˆ¶å®šè®¡åˆ’    æŒ‰è®¡åˆ’æ‰§è¡Œ
        è¯„ä¼°èµ„æº    ç›‘æ§è¿›åº¦
        ä¼˜åŒ–ç­–ç•¥    å¤„ç†å¼‚å¸¸
```

**æ ¸å¿ƒç‰¹å¾**ï¼š
1. **é˜¶æ®µåˆ†ç¦»**ï¼šè§„åˆ’å’Œæ‰§è¡ŒèŒè´£æ¸…æ™°åˆ†ç¦»ï¼Œä¸“ä¸šåŒ–ç¨‹åº¦é«˜
2. **å…¨å±€ä¼˜åŒ–**ï¼šè§„åˆ’é˜¶æ®µè€ƒè™‘å…¨å±€çº¦æŸå’Œèµ„æºé™åˆ¶
3. **è®¡åˆ’è¯¦ç»†**ï¼šç”Ÿæˆå…·ä½“çš„æ‰§è¡Œæ­¥éª¤å’Œèµ„æºåˆ†é…æ–¹æ¡ˆ
4. **ç›‘æ§åé¦ˆ**ï¼šæ‰§è¡Œè¿‡ç¨‹ä¸­æŒç»­ç›‘æ§å¹¶åé¦ˆç»™è§„åˆ’å±‚

**LLMé©±åŠ¨çš„Plan-Solveä¼˜åŠ¿**ï¼š
- **ğŸ¯ å…¨å±€åˆ†æ**ï¼šLLMèƒ½å¤Ÿè¿›è¡Œæ·±åº¦çš„å…¨å±€åˆ†æï¼Œåˆ¶å®šæ›´ä¼˜åŒ–çš„æ‰§è¡Œè®¡åˆ’
- **ğŸ“‹ æ™ºèƒ½è§„åˆ’**ï¼šåˆ©ç”¨LLMçš„é€»è¾‘æ¨ç†èƒ½åŠ›ï¼Œç”Ÿæˆæ›´åˆç†çš„ä»»åŠ¡åˆ†è§£å’Œèµ„æºåˆ†é…
- **ğŸ” åŠ¨æ€ç›‘æ§**ï¼šLLMå¯ä»¥æ™ºèƒ½åˆ†ææ‰§è¡ŒçŠ¶æ€ï¼ŒåŠæ—¶å‘ç°åå·®å¹¶è°ƒæ•´è®¡åˆ’
- **âš–ï¸ çº¦æŸå¹³è¡¡**ï¼šLLMèƒ½å¤Ÿåœ¨å¤šé‡çº¦æŸæ¡ä»¶ä¸‹æ‰¾åˆ°æœ€ä¼˜çš„å¹³è¡¡æ–¹æ¡ˆ

### ä¸ReActæ¨¡å¼çš„å¯¹æ¯”åˆ†æ

| ç‰¹å¾ç»´åº¦ | Plan-Solveæ¨¡å¼ | ReActæ¨¡å¼ | é€‚ç”¨åœºæ™¯å¯¹æ¯” |
|---------|----------------|-----------|-------------|
| è§„åˆ’æ·±åº¦ | æ·±åº¦è§„åˆ’ï¼Œå…¨å±€è§†å›¾ | æµ…å±‚è§„åˆ’ï¼Œå±€éƒ¨å†³ç­– | Plan-Solveé€‚åˆç¡®å®šæ€§ä»»åŠ¡ |
| é€‚åº”æ€§ | ä¸­ç­‰ï¼Œè®¡åˆ’è°ƒæ•´æˆæœ¬é«˜ | é«˜åº¦é€‚åº”ï¼Œå®æ—¶è°ƒæ•´ | ReActé€‚åˆæ¢ç´¢æ€§ä»»åŠ¡ |
| èµ„æºåˆ©ç”¨ | é«˜æ•ˆï¼Œå…¨å±€ä¼˜åŒ– | ä¸­ç­‰ï¼Œå±€éƒ¨ä¼˜åŒ– | Plan-Solveé€‚åˆèµ„æºå¯†é›†å‹ |
| æ‰§è¡Œæ•ˆç‡ | é«˜ï¼Œé¢„å…ˆè§„åˆ’å‡å°‘å†—ä½™ | ä¸­ç­‰ï¼Œå­˜åœ¨è¯•é”™æˆæœ¬ | Plan-Solveé€‚åˆè´¨é‡è¦æ±‚é«˜ |
| é”™è¯¯æ¢å¤ | å¤æ‚ï¼Œéœ€é‡æ–°è§„åˆ’ | ç®€å•ï¼Œå±€éƒ¨è°ƒæ•´ | ReActé€‚åˆé«˜ä¸ç¡®å®šç¯å¢ƒ |
| å¯é¢„æµ‹æ€§ | é«˜ï¼Œè®¡åˆ’æ˜ç¡® | ä½ï¼ŒåŠ¨æ€å˜åŒ– | Plan-Solveé€‚åˆä¼ä¸šçº§åº”ç”¨ |

## Plan-Solveæ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„æ¦‚è§ˆ

åŸºäºjoyagent-jdgenieé¡¹ç›®çš„å®ç°ï¼ŒPlan-Solveæ¨¡å¼é‡‡ç”¨ä¸‰å±‚æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           è§„åˆ’å±‚ (Planning Layer)     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚        PlanningAgent           â”‚ â”‚
â”‚  â”‚  - ä»»åŠ¡åˆ†æä¸åˆ†è§£               â”‚ â”‚
â”‚  â”‚  - ç­–ç•¥åˆ¶å®šä¸ä¼˜åŒ–               â”‚ â”‚
â”‚  â”‚  - è®¡åˆ’ç”Ÿæˆä¸è°ƒæ•´               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“ è®¡åˆ’ä¼ é€’
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ‰§è¡Œå±‚ (Execution Layer)    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚        ExecutorAgent           â”‚ â”‚
â”‚  â”‚  - ä»»åŠ¡å…·ä½“æ‰§è¡Œ                â”‚ â”‚
â”‚  â”‚  - å·¥å…·è°ƒç”¨ç®¡ç†                â”‚ â”‚
â”‚  â”‚  - ç»“æœå¤„ç†ä¸åé¦ˆ              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“ ç»“æœæ±‡æ€»
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ±‡æ€»å±‚ (Summary Layer)      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚        SummaryAgent            â”‚ â”‚
â”‚  â”‚  - ç»“æœæ•´åˆä¸æ€»ç»“              â”‚ â”‚
â”‚  â”‚  - è´¨é‡è¯„ä¼°ä¸éªŒè¯              â”‚ â”‚
â”‚  â”‚  - æœ€ç»ˆè¾“å‡ºç”Ÿæˆ                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶å®ç°

#### 1. è§„åˆ’å±‚ (PlanningAgent)

**èŒè´£å®šä¹‰**ï¼š
- **ä»»åŠ¡ç†è§£**ï¼šæ·±åº¦è§£æç”¨æˆ·éœ€æ±‚çš„å¤æ‚æ€§å’Œçº¦æŸæ¡ä»¶
- **æ–¹æ¡ˆè®¾è®¡**ï¼šåˆ¶å®šè§£å†³é—®é¢˜çš„æ•´ä½“ç­–ç•¥å’Œå®æ–½è·¯å¾„
- **è®¡åˆ’ç”Ÿæˆ**ï¼šå°†æŠ½è±¡ç­–ç•¥è½¬åŒ–ä¸ºå…·ä½“çš„æ‰§è¡Œæ­¥éª¤
- **èµ„æºè¯„ä¼°**ï¼šåˆ†æå®Œæˆä»»åŠ¡æ‰€éœ€çš„å·¥å…·ã€æ—¶é—´å’Œè®¡ç®—èµ„æº

**æ ¸å¿ƒå®ç°**ï¼š
```java
public class PlanningAgent extends ReActAgent {
    private PlanningTool planningTool;
    private boolean isCloseUpdate = false; // æ˜¯å¦å…³é—­åŠ¨æ€æ›´æ–°
    
    @Override
    public boolean think() {
        // åˆ†æå½“å‰ä»»åŠ¡çŠ¶æ€
        if (Objects.nonNull(planningTool.getPlan())) {
            Plan currentPlan = planningTool.getPlan();
            
            // æ£€æŸ¥è®¡åˆ’å®ŒæˆçŠ¶æ€
            if (currentPlan.isCompleted()) {
                setState(AgentState.FINISHED);
                return false;
            }
            
            // è¯„ä¼°æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’
            if (shouldReplan(currentPlan)) {
                return true; // éœ€è¦é‡æ–°è§„åˆ’
            }
            
            return false; // å½“å‰è®¡åˆ’ä»æœ‰æ•ˆ
        }
        
        // é¦–æ¬¡è§„åˆ’æˆ–è®¡åˆ’ä¸¢å¤±ï¼Œéœ€è¦é‡æ–°åˆ¶å®šè®¡åˆ’
        return true;
    }
    
    @Override
    public String act() {
        // åŠ¨æ€æ›´æ–°å¤„ç†
        if (isCloseUpdate) {
            if (Objects.nonNull(planningTool.getPlan())) {
                return getNextTask();
            }
        }
        
        // æ‰§è¡Œè§„åˆ’å·¥å…·è°ƒç”¨
        List<String> results = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        
        for (ToolCall toolCall : toolCalls) {
            String result = executeTool(toolCall);
            
            // ç»“æœé•¿åº¦æ§åˆ¶
            if (maxObserve != null) {
                result = result.substring(0, Math.min(result.length(), maxObserve));
            }
            results.add(result);
            
            // æ›´æ–°è®°å¿†çŠ¶æ€
            updateMemoryWithToolResult(toolCall, result);
        }
        
        // è®¡åˆ’ç”Ÿæˆå®Œæˆåçš„å¤„ç†
        if (Objects.nonNull(planningTool.getPlan())) {
            if (isCloseUpdate) {
                planningTool.stepPlan(); // æ¨è¿›è®¡åˆ’æ­¥éª¤
            }
            return getNextTask();
        }
        
        return String.join("\n\n", results);
    }
    
    private String getNextTask() {
        Plan currentPlan = planningTool.getPlan();
        List<String> tasks = currentPlan.getTasks();
        
        boolean allComplete = true;
        StringBuilder taskStatus = new StringBuilder();
        
        for (int i = 0; i < tasks.size(); i++) {
            String task = tasks.get(i);
            boolean isCompleted = currentPlan.isTaskCompleted(i);
            
            if (!isCompleted) {
                allComplete = false;
                if (taskStatus.length() == 0) {
                    // è¿”å›ä¸‹ä¸€ä¸ªæœªå®Œæˆä»»åŠ¡
                    currentPlan.setCurrentTaskIndex(i);
                    return "Next task: " + task;
                }
            }
            
            taskStatus.append(String.format("Task %d: %s - %s\n", 
                i + 1, task, isCompleted ? "Completed" : "Pending"));
        }
        
        if (allComplete) {
            setState(AgentState.FINISHED);
            return "All tasks completed!\n" + taskStatus.toString();
        }
        
        return taskStatus.toString();
    }
}
```

**è§„åˆ’è´¨é‡è¯„ä¼°æŒ‡æ ‡**ï¼š
```java
public class PlanQualityEvaluator {
    
    public PlanQuality evaluatePlan(Plan plan, TaskContext context) {
        return PlanQuality.builder()
            .completeness(assessCompleteness(plan, context))
            .feasibility(assessFeasibility(plan, context))
            .efficiency(assessEfficiency(plan))
            .robustness(assessRobustness(plan))
            .clarity(assessClarity(plan))
            .build();
    }
    
    private double assessCompleteness(Plan plan, TaskContext context) {
        // è¯„ä¼°è®¡åˆ’æ˜¯å¦è¦†ç›–äº†æ‰€æœ‰å¿…è¦çš„å­ä»»åŠ¡
        Set<String> requiredCapabilities = context.getRequiredCapabilities();
        Set<String> plannedCapabilities = plan.getCoveredCapabilities();
        
        return (double) Sets.intersection(requiredCapabilities, plannedCapabilities).size() 
               / requiredCapabilities.size();
    }
    
    private double assessFeasibility(Plan plan, TaskContext context) {
        // è¯„ä¼°è®¡åˆ’åœ¨ç»™å®šèµ„æºçº¦æŸä¸‹çš„å¯è¡Œæ€§
        ResourceRequirement required = plan.getResourceRequirement();
        ResourceAvailability available = context.getAvailableResources();
        
        return available.canSatisfy(required) ? 1.0 : 
               calculatePartialSatisfactionRatio(required, available);
    }
    
    private double assessEfficiency(Plan plan) {
        // è¯„ä¼°è®¡åˆ’çš„æ‰§è¡Œæ•ˆç‡
        int totalSteps = plan.getTotalSteps();
        int criticalPath = plan.getCriticalPath().size();
        int parallelizableSteps = plan.getParallelizableSteps();
        
        return (double) criticalPath / (totalSteps - parallelizableSteps + 1);
    }
}
```

#### 2. æ‰§è¡Œå±‚ (ExecutorAgent)

**èŒè´£å®šä¹‰**ï¼š
- **ä»»åŠ¡æ‰§è¡Œ**ï¼šæŒ‰ç…§è§„åˆ’å±‚åˆ¶å®šçš„è®¡åˆ’æ‰§è¡Œå…·ä½“ä»»åŠ¡
- **å·¥å…·åè°ƒ**ï¼šç®¡ç†å’Œåè°ƒå¤šç§å·¥å…·çš„è°ƒç”¨
- **è¿›åº¦ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æ‰§è¡ŒçŠ¶æ€å¹¶åé¦ˆç»™è§„åˆ’å±‚
- **å¼‚å¸¸å¤„ç†**ï¼šå¤„ç†æ‰§è¡Œè¿‡ç¨‹ä¸­çš„å„ç§å¼‚å¸¸æƒ…å†µ

**æ ¸å¿ƒå®ç°**ï¼š
```java
public class ExecutorAgent extends ReActAgent {
    
    @Override
    public boolean think() {
        // åˆ†æå½“å‰ä»»åŠ¡å’Œå¯ç”¨å·¥å…·
        String currentTask = context.getTask();
        if (StringUtils.isEmpty(currentTask)) {
            return false; // æ²¡æœ‰ä»»åŠ¡éœ€è¦æ‰§è¡Œ
        }
        
        // æ„å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
        String systemPrompt = buildExecutionSystemPrompt();
        String taskPrompt = buildTaskSpecificPrompt(currentTask);
        
        try {
            // è°ƒç”¨LLMåˆ†ææ‰§è¡Œç­–ç•¥
            CompletableFuture<LLM.ToolCallResponse> future = getLlm().askTool(
                context,
                getMemory().getMessages(),
                Message.systemMessage(systemPrompt, null),
                availableTools,
                ToolChoice.AUTO,
                null,
                context.getIsStream(),
                300
            );
            
            LLM.ToolCallResponse response = future.get();
            setToolCalls(response.getToolCalls());
            
            // è®°å½•æ€è€ƒç»“æœ
            updateMemoryWithAssistantResponse(response);
            
            return response.getToolCalls() != null && !response.getToolCalls().isEmpty();
            
        } catch (Exception e) {
            log.error("Execution thinking failed", e);
            return false;
        }
    }
    
    @Override
    public String act() {
        // å¹¶å‘æ‰§è¡Œå·¥å…·è°ƒç”¨
        Map<String, String> toolResults = executeToolsConcurrently(toolCalls);
        
        // å¤„ç†æ‰§è¡Œç»“æœ
        List<String> results = new ArrayList<>();
        for (ToolCall command : toolCalls) {
            String result = toolResults.get(command.getId());
            
            // ç‰¹æ®Šå·¥å…·çš„ç»“æœå¤„ç†
            handleSpecialToolResult(command, result);
            
            // ç»“æœé•¿åº¦æ§åˆ¶
            if (maxObserve != null) {
                result = result.substring(0, Math.min(result.length(), maxObserve));
            }
            
            // æ›´æ–°è®°å¿†çŠ¶æ€
            updateMemoryWithToolResult(command, result);
            results.add(result);
        }
        
        return String.join("\n\n", results);
    }
    
    private Map<String, String> executeToolsConcurrently(List<ToolCall> toolCalls) {
        if (toolCalls.size() <= 1) {
            // å•ä¸ªå·¥å…·ç›´æ¥æ‰§è¡Œ
            Map<String, String> result = new HashMap<>();
            if (!toolCalls.isEmpty()) {
                ToolCall toolCall = toolCalls.get(0);
                result.put(toolCall.getId(), executeTool(toolCall));
            }
            return result;
        }
        
        // å¹¶å‘æ‰§è¡Œå¤šä¸ªå·¥å…·
        return CompletableFuture.supplyAsync(() -> {
            Map<String, String> results = new ConcurrentHashMap<>();
            
            toolCalls.parallelStream().forEach(command -> {
                try {
                    String result = executeTool(command);
                    results.put(command.getId(), result);
                } catch (Exception e) {
                    log.error("Tool execution failed: " + command.getFunction().getName(), e);
                    results.put(command.getId(), "Error: " + e.getMessage());
                }
            });
            
            return results;
        }).join();
    }
    
    private void handleSpecialToolResult(ToolCall command, String result) {
        String toolName = command.getFunction().getName();
        
        if (!Arrays.asList("code_interpreter", "report_tool", "file_tool", "deep_search")
                .contains(toolName)) {
            // å‘é€å·¥å…·ç»“æœé€šçŸ¥
            printer.send("tool_result", AgentResponse.ToolResult.builder()
                    .toolName(toolName)
                    .toolParam(JSON.parseObject(command.getFunction().getArguments(), Map.class))
                    .toolResult(result)
                    .build(), null);
        }
    }
}
```

**æ‰§è¡Œç›‘æ§ä¸ä¼˜åŒ–**ï¼š
```java
public class ExecutionMonitor {
    private final MetricsRegistry metricsRegistry;
    private final AlertManager alertManager;
    
    public void monitorExecution(ExecutionContext context) {
        // æ€§èƒ½æŒ‡æ ‡ç›‘æ§
        Timer executionTimer = metricsRegistry.timer("execution.duration");
        Counter successCounter = metricsRegistry.counter("execution.success");
        Counter errorCounter = metricsRegistry.counter("execution.error");
        
        Timer.Sample sample = Timer.start(metricsRegistry);
        
        try {
            // æ‰§è¡Œä»»åŠ¡
            String result = executeTask(context);
            
            // è®°å½•æˆåŠŸæŒ‡æ ‡
            successCounter.increment();
            
            // è´¨é‡æ£€æŸ¥
            ExecutionQuality quality = assessExecutionQuality(result, context);
            if (quality.getScore() < 0.7) {
                alertManager.sendAlert("Low execution quality", quality);
            }
            
        } catch (Exception e) {
            errorCounter.increment();
            alertManager.sendAlert("Execution failed", e);
            
        } finally {
            sample.stop(executionTimer);
        }
    }
    
    private ExecutionQuality assessExecutionQuality(String result, ExecutionContext context) {
        return ExecutionQuality.builder()
            .completeness(assessCompleteness(result, context))
            .accuracy(assessAccuracy(result, context))
            .efficiency(assessEfficiency(context))
            .build();
    }
}
```

#### 3. æ±‡æ€»å±‚ (SummaryAgent)

**èŒè´£å®šä¹‰**ï¼š
- **ç»“æœæ•´åˆ**ï¼šå°†æ‰§è¡Œå±‚çš„åˆ†æ•£ç»“æœæ•´åˆä¸ºè¿è´¯çš„è¾“å‡º
- **è´¨é‡ä¿è¯**ï¼šéªŒè¯æœ€ç»ˆç»“æœçš„å®Œæ•´æ€§å’Œå‡†ç¡®æ€§
- **æ ¼å¼åŒ–è¾“å‡º**ï¼šæ ¹æ®ç”¨æˆ·éœ€æ±‚ç”Ÿæˆé€‚å½“æ ¼å¼çš„æœ€ç»ˆç­”æ¡ˆ

**å®ç°æ¶æ„**ï¼š
```java
public class SummaryAgent extends BaseAgent {
    private ResultIntegrator integrator;
    private QualityValidator validator;
    private OutputFormatter formatter;
    
    @Override
    public String step() {
        try {
            // æ”¶é›†æ‰€æœ‰æ‰§è¡Œç»“æœ
            List<ExecutionResult> executionResults = collectExecutionResults();
            
            // æ•´åˆç»“æœ
            IntegratedResult integrated = integrator.integrate(executionResults);
            
            // è´¨é‡éªŒè¯
            ValidationResult validation = validator.validate(integrated);
            if (!validation.isValid()) {
                return handleValidationFailure(validation);
            }
            
            // æ ¼å¼åŒ–æœ€ç»ˆè¾“å‡º
            String finalOutput = formatter.format(integrated, context.getOutputFormat());
            
            setState(AgentState.FINISHED);
            return finalOutput;
            
        } catch (Exception e) {
            log.error("Summary generation failed", e);
            setState(AgentState.ERROR);
            return generateErrorSummary(e);
        }
    }
    
    private List<ExecutionResult> collectExecutionResults() {
        // ä»ä¸Šä¸‹æ–‡ä¸­æ”¶é›†æ‰€æœ‰æ‰§è¡Œç»“æœ
        return context.getTaskProductFiles().stream()
                .map(this::parseExecutionResult)
                .collect(Collectors.toList());
    }
    
    private String handleValidationFailure(ValidationResult validation) {
        // å¤„ç†éªŒè¯å¤±è´¥çš„æƒ…å†µ
        List<String> issues = validation.getIssues();
        
        // å°è¯•è‡ªåŠ¨ä¿®å¤
        for (String issue : issues) {
            if (canAutoFix(issue)) {
                autoFixIssue(issue);
            }
        }
        
        // é‡æ–°éªŒè¯
        ValidationResult revalidation = validator.validate(getLatestResult());
        if (revalidation.isValid()) {
            return formatter.format(getLatestResult(), context.getOutputFormat());
        }
        
        // æ— æ³•ä¿®å¤ï¼Œè¿”å›éƒ¨åˆ†ç»“æœ
        return generatePartialResult(validation);
    }
}
```

### åä½œæµç¨‹è®¾è®¡

Plan-Solveæ¨¡å¼ä¸­å„ç»„ä»¶çš„åä½œéµå¾ªæ¸…æ™°çš„å·¥ä½œæµç¨‹ï¼š

```java
public class PlanSolveHandler implements AgentHandlerService {
    
    @Override
    public String handle(AgentContext agentContext, AgentRequest request) {
        // 1. åˆå§‹åŒ–å„å±‚Agent
        PlanningAgent planningAgent = new PlanningAgent(agentContext);
        ExecutorAgent executorAgent = new ExecutorAgent(agentContext);
        SummaryAgent summaryAgent = new SummaryAgent(agentContext);
        
        // è®¾ç½®æŸ¥è¯¢ç›¸å…³çš„ç³»ç»Ÿæç¤º
        summaryAgent.setSystemPrompt(
            summaryAgent.getSystemPrompt().replace("{{query}}", request.getQuery())
        );
        
        try {
            // 2. è§„åˆ’é˜¶æ®µï¼šåˆ¶å®šæ‰§è¡Œè®¡åˆ’
            String planningResult = planningAgent.run(agentContext.getQuery());
            
            // 3. æ‰§è¡Œé˜¶æ®µï¼šæŒ‰è®¡åˆ’æ‰§è¡Œä»»åŠ¡
            int stepIndex = 0;
            int maxSteps = genieConfig.getPlannerMaxSteps();
            
            while (stepIndex <= maxSteps) {
                // è§£æè§„åˆ’ç»“æœä¸ºå…·ä½“ä»»åŠ¡
                List<String> tasks = parsePlanningResult(planningResult);
                
                if (tasks.isEmpty()) {
                    break; // æ²¡æœ‰æ›´å¤šä»»åŠ¡éœ€è¦æ‰§è¡Œ
                }
                
                // æ‰§è¡Œä»»åŠ¡
                String executionResult = executeTasksBatch(executorAgent, tasks);
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’
                if (needsReplanning(executionResult)) {
                    planningResult = planningAgent.run("Replan based on: " + executionResult);
                }
                
                stepIndex++;
            }
            
            // 4. æ±‡æ€»é˜¶æ®µï¼šæ•´åˆæœ€ç»ˆç»“æœ
            return summaryAgent.run(agentContext.getQuery());
            
        } catch (Exception e) {
            log.error("Plan-Solve execution failed", e);
            return handleExecutionError(e, agentContext);
        }
    }
    
    private List<String> parsePlanningResult(String planningResult) {
        // è§£æè§„åˆ’ç»“æœï¼Œæå–å…·ä½“ä»»åŠ¡
        return Arrays.stream(planningResult.split("<sep>"))
                .map(task -> "ä½ çš„ä»»åŠ¡æ˜¯ï¼š" + task.trim())
                .filter(task -> !task.isEmpty())
                .collect(Collectors.toList());
    }
    
    private String executeTasksBatch(ExecutorAgent executor, List<String> tasks) {
        if (tasks.size() == 1) {
            // å•ä¸ªä»»åŠ¡ç›´æ¥æ‰§è¡Œ
            return executor.run(tasks.get(0));
        } else {
            // å¤šä»»åŠ¡å¹¶å‘æ‰§è¡Œ
            return executeTasksInParallel(executor, tasks);
        }
    }
}
```

## Plan-Solveæ¨¡å¼çš„é€‚ç”¨åœºæ™¯

### 1. å¤æ‚é¡¹ç›®ä»»åŠ¡

**ç‰¹å¾åˆ†æ**ï¼š
- ä»»åŠ¡å…·æœ‰æ˜ç¡®çš„ç›®æ ‡å’Œçº¦æŸæ¡ä»¶
- éœ€è¦åè°ƒå¤šä¸ªå­ä»»åŠ¡å’Œèµ„æº
- å¯¹æ‰§è¡Œæ•ˆç‡å’Œç»“æœè´¨é‡è¦æ±‚è¾ƒé«˜

**å…¸å‹åº”ç”¨åœºæ™¯**ï¼š
- è½¯ä»¶å¼€å‘é¡¹ç›®è§„åˆ’
- å¸‚åœºè¥é”€æ´»åŠ¨ç­–åˆ’
- ç ”å‘é¡¹ç›®ç®¡ç†
- ä¾›åº”é“¾ä¼˜åŒ–

**å®ç°ç¤ºä¾‹**ï¼š
```java
public class ProjectPlanningAgent extends PlanningAgent {
    
    @Override
    protected Plan generatePlan(String projectDescription) {
        // 1. é¡¹ç›®éœ€æ±‚åˆ†æ
        ProjectRequirements requirements = analyzeRequirements(projectDescription);
        
        // 2. èµ„æºèƒ½åŠ›è¯„ä¼°
        ResourceCapability capability = assessResourceCapability();
        
        // 3. ä»»åŠ¡åˆ†è§£
        List<Task> tasks = decomposeIntoTasks(requirements);
        
        // 4. ä¾èµ–å…³ç³»åˆ†æ
        DependencyGraph dependencies = analyzeDependencies(tasks);
        
        // 5. æ—¶é—´ä¼°ç®—
        Map<Task, Duration> timeEstimates = estimateTaskDurations(tasks);
        
        // 6. èµ„æºåˆ†é…
        ResourceAllocation allocation = allocateResources(tasks, capability);
        
        // 7. é£é™©è¯„ä¼°
        List<Risk> risks = identifyRisks(tasks, dependencies);
        
        // 8. ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
        return Plan.builder()
                .tasks(tasks)
                .dependencies(dependencies)
                .timeEstimates(timeEstimates)
                .resourceAllocation(allocation)
                .risks(risks)
                .milestones(defineMilestones(tasks))
                .build();
    }
    
    private List<Task> decomposeIntoTasks(ProjectRequirements requirements) {
        List<Task> tasks = new ArrayList<>();
        
        // æŒ‰ç…§é¡¹ç›®é˜¶æ®µåˆ†è§£ä»»åŠ¡
        for (ProjectPhase phase : requirements.getPhases()) {
            tasks.addAll(decomposePhase(phase));
        }
        
        // æ·»åŠ æ¨ªåˆ‡å…³æ³¨ç‚¹ä»»åŠ¡
        tasks.addAll(createCrossCuttingTasks(requirements));
        
        return tasks;
    }
}
```

### 2. å¤šå·¥å…·åä½œä»»åŠ¡

**ç‰¹å¾åˆ†æ**ï¼š
- éœ€è¦è°ƒç”¨å¤šç§ä¸åŒçš„å·¥å…·å’ŒæœåŠ¡
- å·¥å…·é—´å­˜åœ¨æ•°æ®æµå’Œæ§åˆ¶æµä¾èµ–
- å¯¹å·¥å…·è°ƒç”¨çš„é¡ºåºå’Œå‚æ•°æœ‰ç‰¹å®šè¦æ±‚

**åä½œæ¨¡å¼è®¾è®¡**ï¼š
```java
public class MultiToolCoordinationPlan {
    private Map<String, ToolCapability> availableTools;
    private List<ToolChain> toolChains;
    
    public ExecutionPlan createCoordinationPlan(TaskRequirement requirement) {
        // 1. åˆ†æä»»åŠ¡éœ€è¦çš„èƒ½åŠ›
        Set<Capability> requiredCapabilities = requirement.getRequiredCapabilities();
        
        // 2. åŒ¹é…å¯ç”¨å·¥å…·
        Map<Capability, List<Tool>> capabilityMapping = matchToolsToCapabilities(
            requiredCapabilities, availableTools
        );
        
        // 3. ç”Ÿæˆå·¥å…·è°ƒç”¨é“¾
        List<ToolChain> chains = generateToolChains(capabilityMapping, requirement);
        
        // 4. ä¼˜åŒ–è°ƒç”¨é¡ºåº
        List<ToolChain> optimizedChains = optimizeExecutionOrder(chains);
        
        // 5. å¤„ç†æ•°æ®æµä¾èµ–
        DataFlowGraph dataFlow = buildDataFlowGraph(optimizedChains);
        
        return ExecutionPlan.builder()
                .toolChains(optimizedChains)
                .dataFlow(dataFlow)
                .parallelizationStrategy(determineParallelization(optimizedChains))
                .errorHandlingStrategy(createErrorHandlingStrategy())
                .build();
    }
    
    private List<ToolChain> optimizeExecutionOrder(List<ToolChain> chains) {
        // ä½¿ç”¨æ‹“æ‰‘æ’åºç¡®å®šæœ€ä¼˜æ‰§è¡Œé¡ºåº
        DirectedAcyclicGraph<ToolChain, DefaultEdge> dag = buildDependencyDAG(chains);
        TopologicalOrderIterator<ToolChain, DefaultEdge> iterator = 
            new TopologicalOrderIterator<>(dag);
        
        List<ToolChain> optimizedOrder = new ArrayList<>();
        while (iterator.hasNext()) {
            optimizedOrder.add(iterator.next());
        }
        
        return optimizedOrder;
    }
}
```

### 3. è´¨é‡è¦æ±‚é«˜çš„ä»»åŠ¡

**ç‰¹å¾åˆ†æ**ï¼š
- å¯¹ç»“æœçš„å‡†ç¡®æ€§å’Œå®Œæ•´æ€§è¦æ±‚æé«˜
- éœ€è¦å¤šå±‚éªŒè¯å’Œè´¨é‡ä¿è¯æœºåˆ¶
- é”™è¯¯æˆæœ¬é«˜ï¼Œéœ€è¦è°¨æ…çš„é£é™©æ§åˆ¶

**è´¨é‡ä¿è¯æ¡†æ¶**ï¼š
```java
public class HighQualityExecutionFramework {
    private List<QualityGate> qualityGates;
    private ValidationChain validationChain;
    
    public QualityAssuredResult executeWithQualityControl(Plan plan) {
        List<ExecutionResult> results = new ArrayList<>();
        
        for (Task task : plan.getTasks()) {
            try {
                // æ‰§è¡Œå‰è´¨é‡é—¨æ£€æŸ¥
                QualityGateResult preCheck = validatePreConditions(task);
                if (!preCheck.passed()) {
                    throw new QualityException("Pre-condition failed: " + preCheck.getIssues());
                }
                
                // æ‰§è¡Œä»»åŠ¡
                ExecutionResult result = executeTaskWithRetry(task);
                
                // æ‰§è¡Œåè´¨é‡éªŒè¯
                ValidationResult validation = validationChain.validate(result);
                if (!validation.isValid()) {
                    // å°è¯•è‡ªåŠ¨ä¿®å¤
                    result = attemptAutoFix(result, validation);
                    
                    // é‡æ–°éªŒè¯
                    validation = validationChain.validate(result);
                    if (!validation.isValid()) {
                        throw new QualityException("Quality validation failed: " + validation.getIssues());
                    }
                }
                
                results.add(result);
                
            } catch (Exception e) {
                // é«˜è´¨é‡è¦æ±‚ä¸‹çš„é”™è¯¯å¤„ç†
                handleHighQualityExecutionError(e, task, results);
            }
        }
        
        // æœ€ç»ˆè´¨é‡å®¡è®¡
        QualityAuditResult audit = performFinalQualityAudit(results);
        
        return QualityAssuredResult.builder()
                .results(results)
                .qualityScore(audit.getOverallScore())
                .qualityReport(audit.getReport())
                .build();
    }
    
    private ExecutionResult executeTaskWithRetry(Task task) {
        int maxRetries = 3;
        int attempt = 0;
        
        while (attempt < maxRetries) {
            try {
                return executeTask(task);
            } catch (TransientException e) {
                attempt++;
                if (attempt >= maxRetries) {
                    throw e;
                }
                
                // æŒ‡æ•°é€€é¿é‡è¯•
                sleep(Duration.ofSeconds((long) Math.pow(2, attempt)));
            }
        }
        
        throw new RuntimeException("Max retries exceeded");
    }
}
```

## Plan-Solveæ¨¡å¼çš„ä¼˜åŒ–ç­–ç•¥

### 1. åˆ†å±‚ä¼˜åŒ–ç­–ç•¥

**æˆ˜ç•¥å±‚ä¼˜åŒ–**ï¼š
```java
public class StrategicOptimizer {
    
    public OptimizedPlan optimizeStrategicPlan(Plan originalPlan, OptimizationContext context) {
        // 1. ç›®æ ‡å¯¹é½ä¼˜åŒ–
        Plan goalAlignedPlan = alignWithBusinessGoals(originalPlan, context.getBusinessGoals());
        
        // 2. èµ„æºæ•ˆç‡ä¼˜åŒ–
        Plan resourceOptimizedPlan = optimizeResourceUtilization(goalAlignedPlan, context.getResourceConstraints());
        
        // 3. é£é™©æœ€å°åŒ–ä¼˜åŒ–
        Plan riskOptimizedPlan = minimizeRisks(resourceOptimizedPlan, context.getRiskTolerance());
        
        // 4. æ—¶é—´å‹ç¼©ä¼˜åŒ–
        Plan timeOptimizedPlan = optimizeTimeline(riskOptimizedPlan, context.getTimeConstraints());
        
        return timeOptimizedPlan;
    }
    
    private Plan optimizeResourceUtilization(Plan plan, ResourceConstraints constraints) {
        // ä½¿ç”¨çº¿æ€§è§„åˆ’ä¼˜åŒ–èµ„æºåˆ†é…
        LinearProgrammingOptimizer optimizer = new LinearProgrammingOptimizer();
        
        // å®šä¹‰ç›®æ ‡å‡½æ•°ï¼šæœ€å¤§åŒ–èµ„æºåˆ©ç”¨ç‡
        ObjectiveFunction objective = new ObjectiveFunction(
            extractResourceCoefficients(plan), 
            GoalType.MAXIMIZE
        );
        
        // å®šä¹‰çº¦æŸæ¡ä»¶
        List<LinearConstraint> linearConstraints = buildResourceConstraints(plan, constraints);
        
        // æ±‚è§£ä¼˜åŒ–é—®é¢˜
        OptimizationResult result = optimizer.optimize(objective, linearConstraints);
        
        // æ ¹æ®ä¼˜åŒ–ç»“æœè°ƒæ•´è®¡åˆ’
        return adjustPlanBasedOnOptimization(plan, result);
    }
}
```

**æˆ˜æœ¯å±‚ä¼˜åŒ–**ï¼š
```java
public class TacticalOptimizer {
    
    public ExecutionStrategy optimizeExecutionStrategy(List<Task> tasks, ExecutionContext context) {
        // 1. å¹¶è¡Œåº¦åˆ†æ
        ParallelizationAnalysis parallelAnalysis = analyzeParallelizationOpportunities(tasks);
        
        // 2. è´Ÿè½½å‡è¡¡ä¼˜åŒ–
        LoadBalancingStrategy loadBalancing = optimizeLoadBalancing(tasks, context.getExecutors());
        
        // 3. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
        CachingStrategy caching = optimizeCachingStrategy(tasks, context.getCacheCapacity());
        
        // 4. å®¹é”™ç­–ç•¥ä¼˜åŒ–
        FaultToleranceStrategy faultTolerance = optimizeFaultTolerance(tasks, context.getReliabilityRequirements());
        
        return ExecutionStrategy.builder()
                .parallelization(parallelAnalysis.getStrategy())
                .loadBalancing(loadBalancing)
                .caching(caching)
                .faultTolerance(faultTolerance)
                .build();
    }
}
```

### 2. åŠ¨æ€è°ƒæ•´æœºåˆ¶

**è‡ªé€‚åº”è®¡åˆ’è°ƒæ•´**ï¼š
```java
public class AdaptivePlanManager {
    private PlanningAgent planningAgent;
    private ExecutionMonitor executionMonitor;
    
    public void manageAdaptivePlanning(ExecutionContext context) {
        // æŒç»­ç›‘æ§æ‰§è¡ŒçŠ¶æ€
        executionMonitor.startMonitoring(context, new ExecutionCallback() {
            
            @Override
            public void onTaskCompleted(Task task, ExecutionResult result) {
                // ä»»åŠ¡å®Œæˆåçš„è®¡åˆ’è°ƒæ•´
                adjustPlanAfterTaskCompletion(task, result);
            }
            
            @Override
            public void onExecutionDelayed(Task task, Duration delay) {
                // æ‰§è¡Œå»¶è¿Ÿçš„è®¡åˆ’è°ƒæ•´
                adjustPlanForDelay(task, delay);
            }
            
            @Override
            public void onResourceConstraintChanged(ResourceConstraint constraint) {
                // èµ„æºçº¦æŸå˜åŒ–çš„è®¡åˆ’è°ƒæ•´
                adjustPlanForResourceChange(constraint);
            }
            
            @Override
            public void onExternalEventOccurred(ExternalEvent event) {
                // å¤–éƒ¨äº‹ä»¶çš„è®¡åˆ’è°ƒæ•´
                adjustPlanForExternalEvent(event);
            }
        });
    }
    
    private void adjustPlanAfterTaskCompletion(Task task, ExecutionResult result) {
        if (result.getQuality() > 0.9) {
            // é«˜è´¨é‡ç»“æœï¼šå¯èƒ½åŠ å¿«åç»­ä»»åŠ¡
            accelerateSubsequentTasks(task);
        } else if (result.getQuality() < 0.7) {
            // ä½è´¨é‡ç»“æœï¼šéœ€è¦é¢å¤–çš„è´¨é‡ä¿è¯æ­¥éª¤
            addQualityAssuranceSteps(task);
        }
        
        // æ ¹æ®å®é™…æ‰§è¡Œæ—¶é—´è°ƒæ•´æ—¶é—´ä¼°ç®—æ¨¡å‹
        updateTimeEstimationModel(task, result.getExecutionTime());
    }
}
```

### 3. æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

**è®¡ç®—èµ„æºä¼˜åŒ–**ï¼š
```java
public class ComputationalResourceOptimizer {
    private ResourcePool resourcePool;
    private LoadBalancer loadBalancer;
    
    public OptimizedExecution optimizeComputationalExecution(Plan plan) {
        // 1. è®¡ç®—å¤æ‚åº¦åˆ†æ
        Map<Task, ComputationalComplexity> complexities = analyzeComputationalComplexities(plan.getTasks());
        
        // 2. èµ„æºéœ€æ±‚é¢„æµ‹
        Map<Task, ResourceRequirement> requirements = predictResourceRequirements(complexities);
        
        // 3. åŠ¨æ€èµ„æºåˆ†é…
        ResourceAllocationPlan allocation = allocateResourcesDynamically(requirements);
        
        // 4. æ‰§è¡Œä¼˜åŒ–
        return OptimizedExecution.builder()
                .resourceAllocation(allocation)
                .executionOrder(optimizeExecutionOrder(plan.getTasks(), allocation))
                .loadBalancingStrategy(loadBalancer.createStrategy(allocation))
                .build();
    }
    
    private ResourceAllocationPlan allocateResourcesDynamically(Map<Task, ResourceRequirement> requirements) {
        ResourceAllocationPlan plan = new ResourceAllocationPlan();
        
        // æŒ‰èµ„æºéœ€æ±‚æ’åºä»»åŠ¡
        List<Task> sortedTasks = requirements.entrySet().stream()
                .sorted(Map.Entry.<Task, ResourceRequirement>comparingByValue(
                    Comparator.comparing(ResourceRequirement::getPriority).reversed()
                ))
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
        
        // è´ªå¿ƒç®—æ³•åˆ†é…èµ„æº
        for (Task task : sortedTasks) {
            ResourceRequirement requirement = requirements.get(task);
            Resource allocatedResource = resourcePool.allocateBestFit(requirement);
            
            if (allocatedResource != null) {
                plan.addAllocation(task, allocatedResource);
            } else {
                // èµ„æºä¸è¶³ï¼Œæ·»åŠ åˆ°ç­‰å¾…é˜Ÿåˆ—
                plan.addToWaitingQueue(task, requirement);
            }
        }
        
        return plan;
    }
}
```

## ä¼ä¸šçº§åº”ç”¨è€ƒè™‘

### 1. å¯æ‰©å±•æ€§è®¾è®¡

**æ°´å¹³æ‰©å±•æ¶æ„**ï¼š
```java
@Configuration
public class ScalablePlanSolveConfig {
    
    @Bean
    @ConditionalOnProperty("plansolver.mode=distributed")
    public DistributedPlanningCoordinator distributedCoordinator() {
        return new DistributedPlanningCoordinator();
    }
    
    @Bean
    public PlanPartitioner planPartitioner() {
        return new PlanPartitioner();
    }
    
    @Bean
    public ExecutionCluster executionCluster() {
        return ExecutionCluster.builder()
                .nodeManager(new ExecutionNodeManager())
                .loadBalancer(new RoundRobinLoadBalancer())
                .faultDetector(new HealthCheckBasedFaultDetector())
                .build();
    }
}

public class DistributedPlanningCoordinator {
    private PlanPartitioner partitioner;
    private ExecutionCluster cluster;
    
    public CompletableFuture<PlanExecutionResult> executeDistributedPlan(Plan plan) {
        // 1. è®¡åˆ’åˆ†åŒº
        List<PlanPartition> partitions = partitioner.partition(plan);
        
        // 2. åˆ†å¸ƒå¼æ‰§è¡Œ
        List<CompletableFuture<PartitionResult>> futures = partitions.stream()
                .map(partition -> cluster.executePartition(partition))
                .collect(Collectors.toList());
        
        // 3. ç»“æœåˆå¹¶
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> {
                    List<PartitionResult> results = futures.stream()
                            .map(CompletableFuture::join)
                            .collect(Collectors.toList());
                    return mergePartitionResults(results);
                });
    }
}
```

### 2. å¯é æ€§ä¿éšœ

**æ•…éšœæ¢å¤æœºåˆ¶**ï¼š
```java
public class FaultTolerantPlanSolver {
    private CheckpointManager checkpointManager;
    private FailureDetector failureDetector;
    private RecoveryManager recoveryManager;
    
    public PlanExecutionResult executeWithFaultTolerance(Plan plan) {
        // åˆ›å»ºæ‰§è¡Œä¼šè¯
        ExecutionSession session = createExecutionSession(plan);
        
        try {
            return executeWithCheckpoints(session);
        } catch (FaultException e) {
            return recoverFromFault(session, e);
        }
    }
    
    private PlanExecutionResult executeWithCheckpoints(ExecutionSession session) {
        Plan plan = session.getPlan();
        
        for (int i = 0; i < plan.getTasks().size(); i++) {
            Task task = plan.getTasks().get(i);
            
            // åˆ›å»ºæ£€æŸ¥ç‚¹
            Checkpoint checkpoint = checkpointManager.createCheckpoint(session);
            
            try {
                // æ‰§è¡Œä»»åŠ¡
                ExecutionResult result = executeTask(task);
                
                // æ›´æ–°ä¼šè¯çŠ¶æ€
                session.recordTaskResult(task, result);
                
                // ç¡®è®¤æ£€æŸ¥ç‚¹
                checkpointManager.confirmCheckpoint(checkpoint);
                
            } catch (Exception e) {
                // æ•…éšœæ¢å¤
                checkpointManager.rollbackToCheckpoint(checkpoint);
                throw new FaultException("Task execution failed: " + task.getName(), e);
            }
        }
        
        return session.getFinalResult();
    }
    
    private PlanExecutionResult recoverFromFault(ExecutionSession session, FaultException fault) {
        RecoveryStrategy strategy = recoveryManager.determineRecoveryStrategy(fault);
        
        switch (strategy.getType()) {
            case RETRY:
                return retryExecution(session, strategy);
            case REPLAN:
                return replanAndExecute(session, strategy);
            case PARTIAL_RECOVERY:
                return recoverPartially(session, strategy);
            default:
                throw new RecoveryException("Unknown recovery strategy", fault);
        }
    }
}
```

## å°ç»“

Plan-Solveæ€ç»´æ¨¡å¼é€šè¿‡è§„åˆ’ä¸æ‰§è¡Œçš„æ¸…æ™°åˆ†ç¦»ï¼Œä¸ºå¤æ‚ä»»åŠ¡æä¾›äº†ç³»ç»ŸåŒ–çš„è§£å†³æ–¹æ¡ˆã€‚å…¶ä¸»è¦ä¼˜åŠ¿åŒ…æ‹¬ï¼š

1. **å…¨å±€ä¼˜åŒ–èƒ½åŠ›**ï¼šé€šè¿‡é¢„å…ˆè§„åˆ’å®ç°èµ„æºå’Œæ—¶é—´çš„å…¨å±€æœ€ä¼˜é…ç½®
2. **é«˜æ‰§è¡Œæ•ˆç‡**ï¼šè¯¦ç»†è®¡åˆ’å‡å°‘æ‰§è¡Œè¿‡ç¨‹ä¸­çš„ä¸ç¡®å®šæ€§å’Œæµªè´¹
3. **è´¨é‡å¯æ§æ€§**ï¼šåˆ†å±‚éªŒè¯å’Œç›‘æ§ç¡®ä¿é«˜è´¨é‡ç»“æœ
4. **å¯æ‰©å±•æ€§**ï¼šæ¸…æ™°çš„æ¶æ„ä¾¿äºç³»ç»Ÿæ‰©å±•å’Œä¼˜åŒ–

Plan-Solveæ¨¡å¼ç‰¹åˆ«é€‚åˆä¼ä¸šçº§åº”ç”¨åœºæ™¯ï¼Œå¦‚é¡¹ç›®ç®¡ç†ã€ä¸šåŠ¡æµç¨‹è‡ªåŠ¨åŒ–ã€èµ„æºè°ƒåº¦ç­‰éœ€è¦é«˜å¯é æ€§å’Œå¯é¢„æµ‹æ€§çš„ä»»åŠ¡ã€‚é€šè¿‡åˆç†çš„ä¼˜åŒ–ç­–ç•¥å’Œå·¥ç¨‹å®è·µï¼Œå¯ä»¥æ„å»ºå‡ºé«˜æ•ˆã€å¯é çš„Plan-Solveæ™ºèƒ½ä½“ç³»ç»Ÿã€‚

## æ‰©å±•é˜…è¯»

1. Wang, X., et al. (2023). "Plan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning by Large Language Models"
2. Russell, S. & Norvig, P. (2021). "Artificial Intelligence: A Modern Approach" - Chapter 10: Classical Planning
3. Ghallab, M., et al. (2004). "Automated Planning: Theory and Practice"
4. Dean, T. & Wellman, M. (1991). "Planning and Control"

## å®è·µé¡¹ç›®

1. **é¡¹ç›®ç®¡ç†æ™ºèƒ½ä½“**ï¼šæ„å»ºèƒ½å¤Ÿè‡ªåŠ¨è¿›è¡Œé¡¹ç›®è§„åˆ’å’Œæ‰§è¡Œç›‘æ§çš„æ™ºèƒ½åŠ©æ‰‹
2. **èµ„æºä¼˜åŒ–ç³»ç»Ÿ**ï¼šå¼€å‘åŸºäºPlan-Solveæ¨¡å¼çš„èµ„æºåˆ†é…ä¼˜åŒ–ç³»ç»Ÿ
3. **å·¥ä½œæµè‡ªåŠ¨åŒ–å¹³å°**ï¼šå®ç°æ”¯æŒå¤æ‚ä¸šåŠ¡æµç¨‹çš„è‡ªåŠ¨åŒ–æ‰§è¡Œå¹³å°
4. **è´¨é‡ä¿è¯ç³»ç»Ÿ**ï¼šæ„å»ºå…·æœ‰å¤šå±‚è´¨é‡éªŒè¯çš„é«˜è´¨é‡ä»»åŠ¡æ‰§è¡Œç³»ç»Ÿ
