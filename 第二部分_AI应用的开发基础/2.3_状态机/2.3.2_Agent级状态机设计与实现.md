# 2.3.2 Agent级状态机设计与实现

## 学习目标

🏗️ **架构设计**
- 基于2.3.1的理论基础，设计Agent级状态机架构
- 掌握BaseAgent状态枚举（IDLE、RUNNING、FINISHED、ERROR）的设计模式

⚙️ **实现技术**  
- 学会实现Agent执行循环中的状态转换逻辑
- 理解Agent上下文状态管理与内存状态同步机制

🚀 **高级应用**
- 掌握多类型Agent（Planning、Executor、Summary）的状态协调模式
- 熟悉异常处理和状态恢复的实现策略

## 引言

在2.3.1节中，我们建立了AI应用状态机的理论基础，了解了从传统FSA到AI扩展状态机的演进过程。现在我们将这些理论应用到具体的Agent级状态机设计中。

Agent级状态机是AI应用系统的核心组件，它直接决定了Agent的行为模式和执行流程。在JoyAgent-JDGenie项目中，每个Agent都遵循统一的状态机接口，但根据其职责不同实现了差异化的状态转换逻辑。

本节将基于前面建立的设计原则，深入分析BaseAgent的状态机设计，并探讨不同类型Agent的状态机实现策略。

## 1. BaseAgent状态机核心设计

🏗️ **架构设计**

基于2.3.1节建立的设计原则，我们现在来设计Agent级状态机的具体实现。Agent状态机需要遵循以下原则：
- **状态互斥性**：Agent在任何时候只能处于一个明确的状态
- **转换确定性**：状态转换逻辑应该是可预测和可控的
- **完备性**：覆盖Agent执行过程中的所有可能状态
- **简洁性**：避免不必要的状态，保持设计简洁

### 1.1 状态枚举定义与语义

参考代码示例：**[CODE-002] AgentState枚举定义**

Agent状态枚举是状态机的核心，定义了Agent在执行过程中的所有可能状态。这种设计遵循了2.3.1节中提到的**状态简洁性原则**，用最少的状态覆盖了Agent的完整生命周期。

**状态语义详解：**

- **IDLE（空闲）**：Agent已初始化完成，系统资源已分配，等待任务输入
- **RUNNING（运行）**：Agent正在活跃执行，包括LLM推理、工具调用、结果处理  
- **FINISHED（完成）**：任务执行成功，Agent已产生最终输出，状态稳定
- **ERROR（错误）**：遇到致命错误，如Token限制超出、工具调用失败等

### 1.2 BaseAgent状态机实现架构

```java
/**
 * 代理基类 - 管理代理状态和执行的基础类
 */
@Slf4j
@Data
@Accessors(chain = true)
public abstract class BaseAgent {
    // 执行控制
    private AgentState state = AgentState.IDLE;
    private int maxSteps = 10;
    private int currentStep = 0;
    private int duplicateThreshold = 2;
    
    // 核心组件
    private Memory memory = new Memory();
    protected LLM llm;
    protected AgentContext context;
    public ToolCollection availableTools = new ToolCollection();
    
    /**
     * 运行代理主循环 - 状态机的核心控制逻辑
     */
    public String run(String query) {
        setState(AgentState.IDLE);
        
        if (!query.isEmpty()) {
            updateMemory(RoleType.USER, query, null);
        }
        
        List<String> results = new ArrayList<>();
        try {
            // 主执行循环 - 状态驱动的执行模式
            while (currentStep < maxSteps && state != AgentState.FINISHED) {
                currentStep++;
                log.info("{} {} Executing step {}/{}", 
                    context.getRequestId(), getName(), currentStep, maxSteps);
                
                String stepResult = step(); // 抽象方法，由子类实现具体逻辑
                results.add(stepResult);
                
                // 状态检查与转换逻辑
                if (shouldFinish(stepResult)) {
                    setState(AgentState.FINISHED);
                }
            }
            
            // 超出最大步数处理
            if (currentStep >= maxSteps) {
                currentStep = 0;
                setState(AgentState.IDLE);
                results.add("Terminated: Reached max steps (" + maxSteps + ")");
            }
            
        } catch (Exception e) {
            setState(AgentState.ERROR);
            log.error("Agent execution error: ", e);
            throw e;
        }
        
        return results.isEmpty() ? "No steps executed" : results.get(results.size() - 1);
    }
    
    /**
     * 抽象步骤执行方法 - 子类必须实现
     */
    public abstract String step();
    
    /**
     * 状态转换的安全控制
     */
    protected void setState(AgentState newState) {
        AgentState oldState = this.state;
        if (isValidTransition(oldState, newState)) {
            this.state = newState;
            onStateChanged(oldState, newState);
            log.debug("Agent state transition: {} -> {}", oldState, newState);
        } else {
            log.warn("Invalid state transition attempted: {} -> {}", oldState, newState);
        }
    }
}
```

### 1.3 状态转换验证机制

```java
/**
 * 状态转换有效性验证
 */
private boolean isValidTransition(AgentState from, AgentState to) {
    // 定义有效的状态转换规则
    switch (from) {
        case IDLE:
            return to == AgentState.RUNNING;
            
        case RUNNING:
            return to == AgentState.FINISHED || to == AgentState.ERROR || to == AgentState.RUNNING;
            
        case FINISHED:
            return to == AgentState.IDLE;
            
        case ERROR:
            return to == AgentState.IDLE; // 错误恢复
            
        default:
            return false;
    }
}

/**
 * 状态变更事件处理
 */
protected void onStateChanged(AgentState from, AgentState to) {
    // 发送状态变更通知
    if (printer != null) {
        printer.send("state", Map.of(
            "from", from.name(),
            "to", to.name(),
            "timestamp", System.currentTimeMillis()
        ));
    }
    
    // 执行状态相关的清理或初始化工作
    switch (to) {
        case IDLE:
            resetExecutionContext();
            break;
        case RUNNING:
            initializeExecution();
            break;
        case FINISHED:
            finalizeExecution();
            break;
        case ERROR:
            handleError();
            break;
    }
}
```

## 2. Agent执行循环与状态转换逻辑

### 2.1 ReAct模式下的状态循环

```java
/**
 * ReAct Agent实现 - 思考-行动-观察循环
 */
public class ReActAgent extends BaseAgent {
    
    @Override
    public String step() {
        String result = "";
        
        try {
            // 1. 思考阶段 (Thought)
            setState(AgentState.RUNNING);
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            // 2. 行动阶段 (Action)
            if (shouldAct(thought)) {
                String actionResult = act();
                result = actionResult;
                
                // 3. 观察阶段 (Observation)  
                if (shouldFinish(actionResult)) {
                    setState(AgentState.FINISHED);
                    return actionResult;
                }
            } else {
                // 直接输出思考结果，不执行工具
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (TokenLimitExceeded e) {
            log.warn("Token limit exceeded, finishing execution");
            setState(AgentState.FINISHED);
            return "Task completed due to token limit";
            
        } catch (Exception e) {
            log.error("Error in ReAct step execution", e);
            setState(AgentState.ERROR);
            throw e;
        }
        
        return result;
    }
    
    /**
     * 思考阶段 - 生成下一步行动策略
     */
    private String think() {
        List<Message> messages = memory.getMessages();
        messages.add(Message.systemMessage(getNextStepPrompt(), null));
        
        return llm.chat(messages).getContent();
    }
    
    /**
     * 行动阶段 - 执行工具调用或输出结果
     */
    private String act() {
        List<ToolCall> toolCalls = parseToolCalls(memory.getLastMessage());
        
        if (toolCalls.isEmpty()) {
            setState(AgentState.FINISHED);
            return memory.getLastMessage().getContent();
        }
        
        List<String> results = new ArrayList<>();
        for (ToolCall toolCall : toolCalls) {
            String result = executeTool(toolCall);
            results.add(result);
            
            // 添加工具执行结果到记忆
            Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
            memory.addMessage(toolMsg);
        }
        
        return String.join("\n\n", results);
    }
}
```

### 2.2 规划Agent的状态管理

```java
/**
 * 规划Agent - 负责任务分解和计划制定
 */
public class PlanningAgent extends BaseAgent {
    private PlanningTool planningTool;
    private boolean isColseUpdate = false; // 是否关闭动态更新
    
    @Override
    public String step() {
        try {
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            if (shouldAct(thought)) {
                return act();
            } else {
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (Exception e) {
            log.error("Planning agent step error", e);
            setState(AgentState.ERROR);
            throw e;
        }
    }
    
    @Override
    public String act() {
        // 检查是否已有计划且关闭动态更新
        if (isColseUpdate && Objects.nonNull(planningTool.getPlan())) {
            return getNextTask();
        }
        
        // 执行工具调用（通常是规划工具）
        List<String> results = new ArrayList<>();
        for (ToolCall toolCall : toolCalls) {
            String result = executeTool(toolCall);
            results.add(result);
            
            // 添加工具响应到记忆
            Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
            memory.addMessage(toolMsg);
        }
        
        // 检查计划是否完成
        if (Objects.nonNull(planningTool.getPlan())) {
            return getNextTask();
        }
        
        return String.join("\n\n", results);
    }
    
    /**
     * 获取下一个任务并管理计划执行状态
     */
    private String getNextTask() {
        Plan plan = planningTool.getPlan();
        
        // 检查所有任务是否完成
        boolean allComplete = plan.getStepStatus().stream()
            .allMatch(status -> "completed".equals(status));
            
        if (allComplete) {
            setState(AgentState.FINISHED);
            printer.send("plan", plan);
            return "finish";
        }
        
        // 返回当前步骤
        if (!plan.getCurrentStep().isEmpty()) {
            setState(AgentState.FINISHED);
            String[] currentSteps = plan.getCurrentStep().split("<sep>");
            printer.send("plan", plan);
            
            // 发送任务通知
            Arrays.stream(currentSteps)
                .forEach(step -> printer.send("task", step));
                
            return plan.getCurrentStep();
        }
        
        return "";
    }
}
```

### 2.3 执行Agent的状态协调

```java
/**
 * 执行Agent - 负责具体任务执行
 */
public class ExecutorAgent extends BaseAgent {
    
    @Override 
    public String step() {
        try {
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            if (shouldAct(thought)) {
                String result = act();
                return result;
            } else {
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (Exception e) {
            log.error("Executor agent step error", e);
            setState(AgentState.ERROR);
            throw e;
        }
    }
    
    @Override
    public String act() {
        List<String> results = new ArrayList<>();
        
        for (ToolCall toolCall : toolCalls) {
            try {
                String result = executeTool(toolCall);
                results.add(result);
                
                // 工具执行成功，更新记忆
                Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
                memory.addMessage(toolMsg);
                
            } catch (Exception e) {
                log.error("Tool execution failed: {}", toolCall.getName(), e);
                setState(AgentState.ERROR);
                throw e;
            }
        }
        
        // 检查是否完成
        String combinedResult = String.join("\n\n", results);
        if (shouldFinish(combinedResult)) {
            setState(AgentState.FINISHED);
        }
        
        return combinedResult;
    }
}
```

## 3. Agent上下文状态管理

### 3.1 AgentContext设计模式

```java
/**
 * Agent执行上下文 - 维护Agent运行时状态
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AgentContext {
    private String requestId;
    private String sessionId;
    private String query;
    
    // 状态信息
    private AgentState currentState;
    private long startTime;
    private long lastUpdateTime;
    
    // 执行环境
    private Map<String, Object> contextData = new ConcurrentHashMap<>();
    private List<FileInformation> taskProductFiles = new ArrayList<>();
    private CountDownLatch latch;
    
    /**
     * 线程安全的状态更新
     */
    public synchronized void updateState(AgentState newState) {
        AgentState oldState = this.currentState;
        this.currentState = newState;
        this.lastUpdateTime = System.currentTimeMillis();
        
        // 触发状态变更事件
        notifyStateChange(oldState, newState);
    }
    
    /**
     * 获取上下文快照
     */
    public AgentContextSnapshot createSnapshot() {
        return AgentContextSnapshot.builder()
            .requestId(requestId)
            .sessionId(sessionId)
            .currentState(currentState)
            .contextData(new HashMap<>(contextData))
            .timestamp(lastUpdateTime)
            .build();
    }
}
```

### 3.2 Memory状态同步机制

```java
/**
 * 记忆类 - 管理代理的消息历史和状态
 */
@Data
public class Memory {
    private List<Message> messages = new ArrayList<>();
    private volatile boolean dirty = false; // 标记内存是否需要同步
    
    /**
     * 线程安全的消息添加
     */
    public synchronized void addMessage(Message message) {
        messages.add(message);
        dirty = true;
        notifyMemoryUpdate();
    }
    
    /**
     * 清空工具执行历史 - 状态重置时调用
     */
    public void clearToolContext() {
        Iterator<Message> iterator = messages.iterator();
        while (iterator.hasNext()) {
            Message message = iterator.next();
            
            // 移除工具相关消息
            if (message.getRole() == RoleType.TOOL) {
                iterator.remove();
            }
            
            // 移除包含工具调用的助手消息
            if (message.getRole() == RoleType.ASSISTANT && 
                Objects.nonNull(message.getToolCalls()) && 
                !message.getToolCalls().isEmpty()) {
                iterator.remove();
            }
            
            // 移除状态相关的内部消息
            if (Objects.nonNull(message.getContent()) && 
                message.getContent().startsWith("根据当前状态和可用工具，确定下一步行动")) {
                iterator.remove();
            }
        }
        
        dirty = true;
    }
    
    /**
     * 获取最后一条消息的状态安全方法
     */
    public Message getLastMessage() {
        synchronized (messages) {
            return messages.isEmpty() ? null : messages.get(messages.size() - 1);
        }
    }
}
```

## 4. 多类型Agent的状态协调模式

### 4.1 Plan-Solve模式的状态协调

```java
/**
 * Plan-Solve处理器 - 协调多个Agent的状态
 */
@Component
public class PlanSolveHandlerImpl implements AgentHandlerService {
    
    @Override
    public String handle(AgentContext agentContext, AgentRequest request) {
        // 创建协作Agent
        PlanningAgent planning = new PlanningAgent(agentContext);
        ExecutorAgent executor = new ExecutorAgent(agentContext);
        SummaryAgent summary = new SummaryAgent(agentContext);
        
        // 第一阶段：规划
        String planningResult = planning.run(agentContext.getQuery());
        log.info("Planning phase completed with state: {}", planning.getState());
        
        int stepIdx = 0;
        int maxStepNum = genieConfig.getPlannerMaxSteps();
        
        // 第二阶段：执行循环
        while (stepIdx <= maxStepNum) {
            List<String> planningResults = Arrays.stream(planningResult.split("<sep>"))
                .map(task -> "你的任务是：" + task)
                .collect(Collectors.toList());
                
            String executorResult;
            agentContext.getTaskProductFiles().clear();
            
            if (planningResults.size() == 1) {
                // 单任务执行
                executorResult = executor.run(planningResults.get(0));
            } else {
                // 多任务并行执行
                executorResult = executeMultipleTasks(executor, planningResults);
            }
            
            log.info("Execution phase {} completed with state: {}", 
                stepIdx, executor.getState());
            
            // 检查执行结果
            if (executor.getState() == AgentState.FINISHED) {
                break;
            }
            
            stepIdx++;
        }
        
        // 第三阶段：总结
        summary.setSystemPrompt(summary.getSystemPrompt().replace("{{query}}", request.getQuery()));
        String summaryResult = summary.run("请总结执行结果");
        
        log.info("Summary phase completed with state: {}", summary.getState());
        
        return summaryResult;
    }
    
    /**
     * 多任务并行执行的状态协调
     */
    private String executeMultipleTasks(ExecutorAgent executor, List<String> tasks) {
        List<CompletableFuture<String>> futures = tasks.stream()
            .map(task -> CompletableFuture.supplyAsync(() -> {
                try {
                    return executor.run(task);
                } catch (Exception e) {
                    log.error("Task execution failed: {}", task, e);
                    return "Task failed: " + e.getMessage();
                }
            }))
            .collect(Collectors.toList());
            
        // 等待所有任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        
        // 收集结果
        return futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.joining("\n\n"));
    }
}
```

### 4.2 Agent状态一致性保证

```java
/**
 * Agent状态管理器 - 确保多Agent状态一致性
 */
@Component
public class AgentStateManager {
    private final Map<String, AgentStateInfo> agentStates = new ConcurrentHashMap<>();
    
    /**
     * 注册Agent状态
     */
    public void registerAgent(String agentId, BaseAgent agent) {
        AgentStateInfo stateInfo = AgentStateInfo.builder()
            .agentId(agentId)
            .agent(agent)
            .lastUpdateTime(System.currentTimeMillis())
            .build();
            
        agentStates.put(agentId, stateInfo);
    }
    
    /**
     * 同步更新Agent状态
     */
    public synchronized void updateAgentState(String agentId, AgentState newState) {
        AgentStateInfo stateInfo = agentStates.get(agentId);
        if (stateInfo != null) {
            AgentState oldState = stateInfo.getAgent().getState();
            stateInfo.getAgent().setState(newState);
            stateInfo.setLastUpdateTime(System.currentTimeMillis());
            
            // 通知其他相关Agent
            notifyStateChange(agentId, oldState, newState);
        }
    }
    
    /**
     * 检查Agent状态一致性
     */
    public boolean checkConsistency(String sessionId) {
        return agentStates.values().stream()
            .filter(info -> info.getSessionId().equals(sessionId))
            .map(info -> info.getAgent().getState())
            .allMatch(state -> state == AgentState.FINISHED || state == AgentState.ERROR);
    }
}
```

## 5. 状态机异常处理与恢复

### 5.1 异常状态的分类处理

```java
/**
 * Agent异常处理策略
 */
public class AgentExceptionHandler {
    
    public void handleException(BaseAgent agent, Exception e) {
        if (e instanceof TokenLimitExceeded) {
            // Token限制异常 - 优雅终止
            agent.setState(AgentState.FINISHED);
            log.warn("Agent {} reached token limit, finishing gracefully", 
                agent.getName());
                
        } else if (e instanceof ToolExecutionException) {
            // 工具执行异常 - 可恢复错误
            handleToolError(agent, (ToolExecutionException) e);
            
        } else if (e instanceof NetworkException) {
            // 网络异常 - 重试机制
            handleNetworkError(agent, (NetworkException) e);
            
        } else {
            // 未知异常 - 错误状态
            agent.setState(AgentState.ERROR);
            log.error("Unhandled exception in agent {}", agent.getName(), e);
        }
    }
    
    private void handleToolError(BaseAgent agent, ToolExecutionException e) {
        if (e.isRetryable() && agent.getCurrentStep() < agent.getMaxSteps()) {
            // 清理错误状态，继续执行
            agent.getMemory().clearToolContext();
            log.info("Tool error recovered, continuing execution");
        } else {
            agent.setState(AgentState.ERROR);
        }
    }
}
```

### 5.2 状态恢复机制

```java
/**
 * Agent状态恢复服务
 */
@Service
public class AgentRecoveryService {
    
    /**
     * 从快照恢复Agent状态
     */
    public void recoverFromSnapshot(BaseAgent agent, AgentSnapshot snapshot) {
        try {
            // 恢复基本状态
            agent.setState(snapshot.getState());
            agent.setCurrentStep(snapshot.getCurrentStep());
            
            // 恢复内存状态
            agent.getMemory().clear();
            agent.getMemory().addMessages(snapshot.getMessages());
            
            // 恢复上下文数据
            agent.getContext().getContextData().putAll(snapshot.getContextData());
            
            log.info("Agent {} recovered from snapshot at step {}", 
                agent.getName(), snapshot.getCurrentStep());
                
        } catch (Exception e) {
            log.error("Failed to recover agent from snapshot", e);
            agent.setState(AgentState.ERROR);
        }
    }
    
    /**
     * 检查点保存
     */
    public AgentSnapshot createCheckpoint(BaseAgent agent) {
        return AgentSnapshot.builder()
            .agentId(agent.getName())
            .state(agent.getState())
            .currentStep(agent.getCurrentStep())
            .messages(new ArrayList<>(agent.getMemory().getMessages()))
            .contextData(new HashMap<>(agent.getContext().getContextData()))
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

## 6. 小结

本节深入探讨了Agent级状态机的设计与实现，主要内容包括：

1. **状态枚举设计**：IDLE、RUNNING、FINISHED、ERROR四种状态的语义和转换规则
2. **执行循环控制**：基于状态驱动的Agent主循环实现
3. **上下文管理**：AgentContext和Memory的状态同步机制
4. **多Agent协调**：Plan-Solve模式下的状态协调策略
5. **异常处理**：不同类型异常的状态转换和恢复机制

通过这些设计模式，我们可以构建出健壮、可维护的Agent状态机系统，为复杂的AI应用提供稳定的执行基础。

## 延伸思考

1. 如何设计更细粒度的Agent状态以支持更复杂的执行流程？
2. 在分布式环境中，如何保证多个Agent实例的状态一致性？
3. 如何实现Agent状态的实时监控和可视化？
4. 如何设计Agent状态的版本管理和回滚机制？

下一节我们将探讨任务执行状态机与工作流管理，进一步深入状态机在AI应用中的应用。
