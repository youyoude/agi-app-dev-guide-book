# 2.3.2 Agentçº§çŠ¶æ€æœºè®¾è®¡ä¸å®ç°

## å­¦ä¹ ç›®æ ‡

ğŸ—ï¸ **æ¶æ„è®¾è®¡**
- åŸºäº2.3.1çš„ç†è®ºåŸºç¡€ï¼Œè®¾è®¡Agentçº§çŠ¶æ€æœºæ¶æ„
- æŒæ¡BaseAgentçŠ¶æ€æšä¸¾ï¼ˆIDLEã€RUNNINGã€FINISHEDã€ERRORï¼‰çš„è®¾è®¡æ¨¡å¼

âš™ï¸ **å®ç°æŠ€æœ¯**  
- å­¦ä¼šå®ç°Agentæ‰§è¡Œå¾ªç¯ä¸­çš„çŠ¶æ€è½¬æ¢é€»è¾‘
- ç†è§£Agentä¸Šä¸‹æ–‡çŠ¶æ€ç®¡ç†ä¸å†…å­˜çŠ¶æ€åŒæ­¥æœºåˆ¶

ğŸš€ **é«˜çº§åº”ç”¨**
- æŒæ¡å¤šç±»å‹Agentï¼ˆPlanningã€Executorã€Summaryï¼‰çš„çŠ¶æ€åè°ƒæ¨¡å¼
- ç†Ÿæ‚‰å¼‚å¸¸å¤„ç†å’ŒçŠ¶æ€æ¢å¤çš„å®ç°ç­–ç•¥

## å¼•è¨€

åœ¨2.3.1èŠ‚ä¸­ï¼Œæˆ‘ä»¬å»ºç«‹äº†AIåº”ç”¨çŠ¶æ€æœºçš„ç†è®ºåŸºç¡€ï¼Œäº†è§£äº†ä»ä¼ ç»ŸFSAåˆ°AIæ‰©å±•çŠ¶æ€æœºçš„æ¼”è¿›è¿‡ç¨‹ã€‚ç°åœ¨æˆ‘ä»¬å°†è¿™äº›ç†è®ºåº”ç”¨åˆ°å…·ä½“çš„Agentçº§çŠ¶æ€æœºè®¾è®¡ä¸­ã€‚

Agentçº§çŠ¶æ€æœºæ˜¯AIåº”ç”¨ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ï¼Œå®ƒç›´æ¥å†³å®šäº†Agentçš„è¡Œä¸ºæ¨¡å¼å’Œæ‰§è¡Œæµç¨‹ã€‚åœ¨JoyAgent-JDGenieé¡¹ç›®ä¸­ï¼Œæ¯ä¸ªAgentéƒ½éµå¾ªç»Ÿä¸€çš„çŠ¶æ€æœºæ¥å£ï¼Œä½†æ ¹æ®å…¶èŒè´£ä¸åŒå®ç°äº†å·®å¼‚åŒ–çš„çŠ¶æ€è½¬æ¢é€»è¾‘ã€‚

æœ¬èŠ‚å°†åŸºäºå‰é¢å»ºç«‹çš„è®¾è®¡åŸåˆ™ï¼Œæ·±å…¥åˆ†æBaseAgentçš„çŠ¶æ€æœºè®¾è®¡ï¼Œå¹¶æ¢è®¨ä¸åŒç±»å‹Agentçš„çŠ¶æ€æœºå®ç°ç­–ç•¥ã€‚

## 1. BaseAgentçŠ¶æ€æœºæ ¸å¿ƒè®¾è®¡

ğŸ—ï¸ **æ¶æ„è®¾è®¡**

åŸºäº2.3.1èŠ‚å»ºç«‹çš„è®¾è®¡åŸåˆ™ï¼Œæˆ‘ä»¬ç°åœ¨æ¥è®¾è®¡Agentçº§çŠ¶æ€æœºçš„å…·ä½“å®ç°ã€‚AgentçŠ¶æ€æœºéœ€è¦éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
- **çŠ¶æ€äº’æ–¥æ€§**ï¼šAgentåœ¨ä»»ä½•æ—¶å€™åªèƒ½å¤„äºä¸€ä¸ªæ˜ç¡®çš„çŠ¶æ€
- **è½¬æ¢ç¡®å®šæ€§**ï¼šçŠ¶æ€è½¬æ¢é€»è¾‘åº”è¯¥æ˜¯å¯é¢„æµ‹å’Œå¯æ§çš„
- **å®Œå¤‡æ€§**ï¼šè¦†ç›–Agentæ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ‰€æœ‰å¯èƒ½çŠ¶æ€
- **ç®€æ´æ€§**ï¼šé¿å…ä¸å¿…è¦çš„çŠ¶æ€ï¼Œä¿æŒè®¾è®¡ç®€æ´

### 1.1 çŠ¶æ€æšä¸¾å®šä¹‰ä¸è¯­ä¹‰

å‚è€ƒä»£ç ç¤ºä¾‹ï¼š**[CODE-002] AgentStateæšä¸¾å®šä¹‰**

AgentçŠ¶æ€æšä¸¾æ˜¯çŠ¶æ€æœºçš„æ ¸å¿ƒï¼Œå®šä¹‰äº†Agentåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ‰€æœ‰å¯èƒ½çŠ¶æ€ã€‚è¿™ç§è®¾è®¡éµå¾ªäº†2.3.1èŠ‚ä¸­æåˆ°çš„**çŠ¶æ€ç®€æ´æ€§åŸåˆ™**ï¼Œç”¨æœ€å°‘çš„çŠ¶æ€è¦†ç›–äº†Agentçš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸã€‚

**çŠ¶æ€è¯­ä¹‰è¯¦è§£ï¼š**

- **IDLEï¼ˆç©ºé—²ï¼‰**ï¼šAgentå·²åˆå§‹åŒ–å®Œæˆï¼Œç³»ç»Ÿèµ„æºå·²åˆ†é…ï¼Œç­‰å¾…ä»»åŠ¡è¾“å…¥
- **RUNNINGï¼ˆè¿è¡Œï¼‰**ï¼šAgentæ­£åœ¨æ´»è·ƒæ‰§è¡Œï¼ŒåŒ…æ‹¬LLMæ¨ç†ã€å·¥å…·è°ƒç”¨ã€ç»“æœå¤„ç†  
- **FINISHEDï¼ˆå®Œæˆï¼‰**ï¼šä»»åŠ¡æ‰§è¡ŒæˆåŠŸï¼ŒAgentå·²äº§ç”Ÿæœ€ç»ˆè¾“å‡ºï¼ŒçŠ¶æ€ç¨³å®š
- **ERRORï¼ˆé”™è¯¯ï¼‰**ï¼šé‡åˆ°è‡´å‘½é”™è¯¯ï¼Œå¦‚Tokené™åˆ¶è¶…å‡ºã€å·¥å…·è°ƒç”¨å¤±è´¥ç­‰

### 1.2 BaseAgentçŠ¶æ€æœºå®ç°æ¶æ„

```java
/**
 * ä»£ç†åŸºç±» - ç®¡ç†ä»£ç†çŠ¶æ€å’Œæ‰§è¡Œçš„åŸºç¡€ç±»
 */
@Slf4j
@Data
@Accessors(chain = true)
public abstract class BaseAgent {
    // æ‰§è¡Œæ§åˆ¶
    private AgentState state = AgentState.IDLE;
    private int maxSteps = 10;
    private int currentStep = 0;
    private int duplicateThreshold = 2;
    
    // æ ¸å¿ƒç»„ä»¶
    private Memory memory = new Memory();
    protected LLM llm;
    protected AgentContext context;
    public ToolCollection availableTools = new ToolCollection();
    
    /**
     * è¿è¡Œä»£ç†ä¸»å¾ªç¯ - çŠ¶æ€æœºçš„æ ¸å¿ƒæ§åˆ¶é€»è¾‘
     */
    public String run(String query) {
        setState(AgentState.IDLE);
        
        if (!query.isEmpty()) {
            updateMemory(RoleType.USER, query, null);
        }
        
        List<String> results = new ArrayList<>();
        try {
            // ä¸»æ‰§è¡Œå¾ªç¯ - çŠ¶æ€é©±åŠ¨çš„æ‰§è¡Œæ¨¡å¼
            while (currentStep < maxSteps && state != AgentState.FINISHED) {
                currentStep++;
                log.info("{} {} Executing step {}/{}", 
                    context.getRequestId(), getName(), currentStep, maxSteps);
                
                String stepResult = step(); // æŠ½è±¡æ–¹æ³•ï¼Œç”±å­ç±»å®ç°å…·ä½“é€»è¾‘
                results.add(stepResult);
                
                // çŠ¶æ€æ£€æŸ¥ä¸è½¬æ¢é€»è¾‘
                if (shouldFinish(stepResult)) {
                    setState(AgentState.FINISHED);
                }
            }
            
            // è¶…å‡ºæœ€å¤§æ­¥æ•°å¤„ç†
            if (currentStep >= maxSteps) {
                currentStep = 0;
                setState(AgentState.IDLE);
                results.add("Terminated: Reached max steps (" + maxSteps + ")");
            }
            
        } catch (Exception e) {
            setState(AgentState.ERROR);
            log.error("Agent execution error: ", e);
            throw e;
        }
        
        return results.isEmpty() ? "No steps executed" : results.get(results.size() - 1);
    }
    
    /**
     * æŠ½è±¡æ­¥éª¤æ‰§è¡Œæ–¹æ³• - å­ç±»å¿…é¡»å®ç°
     */
    public abstract String step();
    
    /**
     * çŠ¶æ€è½¬æ¢çš„å®‰å…¨æ§åˆ¶
     */
    protected void setState(AgentState newState) {
        AgentState oldState = this.state;
        if (isValidTransition(oldState, newState)) {
            this.state = newState;
            onStateChanged(oldState, newState);
            log.debug("Agent state transition: {} -> {}", oldState, newState);
        } else {
            log.warn("Invalid state transition attempted: {} -> {}", oldState, newState);
        }
    }
}
```

### 1.3 çŠ¶æ€è½¬æ¢éªŒè¯æœºåˆ¶

```java
/**
 * çŠ¶æ€è½¬æ¢æœ‰æ•ˆæ€§éªŒè¯
 */
private boolean isValidTransition(AgentState from, AgentState to) {
    // å®šä¹‰æœ‰æ•ˆçš„çŠ¶æ€è½¬æ¢è§„åˆ™
    switch (from) {
        case IDLE:
            return to == AgentState.RUNNING;
            
        case RUNNING:
            return to == AgentState.FINISHED || to == AgentState.ERROR || to == AgentState.RUNNING;
            
        case FINISHED:
            return to == AgentState.IDLE;
            
        case ERROR:
            return to == AgentState.IDLE; // é”™è¯¯æ¢å¤
            
        default:
            return false;
    }
}

/**
 * çŠ¶æ€å˜æ›´äº‹ä»¶å¤„ç†
 */
protected void onStateChanged(AgentState from, AgentState to) {
    // å‘é€çŠ¶æ€å˜æ›´é€šçŸ¥
    if (printer != null) {
        printer.send("state", Map.of(
            "from", from.name(),
            "to", to.name(),
            "timestamp", System.currentTimeMillis()
        ));
    }
    
    // æ‰§è¡ŒçŠ¶æ€ç›¸å…³çš„æ¸…ç†æˆ–åˆå§‹åŒ–å·¥ä½œ
    switch (to) {
        case IDLE:
            resetExecutionContext();
            break;
        case RUNNING:
            initializeExecution();
            break;
        case FINISHED:
            finalizeExecution();
            break;
        case ERROR:
            handleError();
            break;
    }
}
```

## 2. Agentæ‰§è¡Œå¾ªç¯ä¸çŠ¶æ€è½¬æ¢é€»è¾‘

### 2.1 ReActæ¨¡å¼ä¸‹çš„çŠ¶æ€å¾ªç¯

```java
/**
 * ReAct Agentå®ç° - æ€è€ƒ-è¡ŒåŠ¨-è§‚å¯Ÿå¾ªç¯
 */
public class ReActAgent extends BaseAgent {
    
    @Override
    public String step() {
        String result = "";
        
        try {
            // 1. æ€è€ƒé˜¶æ®µ (Thought)
            setState(AgentState.RUNNING);
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            // 2. è¡ŒåŠ¨é˜¶æ®µ (Action)
            if (shouldAct(thought)) {
                String actionResult = act();
                result = actionResult;
                
                // 3. è§‚å¯Ÿé˜¶æ®µ (Observation)  
                if (shouldFinish(actionResult)) {
                    setState(AgentState.FINISHED);
                    return actionResult;
                }
            } else {
                // ç›´æ¥è¾“å‡ºæ€è€ƒç»“æœï¼Œä¸æ‰§è¡Œå·¥å…·
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (TokenLimitExceeded e) {
            log.warn("Token limit exceeded, finishing execution");
            setState(AgentState.FINISHED);
            return "Task completed due to token limit";
            
        } catch (Exception e) {
            log.error("Error in ReAct step execution", e);
            setState(AgentState.ERROR);
            throw e;
        }
        
        return result;
    }
    
    /**
     * æ€è€ƒé˜¶æ®µ - ç”Ÿæˆä¸‹ä¸€æ­¥è¡ŒåŠ¨ç­–ç•¥
     */
    private String think() {
        List<Message> messages = memory.getMessages();
        messages.add(Message.systemMessage(getNextStepPrompt(), null));
        
        return llm.chat(messages).getContent();
    }
    
    /**
     * è¡ŒåŠ¨é˜¶æ®µ - æ‰§è¡Œå·¥å…·è°ƒç”¨æˆ–è¾“å‡ºç»“æœ
     */
    private String act() {
        List<ToolCall> toolCalls = parseToolCalls(memory.getLastMessage());
        
        if (toolCalls.isEmpty()) {
            setState(AgentState.FINISHED);
            return memory.getLastMessage().getContent();
        }
        
        List<String> results = new ArrayList<>();
        for (ToolCall toolCall : toolCalls) {
            String result = executeTool(toolCall);
            results.add(result);
            
            // æ·»åŠ å·¥å…·æ‰§è¡Œç»“æœåˆ°è®°å¿†
            Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
            memory.addMessage(toolMsg);
        }
        
        return String.join("\n\n", results);
    }
}
```

### 2.2 è§„åˆ’Agentçš„çŠ¶æ€ç®¡ç†

```java
/**
 * è§„åˆ’Agent - è´Ÿè´£ä»»åŠ¡åˆ†è§£å’Œè®¡åˆ’åˆ¶å®š
 */
public class PlanningAgent extends BaseAgent {
    private PlanningTool planningTool;
    private boolean isColseUpdate = false; // æ˜¯å¦å…³é—­åŠ¨æ€æ›´æ–°
    
    @Override
    public String step() {
        try {
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            if (shouldAct(thought)) {
                return act();
            } else {
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (Exception e) {
            log.error("Planning agent step error", e);
            setState(AgentState.ERROR);
            throw e;
        }
    }
    
    @Override
    public String act() {
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰è®¡åˆ’ä¸”å…³é—­åŠ¨æ€æ›´æ–°
        if (isColseUpdate && Objects.nonNull(planningTool.getPlan())) {
            return getNextTask();
        }
        
        // æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆé€šå¸¸æ˜¯è§„åˆ’å·¥å…·ï¼‰
        List<String> results = new ArrayList<>();
        for (ToolCall toolCall : toolCalls) {
            String result = executeTool(toolCall);
            results.add(result);
            
            // æ·»åŠ å·¥å…·å“åº”åˆ°è®°å¿†
            Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
            memory.addMessage(toolMsg);
        }
        
        // æ£€æŸ¥è®¡åˆ’æ˜¯å¦å®Œæˆ
        if (Objects.nonNull(planningTool.getPlan())) {
            return getNextTask();
        }
        
        return String.join("\n\n", results);
    }
    
    /**
     * è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡å¹¶ç®¡ç†è®¡åˆ’æ‰§è¡ŒçŠ¶æ€
     */
    private String getNextTask() {
        Plan plan = planningTool.getPlan();
        
        // æ£€æŸ¥æ‰€æœ‰ä»»åŠ¡æ˜¯å¦å®Œæˆ
        boolean allComplete = plan.getStepStatus().stream()
            .allMatch(status -> "completed".equals(status));
            
        if (allComplete) {
            setState(AgentState.FINISHED);
            printer.send("plan", plan);
            return "finish";
        }
        
        // è¿”å›å½“å‰æ­¥éª¤
        if (!plan.getCurrentStep().isEmpty()) {
            setState(AgentState.FINISHED);
            String[] currentSteps = plan.getCurrentStep().split("<sep>");
            printer.send("plan", plan);
            
            // å‘é€ä»»åŠ¡é€šçŸ¥
            Arrays.stream(currentSteps)
                .forEach(step -> printer.send("task", step));
                
            return plan.getCurrentStep();
        }
        
        return "";
    }
}
```

### 2.3 æ‰§è¡ŒAgentçš„çŠ¶æ€åè°ƒ

```java
/**
 * æ‰§è¡ŒAgent - è´Ÿè´£å…·ä½“ä»»åŠ¡æ‰§è¡Œ
 */
public class ExecutorAgent extends BaseAgent {
    
    @Override 
    public String step() {
        try {
            String thought = think();
            memory.addMessage(Message.assistantMessage(thought, null));
            
            if (shouldAct(thought)) {
                String result = act();
                return result;
            } else {
                setState(AgentState.FINISHED);
                return thought;
            }
            
        } catch (Exception e) {
            log.error("Executor agent step error", e);
            setState(AgentState.ERROR);
            throw e;
        }
    }
    
    @Override
    public String act() {
        List<String> results = new ArrayList<>();
        
        for (ToolCall toolCall : toolCalls) {
            try {
                String result = executeTool(toolCall);
                results.add(result);
                
                // å·¥å…·æ‰§è¡ŒæˆåŠŸï¼Œæ›´æ–°è®°å¿†
                Message toolMsg = Message.toolMessage(result, toolCall.getId(), null);
                memory.addMessage(toolMsg);
                
            } catch (Exception e) {
                log.error("Tool execution failed: {}", toolCall.getName(), e);
                setState(AgentState.ERROR);
                throw e;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å®Œæˆ
        String combinedResult = String.join("\n\n", results);
        if (shouldFinish(combinedResult)) {
            setState(AgentState.FINISHED);
        }
        
        return combinedResult;
    }
}
```

## 3. Agentä¸Šä¸‹æ–‡çŠ¶æ€ç®¡ç†

### 3.1 AgentContextè®¾è®¡æ¨¡å¼

```java
/**
 * Agentæ‰§è¡Œä¸Šä¸‹æ–‡ - ç»´æŠ¤Agentè¿è¡Œæ—¶çŠ¶æ€
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AgentContext {
    private String requestId;
    private String sessionId;
    private String query;
    
    // çŠ¶æ€ä¿¡æ¯
    private AgentState currentState;
    private long startTime;
    private long lastUpdateTime;
    
    // æ‰§è¡Œç¯å¢ƒ
    private Map<String, Object> contextData = new ConcurrentHashMap<>();
    private List<FileInformation> taskProductFiles = new ArrayList<>();
    private CountDownLatch latch;
    
    /**
     * çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æ›´æ–°
     */
    public synchronized void updateState(AgentState newState) {
        AgentState oldState = this.currentState;
        this.currentState = newState;
        this.lastUpdateTime = System.currentTimeMillis();
        
        // è§¦å‘çŠ¶æ€å˜æ›´äº‹ä»¶
        notifyStateChange(oldState, newState);
    }
    
    /**
     * è·å–ä¸Šä¸‹æ–‡å¿«ç…§
     */
    public AgentContextSnapshot createSnapshot() {
        return AgentContextSnapshot.builder()
            .requestId(requestId)
            .sessionId(sessionId)
            .currentState(currentState)
            .contextData(new HashMap<>(contextData))
            .timestamp(lastUpdateTime)
            .build();
    }
}
```

### 3.2 MemoryçŠ¶æ€åŒæ­¥æœºåˆ¶

```java
/**
 * è®°å¿†ç±» - ç®¡ç†ä»£ç†çš„æ¶ˆæ¯å†å²å’ŒçŠ¶æ€
 */
@Data
public class Memory {
    private List<Message> messages = new ArrayList<>();
    private volatile boolean dirty = false; // æ ‡è®°å†…å­˜æ˜¯å¦éœ€è¦åŒæ­¥
    
    /**
     * çº¿ç¨‹å®‰å…¨çš„æ¶ˆæ¯æ·»åŠ 
     */
    public synchronized void addMessage(Message message) {
        messages.add(message);
        dirty = true;
        notifyMemoryUpdate();
    }
    
    /**
     * æ¸…ç©ºå·¥å…·æ‰§è¡Œå†å² - çŠ¶æ€é‡ç½®æ—¶è°ƒç”¨
     */
    public void clearToolContext() {
        Iterator<Message> iterator = messages.iterator();
        while (iterator.hasNext()) {
            Message message = iterator.next();
            
            // ç§»é™¤å·¥å…·ç›¸å…³æ¶ˆæ¯
            if (message.getRole() == RoleType.TOOL) {
                iterator.remove();
            }
            
            // ç§»é™¤åŒ…å«å·¥å…·è°ƒç”¨çš„åŠ©æ‰‹æ¶ˆæ¯
            if (message.getRole() == RoleType.ASSISTANT && 
                Objects.nonNull(message.getToolCalls()) && 
                !message.getToolCalls().isEmpty()) {
                iterator.remove();
            }
            
            // ç§»é™¤çŠ¶æ€ç›¸å…³çš„å†…éƒ¨æ¶ˆæ¯
            if (Objects.nonNull(message.getContent()) && 
                message.getContent().startsWith("æ ¹æ®å½“å‰çŠ¶æ€å’Œå¯ç”¨å·¥å…·ï¼Œç¡®å®šä¸‹ä¸€æ­¥è¡ŒåŠ¨")) {
                iterator.remove();
            }
        }
        
        dirty = true;
    }
    
    /**
     * è·å–æœ€åä¸€æ¡æ¶ˆæ¯çš„çŠ¶æ€å®‰å…¨æ–¹æ³•
     */
    public Message getLastMessage() {
        synchronized (messages) {
            return messages.isEmpty() ? null : messages.get(messages.size() - 1);
        }
    }
}
```

## 4. å¤šç±»å‹Agentçš„çŠ¶æ€åè°ƒæ¨¡å¼

### 4.1 Plan-Solveæ¨¡å¼çš„çŠ¶æ€åè°ƒ

```java
/**
 * Plan-Solveå¤„ç†å™¨ - åè°ƒå¤šä¸ªAgentçš„çŠ¶æ€
 */
@Component
public class PlanSolveHandlerImpl implements AgentHandlerService {
    
    @Override
    public String handle(AgentContext agentContext, AgentRequest request) {
        // åˆ›å»ºåä½œAgent
        PlanningAgent planning = new PlanningAgent(agentContext);
        ExecutorAgent executor = new ExecutorAgent(agentContext);
        SummaryAgent summary = new SummaryAgent(agentContext);
        
        // ç¬¬ä¸€é˜¶æ®µï¼šè§„åˆ’
        String planningResult = planning.run(agentContext.getQuery());
        log.info("Planning phase completed with state: {}", planning.getState());
        
        int stepIdx = 0;
        int maxStepNum = genieConfig.getPlannerMaxSteps();
        
        // ç¬¬äºŒé˜¶æ®µï¼šæ‰§è¡Œå¾ªç¯
        while (stepIdx <= maxStepNum) {
            List<String> planningResults = Arrays.stream(planningResult.split("<sep>"))
                .map(task -> "ä½ çš„ä»»åŠ¡æ˜¯ï¼š" + task)
                .collect(Collectors.toList());
                
            String executorResult;
            agentContext.getTaskProductFiles().clear();
            
            if (planningResults.size() == 1) {
                // å•ä»»åŠ¡æ‰§è¡Œ
                executorResult = executor.run(planningResults.get(0));
            } else {
                // å¤šä»»åŠ¡å¹¶è¡Œæ‰§è¡Œ
                executorResult = executeMultipleTasks(executor, planningResults);
            }
            
            log.info("Execution phase {} completed with state: {}", 
                stepIdx, executor.getState());
            
            // æ£€æŸ¥æ‰§è¡Œç»“æœ
            if (executor.getState() == AgentState.FINISHED) {
                break;
            }
            
            stepIdx++;
        }
        
        // ç¬¬ä¸‰é˜¶æ®µï¼šæ€»ç»“
        summary.setSystemPrompt(summary.getSystemPrompt().replace("{{query}}", request.getQuery()));
        String summaryResult = summary.run("è¯·æ€»ç»“æ‰§è¡Œç»“æœ");
        
        log.info("Summary phase completed with state: {}", summary.getState());
        
        return summaryResult;
    }
    
    /**
     * å¤šä»»åŠ¡å¹¶è¡Œæ‰§è¡Œçš„çŠ¶æ€åè°ƒ
     */
    private String executeMultipleTasks(ExecutorAgent executor, List<String> tasks) {
        List<CompletableFuture<String>> futures = tasks.stream()
            .map(task -> CompletableFuture.supplyAsync(() -> {
                try {
                    return executor.run(task);
                } catch (Exception e) {
                    log.error("Task execution failed: {}", task, e);
                    return "Task failed: " + e.getMessage();
                }
            }))
            .collect(Collectors.toList());
            
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        
        // æ”¶é›†ç»“æœ
        return futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.joining("\n\n"));
    }
}
```

### 4.2 AgentçŠ¶æ€ä¸€è‡´æ€§ä¿è¯

```java
/**
 * AgentçŠ¶æ€ç®¡ç†å™¨ - ç¡®ä¿å¤šAgentçŠ¶æ€ä¸€è‡´æ€§
 */
@Component
public class AgentStateManager {
    private final Map<String, AgentStateInfo> agentStates = new ConcurrentHashMap<>();
    
    /**
     * æ³¨å†ŒAgentçŠ¶æ€
     */
    public void registerAgent(String agentId, BaseAgent agent) {
        AgentStateInfo stateInfo = AgentStateInfo.builder()
            .agentId(agentId)
            .agent(agent)
            .lastUpdateTime(System.currentTimeMillis())
            .build();
            
        agentStates.put(agentId, stateInfo);
    }
    
    /**
     * åŒæ­¥æ›´æ–°AgentçŠ¶æ€
     */
    public synchronized void updateAgentState(String agentId, AgentState newState) {
        AgentStateInfo stateInfo = agentStates.get(agentId);
        if (stateInfo != null) {
            AgentState oldState = stateInfo.getAgent().getState();
            stateInfo.getAgent().setState(newState);
            stateInfo.setLastUpdateTime(System.currentTimeMillis());
            
            // é€šçŸ¥å…¶ä»–ç›¸å…³Agent
            notifyStateChange(agentId, oldState, newState);
        }
    }
    
    /**
     * æ£€æŸ¥AgentçŠ¶æ€ä¸€è‡´æ€§
     */
    public boolean checkConsistency(String sessionId) {
        return agentStates.values().stream()
            .filter(info -> info.getSessionId().equals(sessionId))
            .map(info -> info.getAgent().getState())
            .allMatch(state -> state == AgentState.FINISHED || state == AgentState.ERROR);
    }
}
```

## 5. çŠ¶æ€æœºå¼‚å¸¸å¤„ç†ä¸æ¢å¤

### 5.1 å¼‚å¸¸çŠ¶æ€çš„åˆ†ç±»å¤„ç†

```java
/**
 * Agentå¼‚å¸¸å¤„ç†ç­–ç•¥
 */
public class AgentExceptionHandler {
    
    public void handleException(BaseAgent agent, Exception e) {
        if (e instanceof TokenLimitExceeded) {
            // Tokené™åˆ¶å¼‚å¸¸ - ä¼˜é›…ç»ˆæ­¢
            agent.setState(AgentState.FINISHED);
            log.warn("Agent {} reached token limit, finishing gracefully", 
                agent.getName());
                
        } else if (e instanceof ToolExecutionException) {
            // å·¥å…·æ‰§è¡Œå¼‚å¸¸ - å¯æ¢å¤é”™è¯¯
            handleToolError(agent, (ToolExecutionException) e);
            
        } else if (e instanceof NetworkException) {
            // ç½‘ç»œå¼‚å¸¸ - é‡è¯•æœºåˆ¶
            handleNetworkError(agent, (NetworkException) e);
            
        } else {
            // æœªçŸ¥å¼‚å¸¸ - é”™è¯¯çŠ¶æ€
            agent.setState(AgentState.ERROR);
            log.error("Unhandled exception in agent {}", agent.getName(), e);
        }
    }
    
    private void handleToolError(BaseAgent agent, ToolExecutionException e) {
        if (e.isRetryable() && agent.getCurrentStep() < agent.getMaxSteps()) {
            // æ¸…ç†é”™è¯¯çŠ¶æ€ï¼Œç»§ç»­æ‰§è¡Œ
            agent.getMemory().clearToolContext();
            log.info("Tool error recovered, continuing execution");
        } else {
            agent.setState(AgentState.ERROR);
        }
    }
}
```

### 5.2 çŠ¶æ€æ¢å¤æœºåˆ¶

```java
/**
 * AgentçŠ¶æ€æ¢å¤æœåŠ¡
 */
@Service
public class AgentRecoveryService {
    
    /**
     * ä»å¿«ç…§æ¢å¤AgentçŠ¶æ€
     */
    public void recoverFromSnapshot(BaseAgent agent, AgentSnapshot snapshot) {
        try {
            // æ¢å¤åŸºæœ¬çŠ¶æ€
            agent.setState(snapshot.getState());
            agent.setCurrentStep(snapshot.getCurrentStep());
            
            // æ¢å¤å†…å­˜çŠ¶æ€
            agent.getMemory().clear();
            agent.getMemory().addMessages(snapshot.getMessages());
            
            // æ¢å¤ä¸Šä¸‹æ–‡æ•°æ®
            agent.getContext().getContextData().putAll(snapshot.getContextData());
            
            log.info("Agent {} recovered from snapshot at step {}", 
                agent.getName(), snapshot.getCurrentStep());
                
        } catch (Exception e) {
            log.error("Failed to recover agent from snapshot", e);
            agent.setState(AgentState.ERROR);
        }
    }
    
    /**
     * æ£€æŸ¥ç‚¹ä¿å­˜
     */
    public AgentSnapshot createCheckpoint(BaseAgent agent) {
        return AgentSnapshot.builder()
            .agentId(agent.getName())
            .state(agent.getState())
            .currentStep(agent.getCurrentStep())
            .messages(new ArrayList<>(agent.getMemory().getMessages()))
            .contextData(new HashMap<>(agent.getContext().getContextData()))
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

## 6. å°ç»“

æœ¬èŠ‚æ·±å…¥æ¢è®¨äº†Agentçº§çŠ¶æ€æœºçš„è®¾è®¡ä¸å®ç°ï¼Œä¸»è¦å†…å®¹åŒ…æ‹¬ï¼š

1. **çŠ¶æ€æšä¸¾è®¾è®¡**ï¼šIDLEã€RUNNINGã€FINISHEDã€ERRORå››ç§çŠ¶æ€çš„è¯­ä¹‰å’Œè½¬æ¢è§„åˆ™
2. **æ‰§è¡Œå¾ªç¯æ§åˆ¶**ï¼šåŸºäºçŠ¶æ€é©±åŠ¨çš„Agentä¸»å¾ªç¯å®ç°
3. **ä¸Šä¸‹æ–‡ç®¡ç†**ï¼šAgentContextå’ŒMemoryçš„çŠ¶æ€åŒæ­¥æœºåˆ¶
4. **å¤šAgentåè°ƒ**ï¼šPlan-Solveæ¨¡å¼ä¸‹çš„çŠ¶æ€åè°ƒç­–ç•¥
5. **å¼‚å¸¸å¤„ç†**ï¼šä¸åŒç±»å‹å¼‚å¸¸çš„çŠ¶æ€è½¬æ¢å’Œæ¢å¤æœºåˆ¶

é€šè¿‡è¿™äº›è®¾è®¡æ¨¡å¼ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºå¥å£®ã€å¯ç»´æŠ¤çš„AgentçŠ¶æ€æœºç³»ç»Ÿï¼Œä¸ºå¤æ‚çš„AIåº”ç”¨æä¾›ç¨³å®šçš„æ‰§è¡ŒåŸºç¡€ã€‚

## å»¶ä¼¸æ€è€ƒ

1. å¦‚ä½•è®¾è®¡æ›´ç»†ç²’åº¦çš„AgentçŠ¶æ€ä»¥æ”¯æŒæ›´å¤æ‚çš„æ‰§è¡Œæµç¨‹ï¼Ÿ
2. åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­ï¼Œå¦‚ä½•ä¿è¯å¤šä¸ªAgentå®ä¾‹çš„çŠ¶æ€ä¸€è‡´æ€§ï¼Ÿ
3. å¦‚ä½•å®ç°AgentçŠ¶æ€çš„å®æ—¶ç›‘æ§å’Œå¯è§†åŒ–ï¼Ÿ
4. å¦‚ä½•è®¾è®¡AgentçŠ¶æ€çš„ç‰ˆæœ¬ç®¡ç†å’Œå›æ»šæœºåˆ¶ï¼Ÿ

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†æ¢è®¨ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€æœºä¸å·¥ä½œæµç®¡ç†ï¼Œè¿›ä¸€æ­¥æ·±å…¥çŠ¶æ€æœºåœ¨AIåº”ç”¨ä¸­çš„åº”ç”¨ã€‚
