# 2.3.5 多Agent协作的分布式状态机

## 学习目标

🏗️ **架构设计层面**
- 学会设计多Agent系统的状态一致性协议
- 理解分布式状态机的组合与协调模式
- 掌握Agent间消息传递的状态机模型

⚙️ **工程实现层面**
- 掌握Plan-Solve模式中Planning、Executor、Summary Agent的状态同步
- 学会实现分布式环境下的状态冲突检测与解决
- 掌握多Agent协作的容错与恢复机制

🚀 **企业级应用**
- 理解大规模多Agent系统的状态管理策略
- 掌握分布式状态机的性能优化技术

## 引言

在前面的章节中，我们学习了单个Agent（2.3.2）、任务（2.3.3）和工具（2.3.4）的状态机设计。现在我们将面对AGI应用中最复杂的状态管理挑战——多Agent协作的分布式状态机。

多Agent协作是AI应用的核心能力之一，它将复杂任务分解给专门的Agent来处理，提高系统的专业化程度和处理效率。这正是2.3.1章节中提到的**状态机组合与分层**原则在分布式环境下的具体应用。然而，多Agent系统的状态管理比单Agent复杂得多，需要解决状态同步、消息协调、故障恢复等分布式系统的典型问题。

在这个复杂的系统中，我们需要应用前面学到的所有设计原则：每个Agent保持其状态的单一职责（SRP），整个协作系统对扩展开放、对修改封闭（OCP），不同类型的Agent可以互相替换（LSP），各Agent通过明确的接口进行协作（ISP），整个系统依赖于抽象的协作协议而不是具体实现（DIP）。

本节将深入分析JoyAgent-JDGenie项目中多Agent协作的状态机设计，探讨分布式状态一致性的实现策略。

## 1. 多Agent协作状态模型

在设计多Agent协作状态模型时，我们面临的挑战不仅是单个Agent的状态管理，更重要的是如何协调多个Agent的状态转换。这需要引入一个新的抽象层——协作状态（Collaboration State），它代表整个多Agent系统的全局状态，同时需要与各个Agent的局部状态保持一致性。

### 1.1 协作状态枚举设计

```java
/**
 * 多Agent协作状态枚举
 */
public enum CollaborationState {
    INITIALIZING("initializing"),     // 初始化：创建Agent实例，分配任务
    COORDINATING("coordinating"),     // 协调中：Agent间进行任务协商和资源分配
    EXECUTING("executing"),           // 执行中：各Agent并行或串行执行任务
    SYNCHRONIZING("synchronizing"),   // 同步中：Agent间交换中间结果
    INTEGRATING("integrating"),       // 整合中：汇总各Agent的执行结果
    COMPLETED("completed"),           // 已完成：所有Agent任务完成，结果整合完毕
    FAILED("failed"),                // 执行失败：关键Agent失败导致整体任务失败
    PARTIAL("partial");              // 部分完成：部分Agent完成，可接受的结果

    private final String value;
    
    CollaborationState(String value) {
        this.value = value;
    }
}
```

### 1.2 协作上下文设计

```java
/**
 * 多Agent协作上下文
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CollaborationContext {
    private String collaborationId;
    private String sessionId;
    private String requestId;
    
    // 协作状态
    private CollaborationState state = CollaborationState.INITIALIZING;
    private long startTime;
    private long endTime;
    private Map<String, Object> sharedData = new ConcurrentHashMap<>();
    
    // Agent管理
    private Map<String, BaseAgent> agents = new ConcurrentHashMap<>();
    private Map<String, AgentState> agentStates = new ConcurrentHashMap<>();
    private Map<String, String> agentResults = new ConcurrentHashMap<>();
    
    // 消息队列
    private BlockingQueue<AgentMessage> messageQueue = new LinkedBlockingQueue<>();
    private Map<String, BlockingQueue<AgentMessage>> agentQueues = new ConcurrentHashMap<>();
    
    // 同步控制
    private CountDownLatch coordinationLatch;
    private CountDownLatch executionLatch;
    private CountDownLatch integrationLatch;
    
    // 状态监听器
    private List<CollaborationStateListener> stateListeners = new ArrayList<>();
    
    /**
     * 线程安全的状态更新
     */
    public synchronized void updateCollaborationState(CollaborationState newState) {
        CollaborationState oldState = this.state;
        this.state = newState;
        
        log.info("Collaboration state transition: {} -> {} for session {}", 
            oldState, newState, sessionId);
        
        // 通知状态监听器
        notifyStateListeners(oldState, newState);
        
        // 处理状态转换的特殊逻辑
        handleStateTransition(oldState, newState);
    }
    
    /**
     * 更新Agent状态
     */
    public synchronized void updateAgentState(String agentId, AgentState newState) {
        AgentState oldState = agentStates.put(agentId, newState);
        
        log.debug("Agent {} state updated: {} -> {}", agentId, oldState, newState);
        
        // 检查是否需要更新协作状态
        checkCollaborationStateUpdate();
    }
    
    /**
     * 检查并更新协作状态
     */
    private void checkCollaborationStateUpdate() {
        List<AgentState> states = new ArrayList<>(agentStates.values());
        
        // 如果所有Agent都完成，更新协作状态
        if (states.stream().allMatch(state -> state == AgentState.FINISHED)) {
            if (this.state == CollaborationState.EXECUTING) {
                updateCollaborationState(CollaborationState.INTEGRATING);
            }
        }
        
        // 如果有关键Agent失败，更新协作状态
        boolean hasCriticalFailure = agents.entrySet().stream()
            .anyMatch(entry -> {
                String agentId = entry.getKey();
                BaseAgent agent = entry.getValue();
                AgentState state = agentStates.get(agentId);
                return isCriticalAgent(agent) && state == AgentState.ERROR;
            });
        
        if (hasCriticalFailure && this.state == CollaborationState.EXECUTING) {
            updateCollaborationState(CollaborationState.FAILED);
        }
    }
}
```

### 1.3 Agent间消息模型

```java
/**
 * Agent间消息模型
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AgentMessage {
    private String messageId;
    private String fromAgentId;
    private String toAgentId;
    private MessageType type;
    private String content;
    private Map<String, Object> payload = new HashMap<>();
    private long timestamp;
    private int priority = 5; // 1-10，1最高优先级
    
    public enum MessageType {
        TASK_ASSIGNMENT,    // 任务分配
        RESULT_SHARING,     // 结果分享
        STATE_UPDATE,       // 状态更新
        COORDINATION,       // 协调消息
        ERROR_NOTIFICATION, // 错误通知
        HEARTBEAT          // 心跳消息
    }
    
    /**
     * 创建任务分配消息
     */
    public static AgentMessage taskAssignment(String from, String to, String task) {
        return AgentMessage.builder()
            .messageId(UUID.randomUUID().toString())
            .fromAgentId(from)
            .toAgentId(to)
            .type(MessageType.TASK_ASSIGNMENT)
            .content(task)
            .timestamp(System.currentTimeMillis())
            .priority(1)
            .build();
    }
    
    /**
     * 创建结果分享消息
     */
    public static AgentMessage resultSharing(String from, String to, String result) {
        return AgentMessage.builder()
            .messageId(UUID.randomUUID().toString())
            .fromAgentId(from)
            .toAgentId(to)
            .type(MessageType.RESULT_SHARING)
            .content(result)
            .timestamp(System.currentTimeMillis())
            .priority(3)
            .build();
    }
}
```

## 2. Plan-Solve协作模式的状态同步

### 2.1 Plan-Solve协作流程设计

```java
/**
 * Plan-Solve协作状态机
 */
@Component
public class PlanSolveCollaborationStateMachine {
    
    /**
     * Plan-Solve协作流程状态
     */
    public enum PlanSolveState {
        PLANNING_PHASE,      // 规划阶段：Planning Agent工作
        PLANNING_REVIEW,     // 规划审核：检查规划结果
        EXECUTION_PHASE,     // 执行阶段：Executor Agent工作
        EXECUTION_MONITOR,   // 执行监控：监控执行进度
        SUMMARY_PHASE,       // 总结阶段：Summary Agent工作
        INTEGRATION,         // 整合阶段：整合最终结果
        COMPLETED           // 完成阶段
    }
    
    @Autowired
    private CollaborationContextManager contextManager;
    
    /**
     * 执行Plan-Solve协作流程
     */
    public CompletableFuture<String> executePlanSolveFlow(AgentRequest request) {
        CollaborationContext context = contextManager.createCollaborationContext(request);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 阶段1：规划阶段
                String planningResult = executePlanningPhase(context, request);
                
                // 阶段2：执行阶段
                String executionResult = executeExecutionPhase(context, planningResult);
                
                // 阶段3：总结阶段
                String summaryResult = executeSummaryPhase(context, executionResult, request);
                
                // 标记协作完成
                context.updateCollaborationState(CollaborationState.COMPLETED);
                
                return summaryResult;
                
            } catch (Exception e) {
                log.error("Plan-Solve collaboration failed", e);
                context.updateCollaborationState(CollaborationState.FAILED);
                throw new RuntimeException("Collaboration failed: " + e.getMessage());
            }
        });
    }
    
    /**
     * 执行规划阶段
     */
    private String executePlanningPhase(CollaborationContext context, AgentRequest request) {
        log.info("Starting planning phase for collaboration: {}", context.getCollaborationId());
        
        // 创建Planning Agent
        PlanningAgent planningAgent = new PlanningAgent(context.toAgentContext());
        context.getAgents().put("planning", planningAgent);
        context.updateAgentState("planning", AgentState.IDLE);
        
        // 更新协作状态
        context.updateCollaborationState(CollaborationState.COORDINATING);
        
        try {
            // 执行规划
            context.updateAgentState("planning", AgentState.RUNNING);
            String planningResult = planningAgent.run(request.getQuery());
            context.updateAgentState("planning", AgentState.FINISHED);
            
            // 保存规划结果到共享数据
            context.getSharedData().put("planning_result", planningResult);
            context.getAgentResults().put("planning", planningResult);
            
            log.info("Planning phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return planningResult;
            
        } catch (Exception e) {
            context.updateAgentState("planning", AgentState.ERROR);
            throw e;
        }
    }
    
    /**
     * 执行执行阶段
     */
    private String executeExecutionPhase(CollaborationContext context, String planningResult) {
        log.info("Starting execution phase for collaboration: {}", context.getCollaborationId());
        
        // 创建Executor Agent
        ExecutorAgent executorAgent = new ExecutorAgent(context.toAgentContext());
        context.getAgents().put("executor", executorAgent);
        context.updateAgentState("executor", AgentState.IDLE);
        
        // 更新协作状态
        context.updateCollaborationState(CollaborationState.EXECUTING);
        
        try {
            // 解析规划结果为任务列表
            List<String> tasks = parsePlanningResult(planningResult);
            StringBuilder executionResults = new StringBuilder();
            
            int stepIdx = 0;
            int maxSteps = getMaxExecutionSteps();
            
            while (stepIdx < maxSteps && !tasks.isEmpty()) {
                context.updateAgentState("executor", AgentState.RUNNING);
                
                String currentTask = tasks.get(0);
                String taskResult = executorAgent.run(currentTask);
                
                executionResults.append(taskResult).append("\n");
                tasks.remove(0);
                
                // 检查是否需要继续执行
                if (executorAgent.getState() == AgentState.FINISHED) {
                    break;
                }
                
                stepIdx++;
            }
            
            context.updateAgentState("executor", AgentState.FINISHED);
            
            // 保存执行结果到共享数据
            String finalExecutionResult = executionResults.toString();
            context.getSharedData().put("execution_result", finalExecutionResult);
            context.getAgentResults().put("executor", finalExecutionResult);
            
            log.info("Execution phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return finalExecutionResult;
            
        } catch (Exception e) {
            context.updateAgentState("executor", AgentState.ERROR);
            throw e;
        }
    }
    
    /**
     * 执行总结阶段
     */
    private String executeSummaryPhase(CollaborationContext context, 
                                     String executionResult, AgentRequest request) {
        log.info("Starting summary phase for collaboration: {}", context.getCollaborationId());
        
        // 创建Summary Agent
        SummaryAgent summaryAgent = new SummaryAgent(context.toAgentContext());
        summaryAgent.setSystemPrompt(
            summaryAgent.getSystemPrompt().replace("{{query}}", request.getQuery()));
        
        context.getAgents().put("summary", summaryAgent);
        context.updateAgentState("summary", AgentState.IDLE);
        
        // 更新协作状态
        context.updateCollaborationState(CollaborationState.INTEGRATING);
        
        try {
            context.updateAgentState("summary", AgentState.RUNNING);
            
            // 构建总结任务
            String summaryTask = buildSummaryTask(context, executionResult, request);
            String summaryResult = summaryAgent.run(summaryTask);
            
            context.updateAgentState("summary", AgentState.FINISHED);
            
            // 保存总结结果
            context.getSharedData().put("summary_result", summaryResult);
            context.getAgentResults().put("summary", summaryResult);
            
            log.info("Summary phase completed for collaboration: {}", 
                context.getCollaborationId());
            
            return summaryResult;
            
        } catch (Exception e) {
            context.updateAgentState("summary", AgentState.ERROR);
            throw e;
        }
    }
}
```

### 2.2 Agent状态同步机制

```java
/**
 * Agent状态同步管理器
 */
@Component
public class AgentStateSynchronizer {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final String STATE_SYNC_CHANNEL = "agent_state_sync";
    private final Map<String, CollaborationContext> collaborationContexts = 
        new ConcurrentHashMap<>();
    
    /**
     * 状态同步消息
     */
    @Data
    @Builder
    public static class StateSyncMessage {
        private String collaborationId;
        private String agentId;
        private AgentState oldState;
        private AgentState newState;
        private long timestamp;
        private String nodeId;
        private Map<String, Object> metadata = new HashMap<>();
    }
    
    /**
     * 广播Agent状态更新
     */
    public void broadcastStateUpdate(String collaborationId, String agentId, 
                                   AgentState oldState, AgentState newState) {
        StateSyncMessage message = StateSyncMessage.builder()
            .collaborationId(collaborationId)
            .agentId(agentId)
            .oldState(oldState)
            .newState(newState)
            .timestamp(System.currentTimeMillis())
            .nodeId(getNodeId())
            .build();
        
        try {
            redisTemplate.convertAndSend(STATE_SYNC_CHANNEL, message);
            log.debug("Broadcasted state update: {} {} -> {}", 
                agentId, oldState, newState);
        } catch (Exception e) {
            log.error("Failed to broadcast state update", e);
        }
    }
    
    /**
     * 监听状态同步消息
     */
    @RedisMessageListener(STATE_SYNC_CHANNEL)
    public void handleStateSyncMessage(StateSyncMessage message) {
        if (getNodeId().equals(message.getNodeId())) {
            // 忽略本节点发送的消息
            return;
        }
        
        CollaborationContext context = collaborationContexts.get(message.getCollaborationId());
        if (context != null) {
            // 更新本地状态
            context.updateAgentState(message.getAgentId(), message.getNewState());
            
            log.debug("Received state update from remote node: {} {} -> {}", 
                message.getAgentId(), message.getOldState(), message.getNewState());
        }
    }
    
    /**
     * 检查状态一致性
     */
    public StateConsistencyReport checkStateConsistency(String collaborationId) {
        CollaborationContext localContext = collaborationContexts.get(collaborationId);
        if (localContext == null) {
            return StateConsistencyReport.notFound(collaborationId);
        }
        
        // 从Redis获取分布式状态
        Map<String, AgentState> distributedStates = getDistributedStates(collaborationId);
        Map<String, AgentState> localStates = localContext.getAgentStates();
        
        List<StateInconsistency> inconsistencies = new ArrayList<>();
        
        // 检查本地状态与分布式状态的一致性
        for (Map.Entry<String, AgentState> entry : localStates.entrySet()) {
            String agentId = entry.getKey();
            AgentState localState = entry.getValue();
            AgentState distributedState = distributedStates.get(agentId);
            
            if (distributedState != null && !localState.equals(distributedState)) {
                inconsistencies.add(StateInconsistency.builder()
                    .agentId(agentId)
                    .localState(localState)
                    .distributedState(distributedState)
                    .build());
            }
        }
        
        return StateConsistencyReport.builder()
            .collaborationId(collaborationId)
            .consistent(inconsistencies.isEmpty())
            .inconsistencies(inconsistencies)
            .checkTime(System.currentTimeMillis())
            .build();
    }
    
    /**
     * 解决状态不一致
     */
    public void resolveStateInconsistency(String collaborationId, String agentId) {
        CollaborationContext context = collaborationContexts.get(collaborationId);
        if (context == null) {
            return;
        }
        
        // 采用最后写入获胜策略
        Map<String, AgentState> distributedStates = getDistributedStates(collaborationId);
        AgentState distributedState = distributedStates.get(agentId);
        
        if (distributedState != null) {
            context.updateAgentState(agentId, distributedState);
            log.info("Resolved state inconsistency for agent {}: updated to {}", 
                agentId, distributedState);
        }
    }
    
    private Map<String, AgentState> getDistributedStates(String collaborationId) {
        String key = "collaboration_states:" + collaborationId;
        
        try {
            Map<Object, Object> rawStates = redisTemplate.opsForHash().entries(key);
            Map<String, AgentState> states = new HashMap<>();
            
            for (Map.Entry<Object, Object> entry : rawStates.entrySet()) {
                String agentId = (String) entry.getKey();
                String stateName = (String) entry.getValue();
                AgentState state = AgentState.valueOf(stateName);
                states.put(agentId, state);
            }
            
            return states;
            
        } catch (Exception e) {
            log.error("Failed to get distributed states", e);
            return new HashMap<>();
        }
    }
}
```

## 3. Agent间消息传递状态机

### 3.1 消息路由与分发机制

```java
/**
 * Agent消息路由器
 */
@Component
public class AgentMessageRouter {
    
    /**
     * 消息路由状态
     */
    public enum RoutingState {
        PENDING,     // 待路由
        ROUTING,     // 路由中
        DELIVERED,   // 已送达
        FAILED,      // 路由失败
        EXPIRED      // 消息过期
    }
    
    /**
     * 消息路由上下文
     */
    @Data
    @Builder
    public static class MessageRoutingContext {
        private String messageId;
        private AgentMessage message;
        private RoutingState state;
        private List<String> routingPath = new ArrayList<>();
        private int retryCount;
        private long expirationTime;
        private String errorMessage;
    }
    
    private final Map<String, BlockingQueue<AgentMessage>> agentQueues = 
        new ConcurrentHashMap<>();
    private final Map<String, MessageRoutingContext> routingContexts = 
        new ConcurrentHashMap<>();
    private final ScheduledExecutorService routingExecutor = 
        Executors.newScheduledThreadPool(5);
    
    /**
     * 发送消息
     */
    public CompletableFuture<Boolean> sendMessage(AgentMessage message) {
        MessageRoutingContext context = MessageRoutingContext.builder()
            .messageId(message.getMessageId())
            .message(message)
            .state(RoutingState.PENDING)
            .expirationTime(System.currentTimeMillis() + getMessageTTL(message))
            .build();
        
        routingContexts.put(message.getMessageId(), context);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                return routeMessage(context);
            } catch (Exception e) {
                log.error("Message routing failed: {}", message.getMessageId(), e);
                context.setState(RoutingState.FAILED);
                context.setErrorMessage(e.getMessage());
                return false;
            }
        });
    }
    
    /**
     * 路由消息到目标Agent
     */
    private boolean routeMessage(MessageRoutingContext context) {
        AgentMessage message = context.getMessage();
        context.setState(RoutingState.ROUTING);
        context.getRoutingPath().add(getCurrentNodeId());
        
        String targetAgentId = message.getToAgentId();
        
        // 检查目标Agent是否在本地
        BlockingQueue<AgentMessage> targetQueue = agentQueues.get(targetAgentId);
        
        if (targetQueue != null) {
            // 本地投递
            return deliverMessageLocally(context, targetQueue);
        } else {
            // 远程投递
            return deliverMessageRemotely(context);
        }
    }
    
    /**
     * 本地消息投递
     */
    private boolean deliverMessageLocally(MessageRoutingContext context, 
                                        BlockingQueue<AgentMessage> targetQueue) {
        try {
            AgentMessage message = context.getMessage();
            
            // 检查消息是否过期
            if (System.currentTimeMillis() > context.getExpirationTime()) {
                context.setState(RoutingState.EXPIRED);
                return false;
            }
            
            // 投递消息
            boolean delivered = targetQueue.offer(message, 5, TimeUnit.SECONDS);
            
            if (delivered) {
                context.setState(RoutingState.DELIVERED);
                log.debug("Message {} delivered locally to agent {}", 
                    message.getMessageId(), message.getToAgentId());
                return true;
            } else {
                // 队列满，重试
                if (context.getRetryCount() < 3) {
                    context.setRetryCount(context.getRetryCount() + 1);
                    scheduleRetry(context);
                    return false;
                } else {
                    context.setState(RoutingState.FAILED);
                    context.setErrorMessage("Target agent queue is full");
                    return false;
                }
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            context.setState(RoutingState.FAILED);
            context.setErrorMessage("Message delivery interrupted");
            return false;
        }
    }
    
    /**
     * 远程消息投递
     */
    private boolean deliverMessageRemotely(MessageRoutingContext context) {
        try {
            AgentMessage message = context.getMessage();
            String targetAgentId = message.getToAgentId();
            
            // 查找目标Agent所在节点
            String targetNodeId = findAgentNode(targetAgentId);
            
            if (targetNodeId == null) {
                context.setState(RoutingState.FAILED);
                context.setErrorMessage("Target agent not found: " + targetAgentId);
                return false;
            }
            
            // 发送到目标节点
            boolean sent = sendToRemoteNode(message, targetNodeId);
            
            if (sent) {
                context.setState(RoutingState.DELIVERED);
                context.getRoutingPath().add(targetNodeId);
                log.debug("Message {} sent to remote node {} for agent {}", 
                    message.getMessageId(), targetNodeId, targetAgentId);
                return true;
            } else {
                context.setState(RoutingState.FAILED);
                context.setErrorMessage("Failed to send to remote node: " + targetNodeId);
                return false;
            }
            
        } catch (Exception e) {
            context.setState(RoutingState.FAILED);
            context.setErrorMessage("Remote delivery failed: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * 安排消息重试
     */
    private void scheduleRetry(MessageRoutingContext context) {
        long delay = calculateRetryDelay(context.getRetryCount());
        
        routingExecutor.schedule(() -> {
            if (context.getState() != RoutingState.EXPIRED) {
                routeMessage(context);
            }
        }, delay, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 注册Agent消息队列
     */
    public void registerAgent(String agentId) {
        agentQueues.put(agentId, new PriorityBlockingQueue<>(100, 
            Comparator.comparingInt(AgentMessage::getPriority)));
        log.debug("Registered message queue for agent: {}", agentId);
    }
    
    /**
     * 注销Agent消息队列
     */
    public void unregisterAgent(String agentId) {
        BlockingQueue<AgentMessage> queue = agentQueues.remove(agentId);
        if (queue != null) {
            // 处理队列中剩余的消息
            handleRemainingMessages(agentId, queue);
        }
        log.debug("Unregistered message queue for agent: {}", agentId);
    }
}
```

### 3.2 消息处理状态机

```java
/**
 * Agent消息处理器
 */
@Component
public class AgentMessageProcessor {
    
    /**
     * 消息处理状态
     */
    public enum ProcessingState {
        RECEIVED,       // 已接收
        VALIDATING,     // 验证中
        PROCESSING,     // 处理中
        RESPONDING,     // 响应中
        COMPLETED,      // 处理完成
        FAILED          // 处理失败
    }
    
    /**
     * 消息处理上下文
     */
    @Data
    @Builder
    public static class MessageProcessingContext {
        private String messageId;
        private String agentId;
        private AgentMessage message;
        private ProcessingState state;
        private long startTime;
        private long endTime;
        private String response;
        private String errorMessage;
        private Map<String, Object> processingData = new HashMap<>();
    }
    
    private final Map<String, MessageProcessingContext> processingContexts = 
        new ConcurrentHashMap<>();
    
    /**
     * 处理Agent消息
     */
    public CompletableFuture<String> processMessage(String agentId, AgentMessage message) {
        MessageProcessingContext context = MessageProcessingContext.builder()
            .messageId(message.getMessageId())
            .agentId(agentId)
            .message(message)
            .state(ProcessingState.RECEIVED)
            .startTime(System.currentTimeMillis())
            .build();
        
        processingContexts.put(message.getMessageId(), context);
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                return processMessageInternal(context);
            } catch (Exception e) {
                log.error("Message processing failed", e);
                context.setState(ProcessingState.FAILED);
                context.setErrorMessage(e.getMessage());
                context.setEndTime(System.currentTimeMillis());
                return null;
            }
        });
    }
    
    /**
     * 内部消息处理逻辑
     */
    private String processMessageInternal(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        // 1. 验证消息
        context.setState(ProcessingState.VALIDATING);
        if (!validateMessage(message)) {
            context.setState(ProcessingState.FAILED);
            context.setErrorMessage("Message validation failed");
            return null;
        }
        
        // 2. 处理消息
        context.setState(ProcessingState.PROCESSING);
        String response = handleMessageByType(context);
        
        // 3. 生成响应
        context.setState(ProcessingState.RESPONDING);
        if (response != null) {
            context.setResponse(response);
            context.setState(ProcessingState.COMPLETED);
        } else {
            context.setState(ProcessingState.FAILED);
            context.setErrorMessage("No response generated");
        }
        
        context.setEndTime(System.currentTimeMillis());
        
        return response;
    }
    
    /**
     * 根据消息类型处理消息
     */
    private String handleMessageByType(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        
        switch (message.getType()) {
            case TASK_ASSIGNMENT:
                return handleTaskAssignment(context);
                
            case RESULT_SHARING:
                return handleResultSharing(context);
                
            case STATE_UPDATE:
                return handleStateUpdate(context);
                
            case COORDINATION:
                return handleCoordination(context);
                
            case ERROR_NOTIFICATION:
                return handleErrorNotification(context);
                
            case HEARTBEAT:
                return handleHeartbeat(context);
                
            default:
                log.warn("Unknown message type: {}", message.getType());
                return null;
        }
    }
    
    /**
     * 处理任务分配消息
     */
    private String handleTaskAssignment(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        log.info("Agent {} received task assignment: {}", agentId, message.getContent());
        
        // 获取Agent实例
        BaseAgent agent = getAgent(agentId);
        if (agent == null) {
            context.setErrorMessage("Agent not found: " + agentId);
            return null;
        }
        
        try {
            // 分配任务给Agent
            String result = agent.run(message.getContent());
            
            // 发送结果分享消息给发送者
            AgentMessage responseMessage = AgentMessage.resultSharing(
                agentId, message.getFromAgentId(), result);
            
            messageRouter.sendMessage(responseMessage);
            
            return "Task accepted and executed";
            
        } catch (Exception e) {
            log.error("Task execution failed for agent: " + agentId, e);
            context.setErrorMessage("Task execution failed: " + e.getMessage());
            
            // 发送错误通知
            AgentMessage errorMessage = AgentMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .fromAgentId(agentId)
                .toAgentId(message.getFromAgentId())
                .type(AgentMessage.MessageType.ERROR_NOTIFICATION)
                .content("Task execution failed: " + e.getMessage())
                .timestamp(System.currentTimeMillis())
                .build();
            
            messageRouter.sendMessage(errorMessage);
            
            return null;
        }
    }
    
    /**
     * 处理结果分享消息
     */
    private String handleResultSharing(MessageProcessingContext context) {
        AgentMessage message = context.getMessage();
        String agentId = context.getAgentId();
        
        log.info("Agent {} received result sharing from {}: {}", 
            agentId, message.getFromAgentId(), message.getContent());
        
        // 将结果保存到协作上下文
        CollaborationContext collabContext = getCollaborationContext(agentId);
        if (collabContext != null) {
            collabContext.getAgentResults().put(message.getFromAgentId(), message.getContent());
            
            // 检查是否所有必需的结果都已收到
            if (areAllRequiredResultsReceived(collabContext)) {
                // 触发下一阶段的协作
                triggerNextCollaborationPhase(collabContext);
            }
        }
        
        return "Result received and processed";
    }
}
```

## 4. 分布式状态冲突检测与解决

### 4.1 状态冲突检测机制

```java
/**
 * 分布式状态冲突检测器
 */
@Component
public class DistributedStateConflictDetector {
    
    /**
     * 状态冲突类型
     */
    public enum ConflictType {
        STATE_MISMATCH,     // 状态不匹配
        VERSION_CONFLICT,   // 版本冲突
        TIMING_CONFLICT,    // 时序冲突
        RESOURCE_CONFLICT   // 资源冲突
    }
    
    /**
     * 状态冲突描述
     */
    @Data
    @Builder
    public static class StateConflict {
        private String conflictId;
        private ConflictType type;
        private String collaborationId;
        private String agentId;
        private String description;
        
        // 冲突详情
        private Object localValue;
        private Object remoteValue;
        private long localTimestamp;
        private long remoteTimestamp;
        private String localNodeId;
        private String remoteNodeId;
        
        // 解决状态
        private boolean resolved;
        private String resolutionStrategy;
        private long resolvedTime;
    }
    
    private final List<StateConflictResolver> conflictResolvers = new ArrayList<>();
    private final Map<String, StateConflict> activeConflicts = new ConcurrentHashMap<>();
    
    /**
     * 检测状态冲突
     */
    @Scheduled(fixedRate = 10000) // 每10秒检查一次
    public void detectStateConflicts() {
        for (CollaborationContext context : collaborationManager.getAllActiveCollaborations()) {
            try {
                List<StateConflict> conflicts = checkCollaborationConflicts(context);
                
                for (StateConflict conflict : conflicts) {
                    if (!activeConflicts.containsKey(conflict.getConflictId())) {
                        activeConflicts.put(conflict.getConflictId(), conflict);
                        log.warn("Detected state conflict: {}", conflict.getDescription());
                        
                        // 尝试自动解决冲突
                        resolveConflictAsync(conflict);
                    }
                }
            } catch (Exception e) {
                log.error("Error during conflict detection", e);
            }
        }
    }
    
    /**
     * 检查协作中的状态冲突
     */
    private List<StateConflict> checkCollaborationConflicts(CollaborationContext context) {
        List<StateConflict> conflicts = new ArrayList<>();
        String collaborationId = context.getCollaborationId();
        
        // 获取分布式状态快照
        Map<String, StateSnapshot> distributedSnapshots = getDistributedStateSnapshots(collaborationId);
        
        for (Map.Entry<String, AgentState> entry : context.getAgentStates().entrySet()) {
            String agentId = entry.getKey();
            AgentState localState = entry.getValue();
            
            StateSnapshot remoteSnapshot = distributedSnapshots.get(agentId);
            if (remoteSnapshot != null) {
                
                // 检查状态不匹配
                if (!localState.equals(remoteSnapshot.getState())) {
                    conflicts.add(StateConflict.builder()
                        .conflictId(UUID.randomUUID().toString())
                        .type(ConflictType.STATE_MISMATCH)
                        .collaborationId(collaborationId)
                        .agentId(agentId)
                        .description(String.format("State mismatch for agent %s: local=%s, remote=%s", 
                            agentId, localState, remoteSnapshot.getState()))
                        .localValue(localState)
                        .remoteValue(remoteSnapshot.getState())
                        .localTimestamp(System.currentTimeMillis())
                        .remoteTimestamp(remoteSnapshot.getTimestamp())
                        .localNodeId(getCurrentNodeId())
                        .remoteNodeId(remoteSnapshot.getNodeId())
                        .build());
                }
                
                // 检查版本冲突
                if (hasVersionConflict(context, agentId, remoteSnapshot)) {
                    conflicts.add(createVersionConflict(context, agentId, remoteSnapshot));
                }
            }
        }
        
        return conflicts;
    }
    
    /**
     * 异步解决状态冲突
     */
    private void resolveConflictAsync(StateConflict conflict) {
        CompletableFuture.runAsync(() -> {
            try {
                boolean resolved = false;
                
                // 尝试使用各种解决策略
                for (StateConflictResolver resolver : conflictResolvers) {
                    if (resolver.canResolve(conflict)) {
                        resolved = resolver.resolve(conflict);
                        if (resolved) {
                            conflict.setResolved(true);
                            conflict.setResolutionStrategy(resolver.getStrategyName());
                            conflict.setResolvedTime(System.currentTimeMillis());
                            
                            log.info("Resolved state conflict using strategy: {}", 
                                resolver.getStrategyName());
                            break;
                        }
                    }
                }
                
                if (!resolved) {
                    log.warn("Failed to resolve state conflict: {}", conflict.getConflictId());
                    // 可以考虑人工介入或其他降级策略
                }
                
            } catch (Exception e) {
                log.error("Error during conflict resolution", e);
            }
        });
    }
}
```

### 4.2 状态冲突解决策略

```java
/**
 * 状态冲突解决器接口
 */
public interface StateConflictResolver {
    boolean canResolve(StateConflict conflict);
    boolean resolve(StateConflict conflict);
    String getStrategyName();
    int getPriority(); // 优先级，数字越小优先级越高
}

/**
 * 最后写入获胜解决器
 */
@Component
public class LastWriteWinsResolver implements StateConflictResolver {
    
    @Override
    public boolean canResolve(StateConflict conflict) {
        return conflict.getType() == ConflictType.STATE_MISMATCH;
    }
    
    @Override
    public boolean resolve(StateConflict conflict) {
        try {
            // 比较时间戳，选择最新的状态
            if (conflict.getRemoteTimestamp() > conflict.getLocalTimestamp()) {
                // 远程状态更新，更新本地状态
                updateLocalState(conflict.getCollaborationId(), 
                                conflict.getAgentId(), 
                                (AgentState) conflict.getRemoteValue());
                
                log.info("Applied remote state for agent {}: {}", 
                    conflict.getAgentId(), conflict.getRemoteValue());
            } else {
                // 本地状态更新，广播到其他节点
                broadcastStateUpdate(conflict.getCollaborationId(), 
                                   conflict.getAgentId(), 
                                   (AgentState) conflict.getLocalValue());
                
                log.info("Broadcasted local state for agent {}: {}", 
                    conflict.getAgentId(), conflict.getLocalValue());
            }
            
            return true;
            
        } catch (Exception e) {
            log.error("Failed to resolve conflict using LastWriteWins strategy", e);
            return false;
        }
    }
    
    @Override
    public String getStrategyName() {
        return "LastWriteWins";
    }
    
    @Override
    public int getPriority() {
        return 10; // 较低优先级，作为默认策略
    }
}

/**
 * 业务优先级解决器
 */
@Component
public class BusinessPriorityResolver implements StateConflictResolver {
    
    @Override
    public boolean canResolve(StateConflict conflict) {
        return conflict.getType() == ConflictType.STATE_MISMATCH && 
               isCriticalAgent(conflict.getAgentId());
    }
    
    @Override
    public boolean resolve(StateConflict conflict) {
        try {
            String agentId = conflict.getAgentId();
            AgentState localState = (AgentState) conflict.getLocalValue();
            AgentState remoteState = (AgentState) conflict.getRemoteValue();
            
            // 基于业务规则选择状态
            AgentState chosenState = chooseStateByBusinessRules(agentId, localState, remoteState);
            
            if (chosenState.equals(localState)) {
                // 保持本地状态，广播更新
                broadcastStateUpdate(conflict.getCollaborationId(), agentId, localState);
            } else {
                // 采用远程状态，更新本地
                updateLocalState(conflict.getCollaborationId(), agentId, remoteState);
            }
            
            log.info("Resolved conflict using business priority: agent={}, chosen_state={}", 
                agentId, chosenState);
            
            return true;
            
        } catch (Exception e) {
            log.error("Failed to resolve conflict using BusinessPriority strategy", e);
            return false;
        }
    }
    
    private AgentState chooseStateByBusinessRules(String agentId, AgentState local, AgentState remote) {
        // 业务规则：如果任一状态为ERROR，优先选择ERROR状态
        if (local == AgentState.ERROR || remote == AgentState.ERROR) {
            return local == AgentState.ERROR ? local : remote;
        }
        
        // 业务规则：优先选择更"进步"的状态
        int localProgress = getStateProgress(local);
        int remoteProgress = getStateProgress(remote);
        
        return localProgress >= remoteProgress ? local : remote;
    }
    
    private int getStateProgress(AgentState state) {
        switch (state) {
            case IDLE: return 0;
            case RUNNING: return 1;
            case FINISHED: return 2;
            case ERROR: return -1;
            default: return 0;
        }
    }
    
    @Override
    public String getStrategyName() {
        return "BusinessPriority";
    }
    
    @Override
    public int getPriority() {
        return 5; // 高优先级
    }
}
```

## 5. 小结

本节深入探讨了多Agent协作的分布式状态机设计与实现：

1. **协作状态模型**：设计了多Agent系统的协作状态和同步机制
2. **Plan-Solve协作**：实现了Planning、Executor、Summary Agent的状态协调流程
3. **消息传递状态机**：建立了Agent间消息路由和处理的状态管理
4. **状态冲突检测**：提供了分布式环境下的状态一致性检测和解决方案

这些技术保证了多Agent系统在分布式环境下的可靠协作，为复杂AI应用的横向扩展提供了技术基础。

## 延伸思考

1. 如何优化多Agent系统的消息传递性能？
2. 如何实现Agent的动态发现和负载均衡？
3. 如何设计更智能的状态冲突预测和预防机制？
4. 如何在网络分区情况下保证系统的可用性？

下一节我们将探讨前后端状态同步与实时通信状态机的具体实现。
