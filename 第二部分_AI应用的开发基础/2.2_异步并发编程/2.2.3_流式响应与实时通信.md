# 2.2.3 æµå¼å“åº”ä¸å®æ—¶é€šä¿¡

## å­¦ä¹ ç›®æ ‡

åŸºäºå‰ä¸¤ç« èŠ‚çš„å¼‚æ­¥ç¼–ç¨‹åŸºç¡€ï¼Œè®¾è®¡å¹¶å®ç°AIåº”ç”¨çš„æµå¼å“åº”æœºåˆ¶ï¼ŒæŒæ¡Server-Sent Eventsï¼ˆSSEï¼‰ç­‰å®æ—¶é€šä¿¡æŠ€æœ¯åœ¨AIåœºæ™¯ä¸­çš„åº”ç”¨ã€‚

## ğŸ”— ç« èŠ‚è¡”æ¥

åœ¨2.2.1ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº†å¼‚æ­¥ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µï¼›åœ¨2.2.2ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¤šè¯­è¨€çš„å¼‚æ­¥å®ç°ã€‚æœ¬ç« èŠ‚å°†èšç„¦äºä¸€ä¸ªç‰¹å®šçš„å¼‚æ­¥åº”ç”¨åœºæ™¯â€”â€”**æµå¼å“åº”ä¸å®æ—¶é€šä¿¡**ï¼Œè¿™æ˜¯AIåº”ç”¨ç”¨æˆ·ä½“éªŒçš„å…³é”®æŠ€æœ¯ã€‚

ä»JD Genieé¡¹ç›®çš„æ¶æ„å›¾å¯ä»¥çœ‹å‡ºï¼Œå‰ç«¯ä¸åç«¯ä¹‹é—´é‡‡ç”¨äº†SSEï¼ˆServer-Sent Eventsï¼‰è¿›è¡Œå®æ—¶é€šä¿¡ï¼Œè¿™æ­£æ˜¯æœ¬ç« èŠ‚è¦æ·±å…¥æ¢è®¨çš„æ ¸å¿ƒæŠ€æœ¯ã€‚

## 2.2.3.1 AIåº”ç”¨ä¸­çš„å®æ—¶é€šä¿¡éœ€æ±‚

### æµå¼å“åº”çš„é‡è¦æ€§

åœ¨AIåº”ç”¨ä¸­ï¼Œæµå¼å“åº”è§£å†³äº†å‡ ä¸ªå…³é”®ç”¨æˆ·ä½“éªŒé—®é¢˜ï¼š

1. **é™ä½æ„ŸçŸ¥å»¶è¿Ÿ**ï¼šç”¨æˆ·å¯ä»¥ç«‹å³çœ‹åˆ°AIå¼€å§‹å“åº”ï¼Œè€Œä¸æ˜¯ç­‰å¾…å®Œæ•´ç»“æœ
2. **å¤„ç†é•¿æ—¶é—´ä»»åŠ¡**ï¼šAIæ¨ç†å¯èƒ½éœ€è¦å‡ ç§’åˆ°å‡ åˆ†é’Ÿï¼Œæµå¼å“åº”ä¿æŒç”¨æˆ·å‚ä¸æ„Ÿ
3. **å†…å®¹é¢„è§ˆ**ï¼šç”¨æˆ·å¯ä»¥æå‰é˜…è¯»éƒ¨åˆ†ç»“æœï¼Œæå‡äº¤äº’æ•ˆç‡
4. **é”™è¯¯å¿«é€Ÿåé¦ˆ**ï¼šå¦‚æœå¤„ç†å‡ºç°é—®é¢˜ï¼Œå¯ä»¥ç«‹å³åœæ­¢å¹¶åé¦ˆç»™ç”¨æˆ·

### å…¸å‹çš„AIæµå¼åœºæ™¯

```
ä¼ ç»Ÿæ¨¡å¼ï¼š
ç”¨æˆ·æé—® â†’ [ç­‰å¾…30ç§’] â†’ å®Œæ•´ç­”æ¡ˆæ˜¾ç¤º

æµå¼æ¨¡å¼ï¼š
ç”¨æˆ·æé—® â†’ ç«‹å³æ˜¾ç¤º"æ­£åœ¨æ€è€ƒ..." â†’ é€æ­¥æ˜¾ç¤ºç­”æ¡ˆå†…å®¹ â†’ å®Œæˆ
```

## 2.2.3.2 Server-Sent Events (SSE) å®ç°

### åç«¯SSEæœåŠ¡å®ç°

åŸºäºJD Genieé¡¹ç›®çš„SSEå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¼ä¸šçº§çš„æµå¼å“åº”æ¶æ„ï¼š

```java
// GenieController.java - SSEæ§åˆ¶å™¨å®ç°
@RestController
public class GenieController {
    
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
    private static final long HEARTBEAT_INTERVAL = 10_000L; // 10ç§’å¿ƒè·³é—´éš”
    
    @PostMapping("/AutoAgent")
    public SseEmitter AutoAgent(@RequestBody AgentRequest request) 
            throws UnsupportedEncodingException {
        
        logger.info("{} auto agent request: {}", 
                   request.getRequestId(), JSON.toJSONString(request));

        Long AUTO_AGENT_SSE_TIMEOUT = 60 * 60 * 1000L; // 1å°æ—¶è¶…æ—¶
        SseEmitter emitter = new SseEmitter(AUTO_AGENT_SSE_TIMEOUT);
        
        // å¯åŠ¨å¿ƒè·³æœºåˆ¶
        ScheduledFuture<?> heartbeatFuture = startHeartbeat(emitter, request.getRequestId());
        
        // æ³¨å†Œè¿æ¥ç›‘å¬å™¨
        registerSSEMonitor(emitter, request.getRequestId(), heartbeatFuture);
        
        // å¼‚æ­¥æ‰§è¡ŒAIå¤„ç†é€»è¾‘
        ThreadUtil.execute(() -> {
            try {
                Printer printer = new SSEPrinter(emitter, request, request.getAgentType());
                AgentContext agentContext = buildAgentContext(request, printer);
                
                // è·å–å¤„ç†å™¨å¹¶æ‰§è¡Œ
                AgentHandlerService handler = agentHandlerFactory.getHandler(agentContext, request);
                handler.handle(agentContext, request);
                
                // æ­£å¸¸å®Œæˆ
                emitter.complete();
                
            } catch (Exception e) {
                logger.error("{} auto agent error", request.getRequestId(), e);
                emitter.completeWithError(e);
            }
        });

        return emitter;
    }
    
    /**
     * SSEå¿ƒè·³æœºåˆ¶ï¼šä¿æŒé•¿è¿æ¥æ´»è·ƒ
     */
    private ScheduledFuture<?> startHeartbeat(SseEmitter emitter, String requestId) {
        return executor.scheduleAtFixedRate(() -> {
            try {
                logger.debug("{} send heartbeat", requestId);
                emitter.send("heartbeat");
            } catch (Exception e) {
                logger.error("{} heartbeat failed, closing connection", requestId, e);
                emitter.completeWithError(e);
            }
        }, HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL, TimeUnit.MILLISECONDS);
    }
    
    /**
     * SSEè¿æ¥äº‹ä»¶ç›‘å¬
     */
    private void registerSSEMonitor(SseEmitter emitter, String requestId, 
                                   ScheduledFuture<?> heartbeatFuture) {
        // æ­£å¸¸å®Œæˆäº‹ä»¶
        emitter.onCompletion(() -> {
            logger.info("{} SSE connection completed normally", requestId);
            heartbeatFuture.cancel(true);
        });

        // è¿æ¥è¶…æ—¶äº‹ä»¶
        emitter.onTimeout(() -> {
            logger.info("{} SSE connection timed out", requestId);
            heartbeatFuture.cancel(true);
            emitter.complete();
        });

        // è¿æ¥é”™è¯¯äº‹ä»¶
        emitter.onError((ex) -> {
            logger.error("{} SSE connection error", requestId, ex);
            heartbeatFuture.cancel(true);
            emitter.completeWithError(ex);
        });
    }
}
```

### SSEæ‰“å°å™¨ï¼šç»“æ„åŒ–æ¶ˆæ¯è¾“å‡º

```java
// SSEPrinter.java - æµå¼æ¶ˆæ¯è¾“å‡ºå™¨
public class SSEPrinter implements Printer {
    
    private final SseEmitter emitter;
    private final AgentRequest request;
    private String agentType;

    @Override
    public void send(String messageId, String messageType, Object message, 
                    String digitalEmployee, Boolean isFinal) {
        try {
            AgentResponse response = new AgentResponse();
            response.setRequestId(request.getRequestId());
            response.setMessageId(messageId);
            response.setMessageType(messageType);
            response.setIsFinal(isFinal);
            response.setDigitalEmployee(digitalEmployee);

            // æ ¹æ®æ¶ˆæ¯ç±»å‹å¤„ç†å†…å®¹
            switch (messageType) {
                case "planning":
                    if (message instanceof List) {
                        @SuppressWarnings("unchecked")
                        List<String> plans = (List<String>) message;
                        response.setPlanList(plans);
                    }
                    break;
                    
                case "agent_stream":
                    response.setResult((String) message);
                    break;
                    
                case "result":
                    if (message instanceof Map) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> taskResult = (Map<String, Object>) message;
                        response.setResultMap(taskResult);
                        Object summary = taskResult.get("taskSummary");
                        response.setResult(summary != null ? summary.toString() : null);
                    }
                    response.getResultMap().put("agentType", agentType);
                    break;
                    
                default:
                    logger.warn("Unknown message type: {}", messageType);
                    break;
            }

            // å‘é€SSEæ¶ˆæ¯
            emitter.send(response);

        } catch (Exception e) {
            logger.error("SSE send error", e);
        }
    }
    
    @Override
    public void close() {
        emitter.complete();
    }
}
```

## 2.2.3.3 Python FastAPIæµå¼å“åº”

### EventSourceResponseå®ç°

PythonæœåŠ¡ä½¿ç”¨FastAPIçš„EventSourceResponseå®ç°æµå¼è¾“å‡ºï¼š

```python
# tool.py - FastAPIæµå¼APIå®ç°
from fastapi.responses import EventSourceResponse
from sse_starlette import ServerSentEvent

@app.post("/v1/tool/deepsearch")
async def post_deepsearch(body: DeepSearchRequest):
    """æ·±åº¦æœç´¢çš„æµå¼API"""
    
    async def _stream():
        """å¼‚æ­¥æµå¼ç”Ÿæˆå™¨"""
        try:
            deepsearch = DeepSearch()
            
            # æµå¼æ‰§è¡Œæœç´¢ä»»åŠ¡
            async for chunk in deepsearch.run(
                query=body.query,
                request_id=body.request_id,
                stream=True,
                stream_mode=StreamMode()
            ):
                # å‘é€æµå¼æ•°æ®
                yield ServerSentEvent(
                    data=chunk,
                    event="data",
                    id=body.request_id
                )
                
                # æ§åˆ¶æµå¼è¾“å‡ºé¢‘ç‡
                await asyncio.sleep(0.01)
                
        except Exception as e:
            logger.error(f"DeepSearch streaming error: {e}")
            yield ServerSentEvent(
                data=json.dumps({
                    "error": str(e),
                    "requestId": body.request_id,
                    "isFinal": True
                }),
                event="error",
                id=body.request_id
            )

    return EventSourceResponse(
        _stream(),
        ping_message_factory=lambda: ServerSentEvent(data="heartbeat"),
        ping=15  # 15ç§’å¿ƒè·³é—´éš”
    )
```

### å¼‚æ­¥æµå¼æ•°æ®å¤„ç†

```python
# deepsearch.py - æµå¼æœç´¢å®ç°
class DeepSearch:
    
    async def run(self, query: str, request_id: str = None, 
                  stream: bool = False, **kwargs) -> AsyncGenerator[str, None]:
        """æµå¼æ‰§è¡Œæ·±åº¦æœç´¢"""
        
        try:
            # ç¬¬ä¸€é˜¶æ®µï¼šæŸ¥è¯¢åˆ†è§£
            yield self._create_stream_message(
                request_id=request_id,
                status="query_decomposition",
                message="æ­£åœ¨åˆ†è§£æŸ¥è¯¢..."
            )
            
            queries = await query_decompose(query, request_id=request_id)
            
            # ç¬¬äºŒé˜¶æ®µï¼šå¹¶è¡Œæœç´¢
            yield self._create_stream_message(
                request_id=request_id,
                status="searching",
                message=f"æ­£åœ¨æœç´¢ {len(queries)} ä¸ªå­æŸ¥è¯¢..."
            )
            
            docs, search_results = await self._search_queries_and_dedup(queries, request_id)
            
            # ç¬¬ä¸‰é˜¶æ®µï¼šç”Ÿæˆç­”æ¡ˆ
            yield self._create_stream_message(
                request_id=request_id,
                status="generating",
                message="æ­£åœ¨ç”Ÿæˆç­”æ¡ˆ...",
                search_result={
                    "query": queries,
                    "docs": [doc.dict() for doc in docs[:5]]  # åªæ˜¾ç¤ºå‰5ä¸ªç»“æœ
                }
            )
            
            # æµå¼ç­”æ¡ˆç”Ÿæˆ
            acc_content = ""
            async for chunk in answer_question(
                query=query, 
                docs=docs, 
                request_id=request_id,
                stream=stream
            ):
                if stream and chunk:
                    acc_content += chunk
                    yield json.dumps({
                        "requestId": request_id,
                        "query": query,
                        "searchResult": {
                            "query": queries, 
                            "docs": [doc.dict() for doc in docs]
                        },
                        "answer": chunk,
                        "isFinal": False,
                        "messageType": "search"
                    }, ensure_ascii=False)
            
            # æœ€ç»ˆç»“æœ
            yield json.dumps({
                "requestId": request_id,
                "query": query,
                "searchResult": {
                    "query": queries, 
                    "docs": [doc.dict() for doc in docs]
                },
                "answer": acc_content,
                "isFinal": True,
                "messageType": "search"
            }, ensure_ascii=False)
            
        except Exception as e:
            logger.error(f"DeepSearch streaming error: {e}")
            yield json.dumps({
                "requestId": request_id,
                "query": query,
                "error": str(e),
                "isFinal": True,
                "messageType": "error"
            }, ensure_ascii=False)
    
    def _create_stream_message(self, request_id: str, status: str, 
                              message: str, **kwargs) -> str:
        """åˆ›å»ºæµå¼æ¶ˆæ¯"""
        data = {
            "requestId": request_id,
            "status": status,
            "message": message,
            "isFinal": False,
            "messageType": "status"
        }
        data.update(kwargs)
        return json.dumps(data, ensure_ascii=False)
```

## 2.2.3.4 å‰ç«¯SSEå®¢æˆ·ç«¯å®ç°

### TypeScript SSEå®¢æˆ·ç«¯

```typescript
// querySSE.ts - ç°ä»£åŒ–SSEå®¢æˆ·ç«¯å®ç°
import { fetchEventSource, EventSourceMessage } from '@microsoft/fetch-event-source';

interface SSEConfig {
  body: any;
  handleMessage: (data: any) => void;
  handleError: (error: Error) => void;
  handleClose: () => void;
  onStatusChange?: (status: string) => void;
}

const SSE_HEADERS = {
  'Content-Type': 'application/json',
  'Cache-Control': 'no-cache',
  'Connection': 'keep-alive',
  'Accept': 'text/event-stream',
};

export default function createSSEConnection(
  config: SSEConfig, 
  url: string = DEFAULT_SSE_URL
): AbortController {
  
  const { body, handleMessage, handleError, handleClose, onStatusChange } = config;
  const abortController = new AbortController();

  fetchEventSource(url, {
    method: 'POST',
    credentials: 'include',
    headers: SSE_HEADERS,
    body: JSON.stringify(body),
    signal: abortController.signal,
    openWhenHidden: true,
    
    onopen(response) {
      console.log('SSE connection opened:', response.status);
      onStatusChange?.('connected');
      
      if (response.ok && response.headers.get('content-type')?.includes('text/event-stream')) {
        return; // è¿æ¥æˆåŠŸ
      } else {
        throw new Error(`SSE connection failed: ${response.status}`);
      }
    },
    
    onmessage(event: EventSourceMessage) {
      try {
        // å¤„ç†å¿ƒè·³æ¶ˆæ¯
        if (event.data === 'heartbeat') {
          console.debug('Received heartbeat');
          return;
        }
        
        // è§£æå¹¶å¤„ç†ä¸šåŠ¡æ¶ˆæ¯
        const parsedData = JSON.parse(event.data);
        handleMessage(parsedData);
        
        // çŠ¶æ€æ›´æ–°
        if (parsedData.messageType === 'status') {
          onStatusChange?.(parsedData.status);
        }
        
      } catch (error) {
        console.error('Error parsing SSE message:', error);
        handleError(new Error('Failed to parse SSE message'));
      }
    },
    
    onerror(error: Error) {
      console.error('SSE error:', error);
      onStatusChange?.('error');
      handleError(error);
    },
    
    onclose() {
      console.log('SSE connection closed');
      onStatusChange?.('disconnected');
      handleClose();
    }
  });
  
  return abortController;
}
```

### React Hooksé›†æˆ

```typescript
// useAIStream.ts - Reactæµå¼AIäº¤äº’Hook
import { useState, useCallback, useRef, useEffect } from 'react';

interface StreamMessage {
  id: string;
  type: string;
  content: string;
  timestamp: number;
  isFinal: boolean;
  metadata?: any;
}

interface StreamState {
  messages: StreamMessage[];
  isConnected: boolean;
  isLoading: boolean;
  error: string | null;
  status: string;
}

export function useAIStream() {
  const [state, setState] = useState<StreamState>({
    messages: [],
    isConnected: false,
    isLoading: false,
    error: null,
    status: 'disconnected'
  });
  
  const abortControllerRef = useRef<AbortController | null>(null);
  
  const sendMessage = useCallback(async (query: string, agentType: string = 'react') => {
    // é‡ç½®çŠ¶æ€
    setState(prev => ({
      ...prev,
      messages: [],
      isLoading: true,
      error: null,
      status: 'connecting'
    }));
    
    // ä¸­æ–­ä¹‹å‰çš„è¿æ¥
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    const config: SSEConfig = {
      body: { 
        query, 
        agentType,
        requestId: `req_${Date.now()}`,
        isStream: true
      },
      
      handleMessage: (data) => {
        const message: StreamMessage = {
          id: data.messageId || `msg_${Date.now()}`,
          type: data.messageType || 'text',
          content: data.result || data.message || '',
          timestamp: Date.now(),
          isFinal: data.isFinal || false,
          metadata: {
            agentType: data.agentType,
            planList: data.planList,
            searchResult: data.searchResult
          }
        };
        
        setState(prev => ({
          ...prev,
          messages: [...prev.messages, message],
          isLoading: !message.isFinal
        }));
      },
      
      handleError: (error) => {
        setState(prev => ({
          ...prev,
          error: error.message,
          isLoading: false,
          isConnected: false,
          status: 'error'
        }));
      },
      
      handleClose: () => {
        setState(prev => ({
          ...prev,
          isLoading: false,
          isConnected: false,
          status: 'disconnected'
        }));
      },
      
      onStatusChange: (status) => {
        setState(prev => ({
          ...prev,
          status,
          isConnected: status === 'connected'
        }));
      }
    };

    // åˆ›å»ºæ–°è¿æ¥
    abortControllerRef.current = createSSEConnection(config);
  }, []);
  
  const disconnect = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);
  
  // ç»„ä»¶å¸è½½æ—¶æ¸…ç†è¿æ¥
  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);
  
  return {
    ...state,
    sendMessage,
    disconnect
  };
}
```

## 2.2.3.5 WebSocket vs SSE æŠ€æœ¯é€‰å‹

### SSEçš„ä¼˜åŠ¿

1. **ç®€å•æ˜“ç”¨**ï¼šåŸºäºHTTPåè®®ï¼Œç©¿è¶Šä»£ç†å’Œé˜²ç«å¢™å®¹æ˜“
2. **è‡ªåŠ¨é‡è¿**ï¼šæµè§ˆå™¨åŸç”Ÿæ”¯æŒæ–­çº¿é‡è¿
3. **å•å‘é€šä¿¡**ï¼šé€‚åˆæœåŠ¡ç«¯æ¨é€åœºæ™¯
4. **æ ‡å‡†åŒ–**ï¼šW3Cæ ‡å‡†ï¼Œæµè§ˆå™¨æ”¯æŒè‰¯å¥½

```typescript
// SSEé€‚ç”¨åœºæ™¯ç¤ºä¾‹
const eventSource = new EventSource('/api/ai-stream');
eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  updateUI(data);
};
```

### WebSocketçš„ä¼˜åŠ¿

1. **åŒå‘é€šä¿¡**ï¼šæ”¯æŒå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯åŒå‘å®æ—¶äº¤äº’
2. **æ›´ä½å»¶è¿Ÿ**ï¼šæ²¡æœ‰HTTPå¤´éƒ¨å¼€é”€
3. **äºŒè¿›åˆ¶æ”¯æŒ**ï¼šå¯ä»¥ä¼ è¾“äºŒè¿›åˆ¶æ•°æ®
4. **åè®®çµæ´»**ï¼šå¯ä»¥è‡ªå®šä¹‰å­åè®®

```typescript
// WebSocketé€‚ç”¨åœºæ™¯ç¤ºä¾‹
const ws = new WebSocket('wss://api.example.com/ai-socket');
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === 'ai_response') {
    updateUI(data);
  }
};
ws.send(JSON.stringify({ type: 'user_input', data: userQuery }));
```

### AIåº”ç”¨åœºæ™¯é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæŠ€æœ¯ | ç†ç”± |
|------|----------|------|
| ChatGPTå¼å¯¹è¯ | SSE | å•å‘æµå¼è¾“å‡ºï¼Œç®€å•å¯é  |
| å®æ—¶åä½œç¼–è¾‘ | WebSocket | éœ€è¦åŒå‘å®æ—¶åŒæ­¥ |
| AIæ¨¡å‹è®­ç»ƒç›‘æ§ | SSE | æœåŠ¡ç«¯çŠ¶æ€æ¨é€ä¸ºä¸» |
| æ¸¸æˆAIå¯¹æˆ˜ | WebSocket | é«˜é¢‘åŒå‘äº¤äº’ |
| æ–‡æ¡£AIåˆ†æ | SSE | åˆ†æç»“æœæµå¼å±•ç¤º |

## 2.2.3.6 æµå¼æ•°æ®çš„èƒŒå‹æ§åˆ¶

### å®¢æˆ·ç«¯èƒŒå‹å¤„ç†

```typescript
// èƒŒå‹æ§åˆ¶çš„SSEå®¢æˆ·ç«¯
class BackpressureSSEClient {
  private messageQueue: any[] = [];
  private processing = false;
  private maxQueueSize = 100;
  
  constructor(private config: SSEConfig) {}
  
  start() {
    const originalHandleMessage = this.config.handleMessage;
    
    this.config.handleMessage = (data) => {
      // é˜Ÿåˆ—æ»¡æ—¶ä¸¢å¼ƒæ—§æ¶ˆæ¯
      if (this.messageQueue.length >= this.maxQueueSize) {
        this.messageQueue.shift();
        console.warn('Message queue overflow, dropping old message');
      }
      
      this.messageQueue.push(data);
      this.processQueue();
    };
    
    createSSEConnection(this.config);
  }
  
  private async processQueue() {
    if (this.processing) return;
    
    this.processing = true;
    try {
      while (this.messageQueue.length > 0) {
        const message = this.messageQueue.shift();
        await this.processMessage(message);
        
        // æ§åˆ¶å¤„ç†é€Ÿç‡
        await new Promise(resolve => setTimeout(resolve, 10));
      }
    } finally {
      this.processing = false;
    }
  }
  
  private async processMessage(message: any) {
    // å¤„ç†å•ä¸ªæ¶ˆæ¯
    try {
      await this.config.handleMessage(message);
    } catch (error) {
      console.error('Error processing message:', error);
    }
  }
}
```

### æœåŠ¡ç«¯æµé‡æ§åˆ¶

```python
# æœåŠ¡ç«¯èƒŒå‹æ§åˆ¶
import asyncio
from collections import deque

class FlowControlledStream:
    def __init__(self, max_buffer_size: int = 1000):
        self.buffer = deque(maxlen=max_buffer_size)
        self.client_ready = asyncio.Event()
        self.client_ready.set()  # åˆå§‹çŠ¶æ€ä¸ºå°±ç»ª
    
    async def send_with_backpressure(self, data: str):
        """å¸¦èƒŒå‹æ§åˆ¶çš„å‘é€"""
        
        # ç­‰å¾…å®¢æˆ·ç«¯å°±ç»ª
        await self.client_ready.wait()
        
        # æ£€æŸ¥ç¼“å†²åŒº
        if len(self.buffer) >= self.buffer.maxlen * 0.8:
            # ç¼“å†²åŒºæ¥è¿‘æ»¡ï¼Œæš‚åœå‘é€
            self.client_ready.clear()
            logger.warning("Buffer near full, pausing stream")
            
            # ç­‰å¾…ç¼“å†²åŒºæ¸…ç©º
            while len(self.buffer) > self.buffer.maxlen * 0.3:
                await asyncio.sleep(0.1)
            
            self.client_ready.set()
        
        self.buffer.append(data)
        return data
    
    async def stream_generator(self):
        """æµå¼ç”Ÿæˆå™¨"""
        while self.buffer:
            try:
                data = self.buffer.popleft()
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.01)  # æ§åˆ¶å‘é€é€Ÿç‡
            except IndexError:
                break

@app.post("/v1/controlled-stream")
async def controlled_stream(request: StreamRequest):
    flow_controller = FlowControlledStream()
    
    async def _stream():
        # æ¨¡æ‹ŸAIå¤„ç†å¹¶ç”Ÿæˆæ•°æ®
        for i in range(1000):
            data = f"Processing step {i}"
            await flow_controller.send_with_backpressure(data)
        
        # æµå¼è¾“å‡º
        async for chunk in flow_controller.stream_generator():
            yield chunk
    
    return EventSourceResponse(_stream())
```

## 2.2.3.7 å®¹é”™ä¸æ¢å¤æœºåˆ¶

### æ–­çº¿é‡è¿ç­–ç•¥

```typescript
// æ™ºèƒ½é‡è¿çš„SSEå®¢æˆ·ç«¯
class ResilientSSEClient {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private baseRetryDelay = 1000; // 1ç§’
  private currentConnection: AbortController | null = null;
  
  constructor(
    private config: SSEConfig,
    private url: string
  ) {}
  
  connect() {
    this.attemptConnection();
  }
  
  private async attemptConnection() {
    try {
      if (this.currentConnection) {
        this.currentConnection.abort();
      }
      
      const enhancedConfig: SSEConfig = {
        ...this.config,
        handleError: (error) => {
          console.error('SSE connection error:', error);
          this.handleConnectionError(error);
        },
        handleClose: () => {
          console.log('SSE connection closed');
          this.handleConnectionClose();
        }
      };
      
      this.currentConnection = createSSEConnection(enhancedConfig, this.url);
      this.reconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°
      
    } catch (error) {
      this.handleConnectionError(error);
    }
  }
  
  private handleConnectionError(error: any) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = this.calculateRetryDelay();
      console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.reconnectAttempts++;
        this.attemptConnection();
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
      this.config.handleError(new Error('Connection failed after maximum retries'));
    }
  }
  
  private handleConnectionClose() {
    // æ­£å¸¸å…³é—­ä¸éœ€è¦é‡è¿
    this.config.handleClose();
  }
  
  private calculateRetryDelay(): number {
    // æŒ‡æ•°é€€é¿ç®—æ³•
    return Math.min(
      this.baseRetryDelay * Math.pow(2, this.reconnectAttempts),
      30000 // æœ€å¤§30ç§’
    );
  }
  
  disconnect() {
    this.reconnectAttempts = this.maxReconnectAttempts; // é˜»æ­¢è‡ªåŠ¨é‡è¿
    if (this.currentConnection) {
      this.currentConnection.abort();
      this.currentConnection = null;
    }
  }
}
```

### æ¶ˆæ¯å»é‡ä¸æ’åº

```typescript
// æ¶ˆæ¯å»é‡å’Œæ’åºå¤„ç†
class OrderedMessageHandler {
  private messageBuffer = new Map<string, any>();
  private expectedSequence = 0;
  private processedMessages = new Set<string>();
  
  handleMessage(message: any) {
    // å»é‡å¤„ç†
    if (this.processedMessages.has(message.id)) {
      console.warn('Duplicate message received:', message.id);
      return;
    }
    
    // å¦‚æœæ¶ˆæ¯æœ‰åºåˆ—å·ï¼Œè¿›è¡Œæ’åº
    if (message.sequence !== undefined) {
      this.handleOrderedMessage(message);
    } else {
      // æ— åºåˆ—å·æ¶ˆæ¯ç›´æ¥å¤„ç†
      this.processMessage(message);
    }
  }
  
  private handleOrderedMessage(message: any) {
    if (message.sequence === this.expectedSequence) {
      // æœŸæœ›çš„ä¸‹ä¸€ä¸ªæ¶ˆæ¯ï¼Œç«‹å³å¤„ç†
      this.processMessage(message);
      this.expectedSequence++;
      
      // æ£€æŸ¥ç¼“å†²åŒºä¸­æ˜¯å¦æœ‰åç»­æ¶ˆæ¯
      this.processBufferedMessages();
    } else if (message.sequence > this.expectedSequence) {
      // æœªæ¥çš„æ¶ˆæ¯ï¼Œç¼“å­˜èµ·æ¥
      this.messageBuffer.set(message.sequence.toString(), message);
    }
    // è¿‡æœŸæ¶ˆæ¯ç›´æ¥ä¸¢å¼ƒ
  }
  
  private processBufferedMessages() {
    while (this.messageBuffer.has(this.expectedSequence.toString())) {
      const message = this.messageBuffer.get(this.expectedSequence.toString());
      this.messageBuffer.delete(this.expectedSequence.toString());
      this.processMessage(message);
      this.expectedSequence++;
    }
  }
  
  private processMessage(message: any) {
    this.processedMessages.add(message.id);
    // å®é™…çš„æ¶ˆæ¯å¤„ç†é€»è¾‘
    console.log('Processing message:', message);
  }
}
```

## 2.2.3.8 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æ¶ˆæ¯å‹ç¼©ä¸æ‰¹é‡å¤„ç†

```python
# æœåŠ¡ç«¯æ¶ˆæ¯ä¼˜åŒ–
import json
import gzip
from typing import List

class OptimizedSSEHandler:
    
    def __init__(self, compression_threshold: int = 1024, batch_size: int = 10):
        self.compression_threshold = compression_threshold
        self.batch_size = batch_size
        self.message_batch: List[dict] = []
    
    async def send_message(self, message: dict, force_send: bool = False):
        """æ‰¹é‡å‘é€æ¶ˆæ¯"""
        self.message_batch.append(message)
        
        if len(self.message_batch) >= self.batch_size or force_send:
            await self._flush_batch()
    
    async def _flush_batch(self):
        """åˆ·æ–°æ¶ˆæ¯æ‰¹æ¬¡"""
        if not self.message_batch:
            return
            
        if len(self.message_batch) == 1:
            # å•æ¡æ¶ˆæ¯ç›´æ¥å‘é€
            message = self.message_batch[0]
            yield self._format_sse_message(message)
        else:
            # æ‰¹é‡æ¶ˆæ¯æ‰“åŒ…å‘é€
            batch_data = {
                "type": "batch",
                "messages": self.message_batch,
                "count": len(self.message_batch)
            }
            yield self._format_sse_message(batch_data)
        
        self.message_batch.clear()
    
    def _format_sse_message(self, data: dict) -> str:
        """æ ¼å¼åŒ–SSEæ¶ˆæ¯"""
        json_data = json.dumps(data, ensure_ascii=False)
        
        # å¤§æ¶ˆæ¯å‹ç¼©
        if len(json_data) > self.compression_threshold:
            compressed_data = gzip.compress(json_data.encode('utf-8'))
            encoded_data = base64.b64encode(compressed_data).decode('ascii')
            return f"data: {{\"compressed\": true, \"data\": \"{encoded_data}\"}}\n\n"
        else:
            return f"data: {json_data}\n\n"

# ä½¿ç”¨ç¤ºä¾‹
@app.post("/v1/optimized-stream")
async def optimized_stream(request: StreamRequest):
    handler = OptimizedSSEHandler()
    
    async def _stream():
        try:
            # æ¨¡æ‹ŸAIå¤„ç†è¿‡ç¨‹
            for i in range(100):
                message = {
                    "sequence": i,
                    "content": f"Processing step {i}",
                    "timestamp": time.time()
                }
                
                # æ‰¹é‡å‘é€ï¼Œæœ€åä¸€æ¡å¼ºåˆ¶å‘é€
                async for chunk in handler.send_message(
                    message, 
                    force_send=(i == 99)
                ):
                    yield chunk
                
                await asyncio.sleep(0.1)
        
        except Exception as e:
            yield f"data: {{\"error\": \"{str(e)}\"}}\n\n"
    
    return EventSourceResponse(_stream())
```

## å°ç»“

æµå¼å“åº”ä¸å®æ—¶é€šä¿¡æ˜¯ç°ä»£AIåº”ç”¨ç”¨æˆ·ä½“éªŒçš„å…³é”®æŠ€æœ¯ã€‚é€šè¿‡åˆç†é€‰æ‹©SSEæˆ–WebSocketæŠ€æœ¯ï¼Œé…åˆé€‚å½“çš„èƒŒå‹æ§åˆ¶ã€å®¹é”™æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œå¯ä»¥æ„å»ºå‡ºå“åº”è¿…é€Ÿã€ç”¨æˆ·ä½“éªŒä¼˜ç§€çš„AIåº”ç”¨ã€‚

å…³é”®è¦ç‚¹ï¼š
1. **æŠ€æœ¯é€‰å‹**ï¼šæ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©SSEæˆ–WebSocket
2. **èƒŒå‹æ§åˆ¶**ï¼šé˜²æ­¢å®¢æˆ·ç«¯å¤„ç†ä¸è¿‡æ¥å¯¼è‡´çš„é—®é¢˜
3. **å®¹é”™æœºåˆ¶**ï¼šå¤„ç†ç½‘ç»œä¸ç¨³å®šå’Œè¿æ¥ä¸­æ–­
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ¶ˆæ¯æ‰¹é‡å¤„ç†å’Œå‹ç¼©ä¼ è¾“

---

**æœ€ä½³å®è·µå»ºè®®ï¼š**
1. ä¼˜å…ˆé€‰æ‹©SSEï¼Œé™¤ééœ€è¦åŒå‘é€šä¿¡
2. å®ç°æ™ºèƒ½é‡è¿å’Œæ¶ˆæ¯å»é‡æœºåˆ¶
3. ç›‘æ§è¿æ¥è´¨é‡å’Œæ¶ˆæ¯å»¶è¿Ÿ
4. ä¸ºç”¨æˆ·æä¾›è¿æ¥çŠ¶æ€åé¦ˆ
