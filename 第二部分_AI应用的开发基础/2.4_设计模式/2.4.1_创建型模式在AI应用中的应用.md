# 2.4.1 创建型模式在AI应用中的应用

创建型设计模式关注对象的创建机制，力图根据实际情况使用合适的方式来创建对象。在AI应用开发中，创建型模式尤其重要，因为AI系统往往需要动态创建各种智能体、工具和配置对象。本节将通过JoyAgent-JDGenie项目的实际代码，深入分析工厂模式、建造者模式和单例模式在AI应用中的具体应用。

## 工厂模式：智能体处理器的动态创建

在JoyAgent-JDGenie中，`AgentHandlerFactory`类是工厂模式的经典实现。该工厂负责根据请求类型和上下文信息动态创建相应的智能体处理器。

### 代码实现

```java
@Component
public class AgentHandlerFactory {

    private final Map<String, AgentHandlerService> handlerMap = new ConcurrentHashMap<>();

    // 构造函数注入所有DataHandler实现
    @Autowired
    public AgentHandlerFactory(List<AgentHandlerService> handlers) {
        // 初始化处理器映射
        for (AgentHandlerService handler : handlers) {
            // 可根据Handler的supports方法或自定义注解来注册
            handlerMap.put(handler.getClass().getSimpleName().toLowerCase(), handler);
        }
    }

    // 根据类型获取处理器
    public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
        if (Objects.isNull(context) || Objects.isNull(request)) {
            return null;
        }

        // 方法1：通过supports方法匹配
        for (AgentHandlerService handler : handlerMap.values()) {
            if (handler.support(context, request)) {
                return handler;
            }
        }

        return null;
    }
}
```

### 设计优势

1. **解耦创建逻辑**：客户端代码不需要知道具体处理器的创建细节
2. **动态扩展**：新增处理器类型只需实现`AgentHandlerService`接口
3. **性能优化**：通过预初始化处理器映射，避免了重复创建开销
4. **类型安全**：通过`support`方法确保返回正确的处理器类型

### AI应用中的特殊考虑

在AI应用中，工厂模式的应用需要考虑以下特殊因素：

- **智能体状态管理**：每个智能体可能需要维护独立的状态和记忆
- **资源管理**：AI模型调用涉及GPU资源，需要合理分配
- **异步处理**：智能体处理往往是异步的，工厂需要支持异步创建

## 建造者模式：复杂AI上下文的构建

`AgentContext`是JoyAgent-JDGenie中的核心上下文对象，包含了智能体执行所需的所有信息。由于其复杂性，项目采用了建造者模式来简化对象的创建过程。

### 代码实现

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AgentContext {
    private String requestId;
    private String sessionId;
    private Printer printer;
    private String query;
    private String task;
    private String dateInfo;
    private List<File> productFiles;
    private List<File> taskProductFiles;
    private String sopPrompt;
    private String basePrompt;
    private String agentType;
    private Boolean isStream;
    private ToolCollection toolCollection;
    
    // ... 其他属性和方法
}
```

### 使用示例

在`GenieController`中，建造者模式的使用非常优雅：

```java
AgentContext agentContext = AgentContext.builder()
        .requestId(request.getRequestId())
        .sessionId(request.getRequestId())
        .printer(printer)
        .query(request.getQuery())
        .task("")
        .dateInfo(DateUtil.CurrentDateInfo())
        .productFiles(new ArrayList<>())
        .taskProductFiles(new ArrayList<>())
        .sopPrompt(request.getSopPrompt())
        .basePrompt(request.getBasePrompt())
        .agentType(request.getAgentType())
        .isStream(Objects.nonNull(request.getIsStream()) ? request.getIsStream() : false)
        .build();
```

### 设计优势

1. **可读性强**：链式调用使得代码易于理解
2. **参数验证**：可以在`build()`方法中进行必要参数的验证
3. **不可变性**：构建完成后的对象可以设计为不可变的
4. **灵活性**：支持部分参数的可选设置

### AI应用中的扩展应用

在AI应用中，建造者模式特别适用于以下场景：

```java
// 智能体配置的构建
AgentConfig config = AgentConfig.builder()
        .modelName("gpt-4o")
        .maxTokens(4096)
        .temperature(0.7)
        .systemPrompt(systemPrompt)
        .tools(Arrays.asList("search", "code", "report"))
        .memorySize(1000)
        .enableStreaming(true)
        .build();

// 工具调用参数的构建
ToolCallRequest toolRequest = ToolCallRequest.builder()
        .toolName("code_interpreter")
        .parameters(parameters)
        .timeout(Duration.ofMinutes(5))
        .retryPolicy(RetryPolicy.exponentialBackoff())
        .context(agentContext)
        .build();
```

## 单例模式：配置管理和资源共享

在JoyAgent-JDGenie中，`GenieConfig`类通过Spring的依赖注入机制实现了单例模式的效果，确保整个应用中只有一个配置实例。

### 代码实现

```java
@Slf4j
@Getter
@Configuration
public class GenieConfig {

    @Value("${autobots.autoagent.planner.model_name:gpt-4o-0806}")
    private String plannerModelName;

    @Value("${autobots.autoagent.executor.model_name:gpt-4o-0806}")
    private String executorModelName;

    @Value("${autobots.autoagent.react.model_name:gpt-4o-0806}")
    private String reactModelName;

    private Map<String, String> plannerSystemPromptMap = new HashMap<>();
    @Value("${autobots.autoagent.planner.system_prompt:{}}")
    public void setPlannerSystemPromptMap(String list) {
        plannerSystemPromptMap = JSONObject.parseObject(list, 
            new TypeReference<Map<String, String>>() {});
    }

    // ... 更多配置项
}
```

### 使用场景

配置对象在各个组件中被广泛使用：

```java
// 在PlanningAgent中使用配置
public PlanningAgent(AgentContext context) {
    ApplicationContext applicationContext = SpringContextHolder.getApplicationContext();
    GenieConfig genieConfig = applicationContext.getBean(GenieConfig.class);
    
    setSystemPrompt(genieConfig.getPlannerSystemPromptMap()
        .getOrDefault(promptKey, PlanningPrompt.SYSTEM_PROMPT)
        .replace("{{tools}}", toolPrompt.toString())
        .replace("{{query}}", context.getQuery()));
        
    setLlm(new LLM(genieConfig.getPlannerModelName(), ""));
    setMaxSteps(genieConfig.getPlannerMaxSteps());
}
```

### 设计优势

1. **资源节约**：避免重复创建配置对象
2. **一致性保证**：确保全应用使用相同的配置
3. **动态更新**：支持配置的热更新（结合Spring Cloud Config）
4. **线程安全**：Spring框架保证了Bean的线程安全性

## 工厂模式的进阶应用

### 工厂方法模式：智能体的专业化创建

在实际项目中，我们可以进一步抽象工厂的创建逻辑：

```java
public abstract class AgentFactory {
    public abstract BaseAgent createAgent(AgentContext context);
    
    // 通用的初始化逻辑
    protected void initializeAgent(BaseAgent agent, AgentContext context) {
        agent.setContext(context);
        agent.setPrinter(context.getPrinter());
        agent.setAvailableTools(context.getToolCollection());
    }
}

public class PlanningAgentFactory extends AgentFactory {
    @Override
    public BaseAgent createAgent(AgentContext context) {
        PlanningAgent agent = new PlanningAgent(context);
        initializeAgent(agent, context);
        return agent;
    }
}
```

### 抽象工厂模式：AI模型生态系统

对于复杂的AI模型生态系统，抽象工厂模式提供了更好的扩展性：

```java
public interface LLMProviderFactory {
    LLMClient createChatClient();
    LLMClient createEmbeddingClient();
    
    default boolean supportsStreaming() {
        return true;
    }
    
    default String getProviderName() {
        return this.getClass().getSimpleName().replace("Factory", "");
    }
}
```

## 性能优化与最佳实践

### 1. 对象池模式

对于频繁创建的AI对象，可以考虑使用对象池：

```java
@Component
public class AgentPool {
    private final Queue<BaseAgent> availableAgents = new ConcurrentLinkedQueue<>();
    private final AtomicInteger totalAgents = new AtomicInteger(0);
    private final int maxPoolSize = 10;
    
    public BaseAgent borrowAgent(AgentType type) {
        BaseAgent agent = availableAgents.poll();
        if (agent == null && totalAgents.get() < maxPoolSize) {
            agent = createNewAgent(type);
            totalAgents.incrementAndGet();
        }
        return agent;
    }
    
    public void returnAgent(BaseAgent agent) {
        agent.reset(); // 重置状态
        availableAgents.offer(agent);
    }
}
```

### 2. 懒加载单例

对于资源密集型的AI组件：

```java
public class LLMModelSingleton {
    private static volatile LLMModelSingleton instance;
    private final LLMModel model;
    
    private LLMModelSingleton() {
        this.model = loadModel(); // 耗时的模型加载
    }
    
    public static LLMModelSingleton getInstance() {
        if (instance == null) {
            synchronized (LLMModelSingleton.class) {
                if (instance == null) {
                    instance = new LLMModelSingleton();
                }
            }
        }
        return instance;
    }
}
```

## 小结与展望

创建型模式在AI应用开发中发挥着重要作用：

1. **工厂模式**帮助我们管理智能体和处理器的创建复杂性
2. **建造者模式**简化了复杂AI上下文对象的构建
3. **单例模式**确保了配置和资源的统一管理

### 与其他模式的协作

创建型模式往往需要与其他模式配合使用：
- 工厂创建的对象可以通过**装饰者模式**增强功能
- 建造者构建的复杂对象可以通过**外观模式**简化使用
- 单例管理的配置可以通过**依赖注入**分发到各个组件

这些模式的合理应用不仅提高了代码的可维护性，还为系统的扩展和优化提供了良好的基础。在下一节中，我们将探讨结构型模式如何帮助我们构建灵活的AI组件架构，特别是如何通过装饰者、适配器等模式来处理AI系统的复杂性。