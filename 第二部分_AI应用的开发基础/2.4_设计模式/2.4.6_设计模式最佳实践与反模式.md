# 2.4.6 设计模式最佳实践与反模式

设计模式是软件工程中久经考验的解决方案，但在AGI应用开发中，传统的设计模式需要结合AI系统的特殊性进行适配和优化。本节将总结设计模式在AGI应用中的最佳实践，分析常见的反模式，并提供实际的改进建议。

## 设计模式选择原则

### 1. 基于问题域选择模式

在AGI应用开发中，不同的问题域适合不同的设计模式：

```java
// 智能体创建问题 -> 工厂模式族
public class AgentCreationStrategy {
    public static BaseAgent createAgent(AgentType type, AgentContext context) {
        switch (type) {
            case PLANNING:
                return AgentFactory.createPlanningAgent(context);  // 工厂方法
            case REACT:
                return AgentFactory.createReactAgent(context);     // 工厂方法
            case MULTI_MODAL:
                return new MultiModalAgentBuilder()                // 建造者模式
                    .withTextProcessor(context.getTextProcessor())
                    .withImageProcessor(context.getImageProcessor())
                    .withAudioProcessor(context.getAudioProcessor())
                    .build();
            default:
                return new DefaultAgent(context);                  // 简单工厂
        }
    }
}

// 智能体协作问题 -> 责任链模式
public class AgentCollaborationChain {
    public String processComplexTask(String task, AgentContext context) {
        return new PlanningAgentHandler()
            .setNext(new ExecutionAgentHandler())
            .setNext(new ValidationAgentHandler())
            .setNext(new ReportAgentHandler())
            .handle(context, new AgentRequest(task));
    }
}
```

### 2. 考虑AI系统的不确定性

AGI应用的不确定性要求我们在模式选择时考虑容错和降级：

```java
// 容错装饰者模式
public class FaultTolerantAgentDecorator implements Agent {
    private final Agent delegate;
    private final FallbackStrategy fallbackStrategy;
    
    @Override
    public String process(String input) {
        try {
            return delegate.process(input);
        } catch (Exception e) {
            log.warn("Primary agent failed, using fallback strategy", e);
            return fallbackStrategy.handle(input, e);
        }
    }
}

// 自适应策略模式
public class AdaptiveProcessingStrategy implements ProcessingStrategy {
    private final List<ProcessingStrategy> strategies;
    private final PerformanceMonitor monitor;
    
    @Override
    public String process(String input) {
        // 根据历史性能动态选择策略
        ProcessingStrategy bestStrategy = strategies.stream()
            .max(Comparator.comparingDouble(s -> monitor.getSuccessRate(s)))
            .orElse(strategies.get(0));
            
        return bestStrategy.process(input);
    }
}
```

## AI应用中的常见反模式

### 1. 上帝智能体反模式

**问题描述**：将所有功能都集中在一个巨大的智能体类中。

```java
// ❌ 反模式：上帝智能体
public class GodAgent {
    public String processNaturalLanguage(String input) { /* ... */ }
    public String generateCode(String requirement) { /* ... */ }
    public String analyzeData(String data) { /* ... */ }
    public String createReport(String data) { /* ... */ }
    public String searchWeb(String query) { /* ... */ }
    public String processImage(byte[] image) { /* ... */ }
    public String translateText(String text, String language) { /* ... */ }
    // ... 更多功能
}
```

**解决方案**：使用组合模式和策略模式分解功能。

```java
// ✅ 正确做法：功能分解
public class CompositeAgent {
    private final Map<TaskType, SpecializedAgent> specialists;
    private final TaskClassifier classifier;
    
    public String process(String input) {
        TaskType taskType = classifier.classify(input);
        SpecializedAgent specialist = specialists.get(taskType);
        return specialist.process(input);
    }
}

public class CodeGenerationAgent implements SpecializedAgent {
    @Override
    public String process(String input) {
        // 专门处理代码生成任务
        return generateCode(input);
    }
}
```

### 2. 硬编码配置反模式

**问题描述**：将AI模型配置、提示词等硬编码在代码中。

```java
// ❌ 反模式：硬编码配置
public class HardcodedAgent {
    public String process(String input) {
        LLM llm = new LLM("gpt-4o", "sk-xxx", "https://api.openai.com/v1");
        String systemPrompt = "You are a helpful assistant. Always respond in JSON format...";
        return llm.chat(systemPrompt, input);
    }
}
```

**解决方案**：使用配置管理和依赖注入。

```java
// ✅ 正确做法：配置外部化
@Component
public class ConfigurableAgent {
    @Autowired
    private LLMProvider llmProvider;
    
    @Autowired
    private PromptTemplateService promptService;
    
    @Value("${agent.system-prompt-template}")
    private String systemPromptTemplate;
    
    public String process(String input) {
        String systemPrompt = promptService.renderTemplate(systemPromptTemplate, input);
        return llmProvider.chat(systemPrompt, input);
    }
}
```

### 3. 同步阻塞反模式

**问题描述**：在处理AI请求时使用同步阻塞调用，导致性能问题。

```java
// ❌ 反模式：同步阻塞
public class BlockingAgent {
    public String processMultipleQueries(List<String> queries) {
        StringBuilder results = new StringBuilder();
        for (String query : queries) {
            String result = llm.chat(query); // 阻塞调用
            results.append(result);
        }
        return results.toString();
    }
}
```

**解决方案**：使用异步模式和并发处理。

```java
// ✅ 正确做法：异步并发
@Service
public class AsyncAgent {
    @Async
    public CompletableFuture<String> processQuery(String query) {
        return CompletableFuture.supplyAsync(() -> llm.chat(query));
    }
    
    public CompletableFuture<String> processMultipleQueries(List<String> queries) {
        List<CompletableFuture<String>> futures = queries.stream()
            .map(this::processQuery)
            .collect(Collectors.toList());
            
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.joining("\n")));
    }
}
```

### 4. 无状态管理反模式

**问题描述**：忽略智能体的状态管理，导致上下文丢失。

```java
// ❌ 反模式：无状态管理
public class StatelessAgent {
    public String chat(String message) {
        // 每次都是全新的对话，没有上下文
        return llm.chat("", message);
    }
}
```

**解决方案**：实现状态管理和上下文保持。

```java
// ✅ 正确做法：状态管理
@Component
@Scope("prototype")
public class StatefulAgent {
    private final ConversationMemory memory;
    private final String sessionId;
    
    public StatefulAgent(ConversationMemory memory, String sessionId) {
        this.memory = memory;
        this.sessionId = sessionId;
    }
    
    public String chat(String message) {
        // 获取历史上下文
        List<Message> history = memory.getHistory(sessionId);
        
        // 处理消息
        String response = llm.chatWithHistory(history, message);
        
        // 更新记忆
        memory.addMessage(sessionId, new Message("user", message));
        memory.addMessage(sessionId, new Message("assistant", response));
        
        return response;
    }
}
```

## 模式组合与协作

### 1. 创建型 + 结构型 + 行为型组合

在实际的AGI应用中，多种模式往往需要协同工作：

```java
// 综合模式应用示例
@Service
public class IntegratedAgentService {
    
    // 工厂模式 + 单例模式
    @Autowired
    private AgentFactory agentFactory;
    
    // 装饰者模式 + 代理模式
    @Autowired
    private AgentEnhancerFactory enhancerFactory;
    
    // 策略模式 + 状态模式
    @Autowired
    private ProcessingStrategySelector strategySelector;
    
    // 观察者模式
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public CompletableFuture<String> processRequest(AgentRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. 创建智能体（工厂模式）
                BaseAgent agent = agentFactory.createAgent(request.getAgentType());
                
                // 2. 增强智能体（装饰者模式）
                Agent enhancedAgent = enhancerFactory.enhance(agent)
                    .withLogging()
                    .withMetrics()
                    .withCache()
                    .withFaultTolerance()
                    .build();
                
                // 3. 选择处理策略（策略模式）
                ProcessingStrategy strategy = strategySelector.select(request);
                
                // 4. 处理请求
                String result = strategy.process(enhancedAgent, request);
                
                // 5. 发布事件（观察者模式）
                eventPublisher.publishEvent(new AgentProcessCompletedEvent(request.getId(), result));
                
                return result;
                
            } catch (Exception e) {
                eventPublisher.publishEvent(new AgentProcessFailedEvent(request.getId(), e));
                throw new AgentProcessingException("Failed to process request", e);
            }
        });
    }
}
```

## 性能与可维护性平衡

### 1. 性能优化模式

```java
// 缓存装饰者模式
public class CachedAgentDecorator implements Agent {
    private final Agent delegate;
    private final Cache<String, String> cache;
    
    @Override
    public String process(String input) {
        String cacheKey = generateCacheKey(input);
        return cache.get(cacheKey, () -> delegate.process(input));
    }
}

// 批处理模式
public class BatchProcessingAgent {
    private final Queue<ProcessingTask> taskQueue = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    @PostConstruct
    public void startBatchProcessing() {
        scheduler.scheduleAtFixedRate(this::processBatch, 0, 1, TimeUnit.SECONDS);
    }
    
    public CompletableFuture<String> submitTask(String input) {
        CompletableFuture<String> future = new CompletableFuture<>();
        taskQueue.offer(new ProcessingTask(input, future));
        return future;
    }
    
    private void processBatch() {
        List<ProcessingTask> batch = new ArrayList<>();
        ProcessingTask task;
        while ((task = taskQueue.poll()) != null && batch.size() < 10) {
            batch.add(task);
        }
        
        if (!batch.isEmpty()) {
            processBatchInternal(batch);
        }
    }
}
```

### 2. 可维护性模式

```java
// 配置驱动的模式选择
@Component
public class ConfigurablePatternSelector {
    
    @Value("${agent.processing.pattern:default}")
    private String processingPattern;
    
    @Value("${agent.caching.enabled:true}")
    private boolean cachingEnabled;
    
    @Value("${agent.metrics.enabled:true}")
    private boolean metricsEnabled;
    
    public Agent createAgent(AgentType type) {
        Agent agent = baseAgentFactory.create(type);
        
        // 根据配置应用装饰者
        if (cachingEnabled) {
            agent = new CachedAgentDecorator(agent);
        }
        
        if (metricsEnabled) {
            agent = new MetricsAgentDecorator(agent);
        }
        
        // 根据配置选择处理模式
        switch (processingPattern) {
            case "batch":
                agent = new BatchProcessingAgentWrapper(agent);
                break;
            case "streaming":
                agent = new StreamingAgentWrapper(agent);
                break;
            case "parallel":
                agent = new ParallelProcessingAgentWrapper(agent);
                break;
        }
        
        return agent;
    }
}
```

## 实际项目案例分析

### 案例1：JoyAgent-JDGenie的模式应用

通过对JoyAgent-JDGenie项目的分析，我们可以看到以下模式的成功应用：

```java
// 1. 工厂模式族的应用
public class AgentEcosystem {
    // 简单工厂：AgentHandlerFactory
    // 工厂方法：不同Agent的创建
    // 抽象工厂：LLM提供商适配
    // 建造者模式：AgentContext构建
}

// 2. 结构型模式的应用
public class AgentArchitecture {
    // 装饰者模式：SSEPrinter功能增强
    // 适配器模式：多LLM提供商统一接口
    // 外观模式：GenieController简化复杂调用
    // 组合模式：ToolCollection工具管理
}

// 3. 行为型模式的应用
public class AgentBehavior {
    // 模板方法：BaseAgent执行流程
    // 策略模式：不同Agent类型的处理策略
    // 状态模式：Agent状态管理
    // 观察者模式：SSE事件通知
    // 命令模式：工具调用封装
}
```

## 小结与建议

### 核心原则

1. **问题导向**：根据具体问题选择合适的模式，避免为了使用模式而使用模式
2. **渐进式应用**：从简单模式开始，随着系统复杂度增加逐步引入更多模式
3. **性能考虑**：在应用模式时要考虑性能影响，特别是在AI应用的高并发场景
4. **可测试性**：选择的模式应该有利于单元测试和集成测试
5. **团队理解**：确保团队成员都能理解和维护所使用的模式

### 最佳实践总结

1. **创建型模式**：用于管理AI组件的复杂创建逻辑
2. **结构型模式**：用于构建灵活的AI系统架构
3. **行为型模式**：用于实现智能的决策和协作流程
4. **模式组合**：在实际项目中合理组合多种模式
5. **反模式避免**：识别并避免常见的设计陷阱

### 与前面章节的呼应

设计模式作为第二部分"AGI应用的开发基础"的重要组成部分，与前面的章节紧密相关：

- **流式通信**：装饰者模式增强流式处理能力，观察者模式实现事件驱动
- **异步并发编程**：策略模式选择并发策略，工厂模式创建异步组件
- **状态机**：状态模式管理智能体状态，模板方法定义状态转换流程

设计模式为AGI应用开发提供了强大的工具箱，合理使用这些模式能够显著提高系统的质量和可维护性。在实际开发中，我们需要根据具体场景灵活选择和组合模式，避免过度设计，追求简单而有效的解决方案。

在接下来的第三部分中，我们将探讨AGI应用的开发思想与设计哲学，这些设计模式将作为重要的实现手段，支撑更高层次的架构设计理念。