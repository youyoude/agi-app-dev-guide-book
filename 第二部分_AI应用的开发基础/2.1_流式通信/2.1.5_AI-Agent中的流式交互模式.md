# 2.1.5 AI-Agent中的流式交互模式

**学习目标：** 理解AI Agent场景下的特殊流式交互需求，掌握智能化的流式通信模式

## Agent执行状态的流式反馈

### Agent生命周期与状态流

AI Agent的执行过程通常包含多个阶段，每个阶段都需要向用户提供实时反馈：

```java
public enum AgentState {
    INITIALIZING("初始化中", "正在准备执行环境..."),
    PLANNING("制定计划", "正在分析任务并制定执行计划..."),
    TOOL_CALLING("调用工具", "正在使用工具执行具体任务..."),
    THINKING("思考中", "正在分析中间结果..."),
    SUMMARIZING("总结中", "正在整理和总结执行结果..."),
    COMPLETED("已完成", "任务执行完成"),
    ERROR("执行错误", "执行过程中遇到错误");

    private final String displayName;
    private final String description;

    AgentState(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }
}

@Component
public class AgentStatusStreamer {
    
    public void streamAgentStatus(Printer printer, AgentState state, String detail) {
        AgentStatusMessage message = AgentStatusMessage.builder()
            .state(state.name())
            .displayName(state.getDisplayName())
            .description(state.getDescription())
            .detail(detail)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_status", message);
    }

    public void streamThinking(Printer printer, String thought) {
        ThinkingMessage message = ThinkingMessage.builder()
            .content(thought)
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("agent_thinking", message);
    }

    public void streamPlanUpdate(Printer printer, List<Plan> plans, int currentStep) {
        PlanUpdateMessage message = PlanUpdateMessage.builder()
            .plans(plans)
            .currentStep(currentStep)
            .progress(calculateProgress(plans, currentStep))
            .timestamp(System.currentTimeMillis())
            .build();
            
        printer.send("plan_update", message);
    }

    private double calculateProgress(List<Plan> plans, int currentStep) {
        if (plans == null || plans.isEmpty()) {
            return 0.0;
        }
        return Math.min(100.0, (double) currentStep / plans.size() * 100);
    }
}
```

### 分层状态反馈机制

```java
public abstract class BaseAgent {
    protected Printer printer;
    protected AgentStatusStreamer statusStreamer;
    
    protected void executeWithStatusFeedback(String operation, Runnable task) {
        try {
            // 开始执行反馈
            statusStreamer.streamAgentStatus(printer, 
                AgentState.TOOL_CALLING, "开始执行: " + operation);
            
            // 执行实际任务
            task.run();
            
            // 完成反馈
            statusStreamer.streamAgentStatus(printer, 
                AgentState.COMPLETED, "完成: " + operation);
                
        } catch (Exception e) {
            // 错误反馈
            statusStreamer.streamAgentStatus(printer, 
                AgentState.ERROR, "执行失败: " + operation + " - " + e.getMessage());
            throw e;
        }
    }

    protected <T> T executeWithProgressFeedback(String operation, 
                                               Supplier<T> task, 
                                               ProgressCallback callback) {
        statusStreamer.streamAgentStatus(printer, AgentState.TOOL_CALLING, operation);
        
        return task.get(); // 实际执行中会结合callback提供进度更新
    }
}

@Component
public class PlanningAgent extends BaseAgent {
    
    @Override
    public void handle(AgentContext context, AgentRequest request) {
        printer = context.getPrinter();
        statusStreamer = new AgentStatusStreamer();
        
        try {
            // 阶段1：初始化
            statusStreamer.streamAgentStatus(printer, AgentState.INITIALIZING, 
                "准备分析任务: " + request.getQuery());
            
            // 阶段2：制定计划
            statusStreamer.streamAgentStatus(printer, AgentState.PLANNING, 
                "正在制定执行计划...");
            
            List<Plan> plans = executeWithProgressFeedback("生成执行计划", 
                () -> generatePlan(request), 
                (progress, detail) -> {
                    // 进度回调
                    printer.send("plan_progress", Map.of(
                        "progress", progress,
                        "detail", detail
                    ));
                });
            
            // 流式发送完整计划
            statusStreamer.streamPlanUpdate(printer, plans, 0);
            
            // 阶段3：执行计划
            executePlansWithStreaming(context, plans);
            
        } catch (Exception e) {
            statusStreamer.streamAgentStatus(printer, AgentState.ERROR, e.getMessage());
            throw e;
        }
    }

    private void executePlansWithStreaming(AgentContext context, List<Plan> plans) {
        for (int i = 0; i < plans.size(); i++) {
            Plan plan = plans.get(i);
            
            // 更新当前执行计划
            statusStreamer.streamPlanUpdate(printer, plans, i + 1);
            
            // 执行单个计划步骤
            executeWithStatusFeedback("执行步骤: " + plan.getAction(), () -> {
                executePlan(context, plan);
                plan.setStatus(PlanStatus.COMPLETED);
            });
            
            // 发送步骤完成的流式反馈
            printer.send("plan_step_completed", Map.of(
                "stepIndex", i,
                "plan", plan,
                "progress", (i + 1.0) / plans.size() * 100
            ));
        }
    }
}
```

## 工具调用结果的增量传输

### 工具执行的流式包装

```java
public abstract class BaseTool {
    protected AgentContext agentContext;

    /**
     * 流式执行工具，支持增量结果传输
     */
    protected <T> T executeStreamingly(String toolName, 
                                     Supplier<T> execution, 
                                     Function<T, Stream<Object>> resultStreamer) {
        Printer printer = agentContext.getPrinter();
        String requestId = agentContext.getRequestId();
        
        // 开始执行通知
        printer.send("tool_start", Map.of(
            "toolName", toolName,
            "requestId", requestId,
            "timestamp", System.currentTimeMillis()
        ));
        
        try {
            T result = execution.get();
            
            // 流式传输结果
            if (resultStreamer != null) {
                resultStreamer.apply(result).forEach(chunk -> {
                    printer.send("tool_stream", Map.of(
                        "toolName", toolName,
                        "chunk", chunk,
                        "requestId", requestId
                    ));
                });
            }
            
            // 完成通知
            printer.send("tool_complete", Map.of(
                "toolName", toolName,
                "result", result,
                "requestId", requestId
            ));
            
            return result;
            
        } catch (Exception e) {
            // 错误通知
            printer.send("tool_error", Map.of(
                "toolName", toolName,
                "error", e.getMessage(),
                "requestId", requestId
            ));
            throw e;
        }
    }
}

@Component
public class DeepSearchTool extends BaseTool {
    
    @Override
    public String call(String query) {
        return executeStreamingly("深度搜索", 
            () -> performDeepSearch(query),
            result -> streamSearchResults(result));
    }

    private DeepSearchResult performDeepSearch(String query) {
        Printer printer = agentContext.getPrinter();
        
        // 第一步：查询理解
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "description", "理解搜索意图",
            "status", "in_progress"
        ));
        
        QueryIntent intent = analyzeQuery(query);
        
        printer.send("search_step", Map.of(
            "step", "query_understanding",
            "result", intent,
            "status", "completed"
        ));
        
        // 第二步：多源搜索
        printer.send("search_step", Map.of(
            "step", "multi_source_search",
            "description", "执行多源搜索",
            "status", "in_progress"
        ));
        
        List<SearchSource> sources = getSearchSources();
        List<SearchResult> allResults = new ArrayList<>();
        
        for (int i = 0; i < sources.size(); i++) {
            SearchSource source = sources.get(i);
            
            printer.send("search_progress", Map.of(
                "source", source.getName(),
                "progress", (i + 1.0) / sources.size() * 100,
                "status", "searching"
            ));
            
            try {
                List<SearchResult> sourceResults = searchFromSource(source, query);
                allResults.addAll(sourceResults);
                
                // 流式发送中间结果
                printer.send("search_intermediate", Map.of(
                    "source", source.getName(),
                    "results", sourceResults,
                    "count", sourceResults.size()
                ));
                
            } catch (Exception e) {
                printer.send("search_error", Map.of(
                    "source", source.getName(),
                    "error", e.getMessage()
                ));
            }
        }
        
        // 第三步：结果整合
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "description", "整合搜索结果",
            "status", "in_progress",
            "totalResults", allResults.size()
        ));
        
        DeepSearchResult finalResult = integrateResults(allResults, intent);
        
        printer.send("search_step", Map.of(
            "step", "result_integration",
            "status", "completed",
            "finalResultCount", finalResult.getItems().size()
        ));
        
        return finalResult;
    }

    private Stream<Object> streamSearchResults(DeepSearchResult result) {
        return result.getItems().stream().map(item -> Map.of(
            "type", "search_item",
            "title", item.getTitle(),
            "content", item.getContent(),
            "source", item.getSource(),
            "relevance", item.getRelevance()
        ));
    }
}
```

### 代码解释器的流式输出

```java
@Component
public class CodeInterpreterTool extends BaseTool {
    
    @Override
    public CodeInterpreterResponse call(CodeInterpreterRequest request) {
        return executeStreamingly("代码解释器",
            () -> executeCode(request),
            result -> streamCodeExecution(result));
    }

    private CodeInterpreterResult executeCode(CodeInterpreterRequest request) {
        Printer printer = agentContext.getPrinter();
        String code = request.getCode();
        String language = request.getLanguage();
        
        // 代码分析阶段
        printer.send("code_analysis", Map.of(
            "phase", "analyzing",
            "language", language,
            "codeLength", code.length()
        ));
        
        CodeAnalysis analysis = analyzeCode(code, language);
        
        printer.send("code_analysis", Map.of(
            "phase", "completed",
            "analysis", analysis,
            "estimatedExecutionTime", analysis.getEstimatedTime()
        ));
        
        // 执行环境准备
        printer.send("execution_env", Map.of(
            "phase", "preparing",
            "environment", language
        ));
        
        ExecutionEnvironment env = prepareEnvironment(language);
        
        printer.send("execution_env", Map.of(
            "phase", "ready",
            "environmentId", env.getId()
        ));
        
        // 代码执行 - 实时输出
        printer.send("code_execution", Map.of(
            "phase", "running",
            "startTime", System.currentTimeMillis()
        ));
        
        CodeExecutionResult result = executeCodeWithStreaming(env, code, printer);
        
        return CodeInterpreterResult.builder()
            .analysis(analysis)
            .executionResult(result)
            .environment(env)
            .build();
    }

    private CodeExecutionResult executeCodeWithStreaming(ExecutionEnvironment env, 
                                                        String code, 
                                                        Printer printer) {
        StringBuilder stdout = new StringBuilder();
        StringBuilder stderr = new StringBuilder();
        
        // 创建流式输出处理器
        ProcessBuilder pb = new ProcessBuilder(env.getCommand(), code);
        pb.redirectErrorStream(false);
        
        try {
            Process process = pb.start();
            
            // 异步读取标准输出
            Thread stdoutReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stdout.append(line).append("\n");
                        
                        // 实时流式输出
                        printer.send("code_stdout", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis()
                        ));
                    }
                } catch (IOException e) {
                    log.error("读取标准输出失败", e);
                }
            });
            
            // 异步读取错误输出
            Thread stderrReader = new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getErrorStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        stderr.append(line).append("\n");
                        
                        // 实时流式错误输出
                        printer.send("code_stderr", Map.of(
                            "line", line,
                            "timestamp", System.currentTimeMillis(),
                            "level", "error"
                        ));
                    }
                } catch (IOException e) {
                    log.error("读取错误输出失败", e);
                }
            });
            
            stdoutReader.start();
            stderrReader.start();
            
            // 等待执行完成
            int exitCode = process.waitFor();
            
            stdoutReader.join();
            stderrReader.join();
            
            // 发送执行完成通知
            printer.send("code_execution", Map.of(
                "phase", "completed",
                "exitCode", exitCode,
                "endTime", System.currentTimeMillis()
            ));
            
            return CodeExecutionResult.builder()
                .exitCode(exitCode)
                .stdout(stdout.toString())
                .stderr(stderr.toString())
                .executionTime(System.currentTimeMillis())
                .build();
                
        } catch (Exception e) {
            printer.send("code_execution", Map.of(
                "phase", "error",
                "error", e.getMessage()
            ));
            throw new RuntimeException("代码执行失败", e);
        }
    }

    private Stream<Object> streamCodeExecution(CodeInterpreterResult result) {
        List<Object> streamItems = new ArrayList<>();
        
        // 分析结果
        streamItems.add(Map.of(
            "type", "analysis",
            "data", result.getAnalysis()
        ));
        
        // 执行结果
        streamItems.add(Map.of(
            "type", "execution_result",
            "data", result.getExecutionResult()
        ));
        
        // 如果有生成的文件，逐个流式传输
        if (result.getGeneratedFiles() != null) {
            result.getGeneratedFiles().forEach(file -> {
                streamItems.add(Map.of(
                    "type", "generated_file",
                    "data", file
                ));
            });
        }
        
        return streamItems.stream();
    }
}
```

## 多Agent协作的流式消息传递

### Agent间通信架构

```java
@Component
public class AgentCommunicationBus {
    private final Map<String, Agent> activeAgents = new ConcurrentHashMap<>();
    private final Map<String, List<AgentMessageListener>> listeners = new ConcurrentHashMap<>();
    private final ExecutorService messageDispatcher = Executors.newFixedThreadPool(5);

    /**
     * 注册Agent到通信总线
     */
    public void registerAgent(String agentId, Agent agent) {
        activeAgents.put(agentId, agent);
        
        // 发送Agent注册通知
        broadcastMessage(AgentMessage.builder()
            .fromAgent("system")
            .toAgent("all")
            .messageType("agent_registered")
            .data(Map.of("agentId", agentId, "agentType", agent.getType()))
            .build());
    }

    /**
     * 发送Agent间消息
     */
    public void sendMessage(AgentMessage message) {
        messageDispatcher.submit(() -> {
            try {
                // 记录消息日志
                logMessage(message);
                
                // 流式通知用户
                notifyUserOfAgentCommunication(message);
                
                if ("all".equals(message.getToAgent())) {
                    // 广播消息
                    activeAgents.forEach((agentId, agent) -> {
                        if (!agentId.equals(message.getFromAgent())) {
                            deliverMessage(agent, message);
                        }
                    });
                } else {
                    // 点对点消息
                    Agent targetAgent = activeAgents.get(message.getToAgent());
                    if (targetAgent != null) {
                        deliverMessage(targetAgent, message);
                    }
                }
                
                // 通知监听器
                notifyListeners(message);
                
            } catch (Exception e) {
                log.error("消息发送失败", e);
            }
        });
    }

    private void notifyUserOfAgentCommunication(AgentMessage message) {
        // 获取相关的Printer（通过请求ID关联）
        Printer printer = getPrinterForMessage(message);
        if (printer != null) {
            printer.send("agent_communication", Map.of(
                "fromAgent", message.getFromAgent(),
                "toAgent", message.getToAgent(),
                "messageType", message.getMessageType(),
                "summary", summarizeMessage(message),
                "timestamp", message.getTimestamp()
            ));
        }
    }

    private void deliverMessage(Agent agent, AgentMessage message) {
        try {
            agent.receiveMessage(message);
        } catch (Exception e) {
            log.error("消息投递失败: {} -> {}", message.getFromAgent(), 
                     agent.getId(), e);
        }
    }

    /**
     * 广播消息给所有Agent
     */
    public void broadcastMessage(AgentMessage message) {
        message.setToAgent("all");
        sendMessage(message);
    }

    /**
     * 添加消息监听器
     */
    public void addMessageListener(String messageType, AgentMessageListener listener) {
        listeners.computeIfAbsent(messageType, k -> new ArrayList<>()).add(listener);
    }

    private void notifyListeners(AgentMessage message) {
        List<AgentMessageListener> typeListeners = listeners.get(message.getMessageType());
        if (typeListeners != null) {
            typeListeners.forEach(listener -> {
                try {
                    listener.onMessage(message);
                } catch (Exception e) {
                    log.error("消息监听器执行失败", e);
                }
            });
        }
    }
}

@Data
@Builder
public class AgentMessage {
    private String messageId;
    private String fromAgent;
    private String toAgent;
    private String messageType;
    private Object data;
    private long timestamp;
    private String requestId; // 关联用户请求
}
```

### 协作流程的可视化流式传输

```java
@Component
public class CollaborationVisualizer {
    
    public void visualizeCollaboration(String requestId, List<Agent> agents, Printer printer) {
        // 初始化协作图
        CollaborationGraph graph = new CollaborationGraph();
        agents.forEach(agent -> graph.addNode(agent.getId(), agent.getType()));
        
        printer.send("collaboration_init", Map.of(
            "graph", graph,
            "agents", agents.stream().map(this::serializeAgent).collect(Collectors.toList())
        ));
        
        // 监听Agent间通信
        AgentCommunicationBus bus = getAgentCommunicationBus();
        bus.addMessageListener("all", message -> {
            if (requestId.equals(message.getRequestId())) {
                // 更新协作图
                graph.addEdge(message.getFromAgent(), message.getToAgent(), message.getMessageType());
                
                // 流式发送协作更新
                printer.send("collaboration_update", Map.of(
                    "edge", Map.of(
                        "from", message.getFromAgent(),
                        "to", message.getToAgent(),
                        "type", message.getMessageType(),
                        "timestamp", message.getTimestamp()
                    ),
                    "graph", graph.getSnapshot()
                ));
            }
        });
    }

    private Map<String, Object> serializeAgent(Agent agent) {
        return Map.of(
            "id", agent.getId(),
            "type", agent.getType(),
            "status", agent.getStatus(),
            "capabilities", agent.getCapabilities()
        );
    }
}

@Component 
public class MultiAgentOrchestrator {
    private final AgentCommunicationBus communicationBus;
    private final CollaborationVisualizer visualizer;

    public void executeCollaborativeTask(AgentContext context, CollaborativeTask task) {
        String requestId = context.getRequestId();
        Printer printer = context.getPrinter();
        
        // 初始化协作环境
        printer.send("collaboration_start", Map.of(
            "taskId", task.getId(),
            "description", task.getDescription(),
            "requiredAgents", task.getRequiredAgentTypes()
        ));
        
        // 创建并注册所需的Agent
        List<Agent> agents = createRequiredAgents(task, context);
        agents.forEach(agent -> communicationBus.registerAgent(agent.getId(), agent));
        
        // 启动协作可视化
        visualizer.visualizeCollaboration(requestId, agents, printer);
        
        // 分配任务给各个Agent
        distributeTasksWithStreaming(task, agents, printer);
        
        // 监控协作进度
        monitorCollaborationProgress(requestId, agents, printer);
    }

    private void distributeTasksWithStreaming(CollaborativeTask task, 
                                           List<Agent> agents, 
                                           Printer printer) {
        List<SubTask> subTasks = task.decomposeToSubTasks();
        
        for (int i = 0; i < subTasks.size(); i++) {
            SubTask subTask = subTasks.get(i);
            Agent assignedAgent = findBestAgent(subTask, agents);
            
            // 流式发送任务分配信息
            printer.send("task_assignment", Map.of(
                "subTaskId", subTask.getId(),
                "description", subTask.getDescription(),
                "assignedAgent", assignedAgent.getId(),
                "priority", subTask.getPriority(),
                "dependencies", subTask.getDependencies()
            ));
            
            // 发送任务给Agent
            AgentMessage taskMessage = AgentMessage.builder()
                .messageId(UUID.randomUUID().toString())
                .fromAgent("orchestrator")
                .toAgent(assignedAgent.getId())
                .messageType("task_assignment")
                .data(subTask)
                .timestamp(System.currentTimeMillis())
                .requestId(task.getRequestId())
                .build();
                
            communicationBus.sendMessage(taskMessage);
        }
    }

    private void monitorCollaborationProgress(String requestId, 
                                           List<Agent> agents, 
                                           Printer printer) {
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        
        monitor.scheduleAtFixedRate(() -> {
            // 收集各Agent状态
            Map<String, AgentStatus> agentStatuses = agents.stream()
                .collect(Collectors.toMap(Agent::getId, Agent::getStatus));
            
            // 计算整体进度
            double overallProgress = calculateOverallProgress(agentStatuses);
            
            // 流式发送进度更新
            printer.send("collaboration_progress", Map.of(
                "overallProgress", overallProgress,
                "agentStatuses", agentStatuses,
                "timestamp", System.currentTimeMillis()
            ));
            
            // 检查是否完成
            if (isCollaborationComplete(agentStatuses)) {
                printer.send("collaboration_complete", Map.of(
                    "completionTime", System.currentTimeMillis(),
                    "finalResults", collectFinalResults(agents)
                ));
                monitor.shutdown();
            }
            
        }, 5, 5, TimeUnit.SECONDS); // 每5秒更新一次进度
    }
}
```

## 流式Token计数与限流控制

### 实时Token消耗监控

```java
@Component
public class TokenMonitor {
    private final Map<String, TokenUsageTracker> sessionTrackers = new ConcurrentHashMap<>();
    private final TokenLimitConfig limitConfig;

    public TokenUsageTracker getOrCreateTracker(String requestId) {
        return sessionTrackers.computeIfAbsent(requestId, 
            k -> new TokenUsageTracker(k, limitConfig));
    }

    @EventListener
    public void handleTokenUsage(TokenUsageEvent event) {
        TokenUsageTracker tracker = getOrCreateTracker(event.getRequestId());
        tracker.addUsage(event.getTokens(), event.getModel());
        
        // 流式发送Token使用情况
        if (event.getPrinter() != null) {
            event.getPrinter().send("token_usage", Map.of(
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit(),
                "percentage", tracker.getUsagePercentage(),
                "model", event.getModel(),
                "timestamp", System.currentTimeMillis()
            ));
        }
        
        // 检查是否接近限制
        if (tracker.isNearLimit(0.9)) { // 90%
            event.getPrinter().send("token_warning", Map.of(
                "message", "Token使用量已达到90%",
                "currentUsage", tracker.getCurrentUsage(),
                "limit", tracker.getLimit()
            ));
        }
        
        // 检查是否超过限制
        if (tracker.isOverLimit()) {
            throw new TokenLimitExceeded(event.getRequestId(), 
                tracker.getCurrentUsage(), tracker.getLimit());
        }
    }

    public void cleanupTracker(String requestId) {
        sessionTrackers.remove(requestId);
    }
}

public class TokenUsageTracker {
    private final String requestId;
    private final TokenLimitConfig limitConfig;
    private final Map<String, AtomicLong> modelUsage = new ConcurrentHashMap<>();
    private final AtomicLong totalUsage = new AtomicLong(0);

    public void addUsage(long tokens, String model) {
        modelUsage.computeIfAbsent(model, k -> new AtomicLong(0)).addAndGet(tokens);
        totalUsage.addAndGet(tokens);
    }

    public boolean isNearLimit(double threshold) {
        return getUsagePercentage() >= threshold * 100;
    }

    public boolean isOverLimit() {
        return totalUsage.get() > limitConfig.getMaxTokensPerSession();
    }

    public double getUsagePercentage() {
        return (double) totalUsage.get() / limitConfig.getMaxTokensPerSession() * 100;
    }

    public long getCurrentUsage() {
        return totalUsage.get();
    }

    public long getLimit() {
        return limitConfig.getMaxTokensPerSession();
    }

    public Map<String, Long> getModelUsageBreakdown() {
        return modelUsage.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> entry.getValue().get()
            ));
    }
}
```

### 动态限流策略

```java
@Component
public class AdaptiveThrottleController {
    private final TokenMonitor tokenMonitor;
    private final Map<String, ThrottleState> sessionThrottles = new ConcurrentHashMap<>();

    public void checkAndApplyThrottle(String requestId, Printer printer) {
        TokenUsageTracker tracker = tokenMonitor.getOrCreateTracker(requestId);
        ThrottleState throttle = sessionThrottles.computeIfAbsent(requestId, 
            k -> new ThrottleState());

        double usagePercentage = tracker.getUsagePercentage();
        
        if (usagePercentage > 95) {
            // 严重限流：暂停所有非关键操作
            throttle.setLevel(ThrottleLevel.SEVERE);
            printer.send("throttle_applied", Map.of(
                "level", "severe",
                "message", "Token使用量过高，暂停非关键操作",
                "estimatedDelay", "30-60秒"
            ));
            
        } else if (usagePercentage > 80) {
            // 中等限流：延长操作间隔
            throttle.setLevel(ThrottleLevel.MODERATE);
            printer.send("throttle_applied", Map.of(
                "level", "moderate", 
                "message", "适度降低处理速度以控制Token消耗",
                "slowdownFactor", 2.0
            ));
            
        } else if (usagePercentage > 60) {
            // 轻微限流：优化请求
            throttle.setLevel(ThrottleLevel.LIGHT);
            printer.send("throttle_applied", Map.of(
                "level", "light",
                "message", "开启Token优化模式",
                "optimization", "enabled"
            ));
        }

        // 应用限流延迟
        if (throttle.getLevel() != ThrottleLevel.NONE) {
            long delayMs = calculateThrottleDelay(throttle.getLevel(), usagePercentage);
            if (delayMs > 0) {
                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private long calculateThrottleDelay(ThrottleLevel level, double usagePercentage) {
        switch (level) {
            case LIGHT:
                return Math.round(500 * (usagePercentage / 100)); // 0-5秒
            case MODERATE:
                return Math.round(2000 * (usagePercentage / 100)); // 0-20秒  
            case SEVERE:
                return Math.round(10000 * (usagePercentage / 100)); // 0-100秒
            default:
                return 0;
        }
    }
}

enum ThrottleLevel {
    NONE, LIGHT, MODERATE, SEVERE
}

@Data
class ThrottleState {
    private ThrottleLevel level = ThrottleLevel.NONE;
    private long lastThrottleTime = 0;
    private int consecutiveThrottles = 0;
}
```

## Agent执行进度的可视化展示

### 进度可视化组件

```typescript
interface AgentProgress {
    agentId: string;
    agentType: string;
    currentStep: string;
    totalSteps: number;
    completedSteps: number;
    progress: number;
    status: 'idle' | 'running' | 'completed' | 'error';
    lastUpdate: number;
    estimatedTimeRemaining?: number;
}

interface CollaborationState {
    requestId: string;
    agents: AgentProgress[];
    overallProgress: number;
    activeConnections: Array<{
        from: string;
        to: string;
        type: string;
        timestamp: number;
    }>;
    timeline: Array<{
        timestamp: number;
        event: string;
        agent?: string;
        details: any;
    }>;
}

export const AgentCollaborationDashboard: React.FC<{
  requestId: string;
}> = ({ requestId }) => {
  const [collaborationState, setCollaborationState] = useState<CollaborationState | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const sseClient = new AdvancedSSEClient({
      body: { requestId, agentType: 'collaboration' },
      handleMessage: (message) => {
        handleCollaborationMessage(message);
      },
      handleError: (error) => {
        console.error('协作监控连接错误:', error);
        setIsConnected(false);
      },
      handleClose: () => {
        setIsConnected(false);
      }
    });

    sseClient.connect('/web/api/v1/agent/collaboration/stream');
    setIsConnected(true);

    return () => {
      sseClient.disconnect();
    };
  }, [requestId]);

  const handleCollaborationMessage = (message: any) => {
    switch (message.messageType) {
      case 'collaboration_init':
        setCollaborationState({
          requestId: message.requestId,
          agents: message.agents.map(formatAgentProgress),
          overallProgress: 0,
          activeConnections: [],
          timeline: []
        });
        break;

      case 'collaboration_progress':
        setCollaborationState(prev => prev ? {
          ...prev,
          agents: updateAgentProgress(prev.agents, message.agentStatuses),
          overallProgress: message.overallProgress
        } : null);
        break;

      case 'agent_communication':
        setCollaborationState(prev => prev ? {
          ...prev,
          activeConnections: [
            ...prev.activeConnections.slice(-10), // 保留最近10个连接
            {
              from: message.fromAgent,
              to: message.toAgent,
              type: message.messageType,
              timestamp: message.timestamp
            }
          ],
          timeline: [
            ...prev.timeline,
            {
              timestamp: message.timestamp,
              event: 'agent_communication',
              agent: message.fromAgent,
              details: {
                to: message.toAgent,
                type: message.messageType,
                summary: message.summary
              }
            }
          ]
        } : null);
        break;

      case 'task_assignment':
        setCollaborationState(prev => prev ? {
          ...prev,
          timeline: [
            ...prev.timeline,
            {
              timestamp: Date.now(),
              event: 'task_assignment',
              agent: message.assignedAgent,
              details: {
                taskId: message.subTaskId,
                description: message.description,
                priority: message.priority
              }
            }
          ]
        } : null);
        break;
    }
  };

  if (!collaborationState) {
    return <div className="loading">初始化协作监控...</div>;
  }

  return (
    <div className="collaboration-dashboard">
      {/* 整体进度 */}
      <div className="overall-progress">
        <h3>整体进度</h3>
        <ProgressRing 
          progress={collaborationState.overallProgress} 
          size={120}
          strokeWidth={8}
        />
        <div className="status-indicator">
          <StatusDot connected={isConnected} />
          <span>{isConnected ? '已连接' : '连接断开'}</span>
        </div>
      </div>

      {/* Agent状态网格 */}
      <div className="agents-grid">
        {collaborationState.agents.map(agent => (
          <AgentCard key={agent.agentId} agent={agent} />
        ))}
      </div>

      {/* 协作图 */}
      <div className="collaboration-graph">
        <h3>Agent协作关系</h3>
        <CollaborationNetwork 
          agents={collaborationState.agents}
          connections={collaborationState.activeConnections}
        />
      </div>

      {/* 时间线 */}
      <div className="timeline">
        <h3>执行时间线</h3>
        <Timeline events={collaborationState.timeline} />
      </div>
    </div>
  );
};

const AgentCard: React.FC<{ agent: AgentProgress }> = ({ agent }) => {
  return (
    <div className={`agent-card ${agent.status}`}>
      <div className="agent-header">
        <div className="agent-icon">{getAgentIcon(agent.agentType)}</div>
        <div className="agent-info">
          <h4>{agent.agentId}</h4>
          <span className="agent-type">{agent.agentType}</span>
        </div>
        <StatusBadge status={agent.status} />
      </div>
      
      <div className="agent-progress">
        <div className="progress-bar">
          <div 
            className="progress-fill" 
            style={{ width: `${agent.progress}%` }}
          />
        </div>
        <span className="progress-text">
          {agent.completedSteps}/{agent.totalSteps} 步骤
        </span>
      </div>
      
      <div className="current-step">
        <span>当前: {agent.currentStep}</span>
        {agent.estimatedTimeRemaining && (
          <span className="time-remaining">
            预计剩余: {formatDuration(agent.estimatedTimeRemaining)}
          </span>
        )}
      </div>
    </div>
  );
};
```

## 小结

AI-Agent中的流式交互模式具有以下特点：

1. **状态流式反馈**：Agent执行的每个阶段都需要实时反馈给用户
2. **工具调用透明化**：工具执行过程和结果需要增量传输
3. **多Agent协作可视化**：复杂的协作关系需要实时展示
4. **Token使用监控**：实时监控和控制Token消耗
5. **进度可视化**：提供直观的执行进度和状态展示

这些模式使用户能够更好地理解AI Agent的"思考"和执行过程，提供了前所未有的透明度和交互体验。在下一节中，我们将探讨如何优化流式通信的性能并建立完善的监控体系。

---

**本节关键要点：**
- Agent生命周期状态的流式反馈机制
- 工具调用结果的增量传输策略
- 多Agent协作的实时通信和可视化
- 流式Token计数和动态限流控制
- Agent执行进度的可视化展示方案
