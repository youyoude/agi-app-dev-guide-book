# 2.1.3 客户端流式数据接收处理

**学习目标：** 学会在前端实现稳定可靠的流式数据接收，掌握流式UI更新的最佳实践

## EventSource API深入应用

### 原生 EventSource API

EventSource 是浏览器原生提供的 SSE 客户端 API：

```javascript
// 基础用法
const eventSource = new EventSource('/api/stream');

eventSource.onmessage = function(event) {
    console.log('接收到数据:', event.data);
};

eventSource.onerror = function(error) {
    console.error('连接错误:', error);
};

// 监听自定义事件类型
eventSource.addEventListener('status', function(event) {
    console.log('状态更新:', event.data);
});

// 关闭连接
eventSource.close();
```

### 高级特性应用

#### 1. 连接状态管理

```javascript
class SSEConnectionManager {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.eventSource = null;
        this.connectionState = 'disconnected'; // disconnected, connecting, connected
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
        this.reconnectDelay = options.reconnectDelay || 1000;
    }

    connect() {
        if (this.connectionState === 'connected' || this.connectionState === 'connecting') {
            return;
        }

        this.connectionState = 'connecting';
        this.eventSource = new EventSource(this.url);

        this.eventSource.onopen = () => {
            console.log('SSE连接已建立');
            this.connectionState = 'connected';
            this.reconnectAttempts = 0;
            this.options.onOpen?.();
        };

        this.eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.options.onMessage?.(data);
            } catch (error) {
                console.error('数据解析失败:', error);
                this.options.onError?.(new Error('数据解析失败'));
            }
        };

        this.eventSource.onerror = (error) => {
            console.error('SSE连接错误:', error);
            this.connectionState = 'disconnected';
            this.options.onError?.(error);
            
            // 自动重连逻辑
            this.handleReconnect();
        };
    }

    handleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('达到最大重连次数，停止重连');
            this.options.onMaxReconnectReached?.();
            return;
        }

        this.reconnectAttempts++;
        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // 指数退避
        
        console.log(`${delay}ms后进行第${this.reconnectAttempts}次重连...`);
        
        setTimeout(() => {
            this.connect();
        }, delay);
    }

    disconnect() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        this.connectionState = 'disconnected';
    }

    getConnectionState() {
        return this.connectionState;
    }
}
```

## fetch-event-source库的高级用法

### 功能增强的 SSE 客户端

项目中使用了 `@microsoft/fetch-event-source` 库，它提供了更强大的功能：

```typescript
import { fetchEventSource, EventSourceMessage } from '@microsoft/fetch-event-source';

const DEFAULT_SSE_URL = `${SERVICE_BASE_URL}/web/api/v1/gpt/queryAgentStreamIncr`;

const SSE_HEADERS = {
  'Content-Type': 'application/json',
  'Cache-Control': 'no-cache',
  'Connection': 'keep-alive',
  'Accept': 'text/event-stream',
};

interface SSEConfig {
  body: any;
  handleMessage: (data: any) => void;
  handleError: (error: Error) => void;
  handleClose: () => void;
}

export default (config: SSEConfig, url: string = DEFAULT_SSE_URL): void => {
  const { body = null, handleMessage, handleError, handleClose } = config;

  fetchEventSource(url, {
    method: 'POST',
    credentials: 'include',
    headers: SSE_HEADERS,
    body: JSON.stringify(body),
    openWhenHidden: true, // 页面隐藏时保持连接
    
    onmessage(event: EventSourceMessage) {
      if (event.data) {
        try {
          const parsedData = JSON.parse(event.data);
          handleMessage(parsedData);
        } catch (error) {
          console.error('解析SSE消息失败:', error);
          handleError(new Error('消息解析失败'));
        }
      }
    },
    
    onerror(error: Error) {
      console.error('SSE错误:', error);
      handleError(error);
    },
    
    onclose() {
      console.log('SSE连接关闭');
      handleClose();
    },

    // 自定义重试逻辑
    onopen(response) {
      if (response.ok && response.headers.get('content-type')?.includes('text/event-stream')) {
        return; // 连接成功
      } else {
        throw new Error(`连接失败: ${response.status} ${response.statusText}`);
      }
    },
  });
};
```

### 高级配置选项

```typescript
interface AdvancedSSEConfig extends SSEConfig {
  // 重连策略配置
  retryConfig?: {
    maxRetries: number;
    retryDelay: number;
    retryDelayMultiplier: number;
    maxRetryDelay: number;
  };
  
  // 性能优化配置
  performanceConfig?: {
    bufferSize: number;
    throttleMs: number;
    debounceMs: number;
  };
  
  // 监控配置
  monitoringConfig?: {
    enableMetrics: boolean;
    metricsCallback: (metrics: SSEMetrics) => void;
  };
}

class AdvancedSSEClient {
  private config: AdvancedSSEConfig;
  private abortController: AbortController;
  private metrics: SSEMetrics;
  private messageBuffer: any[];
  private throttleTimer: NodeJS.Timeout | null = null;

  constructor(config: AdvancedSSEConfig) {
    this.config = config;
    this.abortController = new AbortController();
    this.metrics = {
      messagesReceived: 0,
      bytesReceived: 0,
      errors: 0,
      connectionTime: 0,
      lastMessageTime: 0
    };
    this.messageBuffer = [];
  }

  async connect(url: string): Promise<void> {
    const startTime = Date.now();
    
    await fetchEventSource(url, {
      method: 'POST',
      headers: this.config.headers,
      body: JSON.stringify(this.config.body),
      signal: this.abortController.signal,
      
      onopen: (response) => {
        this.metrics.connectionTime = Date.now() - startTime;
        console.log(`SSE连接建立，耗时: ${this.metrics.connectionTime}ms`);
      },
      
      onmessage: (event) => {
        this.metrics.messagesReceived++;
        this.metrics.bytesReceived += event.data.length;
        this.metrics.lastMessageTime = Date.now();
        
        // 缓冲和节流处理
        this.handleMessage(event);
        
        // 发送监控数据
        if (this.config.monitoringConfig?.enableMetrics) {
          this.config.monitoringConfig.metricsCallback(this.metrics);
        }
      },
      
      onerror: (error) => {
        this.metrics.errors++;
        this.config.handleError(error);
      }
    });
  }

  private handleMessage(event: EventSourceMessage) {
    try {
      const data = JSON.parse(event.data);
      
      // 配置了缓冲区大小
      if (this.config.performanceConfig?.bufferSize) {
        this.messageBuffer.push(data);
        
        if (this.messageBuffer.length >= this.config.performanceConfig.bufferSize) {
          this.flushBuffer();
        }
      } else {
        // 节流处理
        this.throttledHandleMessage(data);
      }
    } catch (error) {
      console.error('消息处理失败:', error);
    }
  }

  private throttledHandleMessage(data: any) {
    if (this.throttleTimer) {
      return;
    }

    const throttleMs = this.config.performanceConfig?.throttleMs || 0;
    
    if (throttleMs > 0) {
      this.throttleTimer = setTimeout(() => {
        this.config.handleMessage(data);
        this.throttleTimer = null;
      }, throttleMs);
    } else {
      this.config.handleMessage(data);
    }
  }

  private flushBuffer() {
    if (this.messageBuffer.length > 0) {
      this.config.handleMessage(this.messageBuffer);
      this.messageBuffer = [];
    }
  }

  disconnect() {
    this.abortController.abort();
    this.flushBuffer(); // 确保缓冲区数据被处理
  }

  getMetrics(): SSEMetrics {
    return { ...this.metrics };
  }
}
```

## 流式数据解析与状态管理

### 消息类型分类处理

```typescript
interface StreamMessage {
  type: string;
  data: any;
  requestId: string;
  timestamp: number;
  messageId?: string;
  finished?: boolean;
}

class MessageProcessor {
  private handlers: Map<string, MessageHandler> = new Map();
  private stateManager: StateManager;

  constructor(stateManager: StateManager) {
    this.stateManager = stateManager;
    this.initializeHandlers();
  }

  private initializeHandlers() {
    // 计划执行消息处理
    this.handlers.set('plan', (message: StreamMessage) => {
      this.stateManager.updatePlans(message.data);
    });

    // 流式内容消息处理
    this.handlers.set('agent_stream', (message: StreamMessage) => {
      this.stateManager.appendStreamContent(message.data);
    });

    // 最终结果消息处理
    this.handlers.set('result', (message: StreamMessage) => {
      this.stateManager.setFinalResult(message.data);
      if (message.finished) {
        this.stateManager.markCompleted();
      }
    });

    // 错误消息处理
    this.handlers.set('error', (message: StreamMessage) => {
      this.stateManager.setError(message.data);
    });

    // 心跳消息处理
    this.handlers.set('heartbeat', (message: StreamMessage) => {
      this.stateManager.updateLastHeartbeat();
    });
  }

  processMessage(rawMessage: any) {
    try {
      const message: StreamMessage = this.parseMessage(rawMessage);
      const handler = this.handlers.get(message.type);
      
      if (handler) {
        handler(message);
      } else {
        console.warn(`未知消息类型: ${message.type}`);
      }
    } catch (error) {
      console.error('消息处理失败:', error);
      this.stateManager.setError(error.message);
    }
  }

  private parseMessage(rawMessage: any): StreamMessage {
    // 统一的消息格式转换逻辑
    if (typeof rawMessage === 'string') {
      return JSON.parse(rawMessage);
    }
    
    // 适配不同的消息格式
    return {
      type: rawMessage.messageType || rawMessage.type || 'unknown',
      data: rawMessage.result || rawMessage.data,
      requestId: rawMessage.requestId || rawMessage.id,
      timestamp: Date.now(),
      messageId: rawMessage.messageId,
      finished: rawMessage.finished || false
    };
  }
}
```

### 状态管理器设计

```typescript
interface TaskState {
  requestId: string;
  status: 'pending' | 'running' | 'completed' | 'error';
  plans: Plan[];
  streamContent: string;
  finalResult: any;
  error: string | null;
  progress: number;
  lastHeartbeat: number;
  metadata: Record<string, any>;
}

class StateManager {
  private state: TaskState;
  private listeners: Set<StateListener> = new Set();
  private updateQueue: Array<() => void> = [];
  private isUpdating = false;

  constructor(requestId: string) {
    this.state = {
      requestId,
      status: 'pending',
      plans: [],
      streamContent: '',
      finalResult: null,
      error: null,
      progress: 0,
      lastHeartbeat: Date.now(),
      metadata: {}
    };
  }

  // 批量更新机制
  private batchUpdate(updateFn: () => void) {
    this.updateQueue.push(updateFn);
    
    if (!this.isUpdating) {
      this.isUpdating = true;
      
      // 使用 requestAnimationFrame 确保UI更新的性能
      requestAnimationFrame(() => {
        this.updateQueue.forEach(fn => fn());
        this.updateQueue = [];
        this.isUpdating = false;
        
        // 通知所有监听器
        this.notifyListeners();
      });
    }
  }

  updatePlans(plans: Plan[]) {
    this.batchUpdate(() => {
      this.state.plans = plans;
      this.state.status = 'running';
      this.updateProgress();
    });
  }

  appendStreamContent(content: string) {
    this.batchUpdate(() => {
      this.state.streamContent += content;
      this.updateProgress();
    });
  }

  setFinalResult(result: any) {
    this.batchUpdate(() => {
      this.state.finalResult = result;
      this.state.progress = 100;
    });
  }

  markCompleted() {
    this.batchUpdate(() => {
      this.state.status = 'completed';
      this.state.progress = 100;
    });
  }

  setError(error: string) {
    this.batchUpdate(() => {
      this.state.error = error;
      this.state.status = 'error';
    });
  }

  updateLastHeartbeat() {
    // 心跳更新不需要通知UI，避免频繁重渲染
    this.state.lastHeartbeat = Date.now();
  }

  private updateProgress() {
    // 根据计划完成情况和内容长度估算进度
    const planProgress = this.state.plans.length > 0 
      ? (this.state.plans.filter(p => p.status === 'completed').length / this.state.plans.length) * 50 
      : 0;
    
    const contentProgress = Math.min(this.state.streamContent.length / 1000 * 25, 25);
    
    this.state.progress = Math.min(planProgress + contentProgress, 95); // 保留5%给最终结果
  }

  // 订阅状态变化
  subscribe(listener: StateListener): () => void {
    this.listeners.add(listener);
    
    // 返回取消订阅函数
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notifyListeners() {
    this.listeners.forEach(listener => {
      try {
        listener(this.state);
      } catch (error) {
        console.error('状态监听器执行失败:', error);
      }
    });
  }

  getState(): Readonly<TaskState> {
    return { ...this.state };
  }

  // 检查连接健康状态
  isHealthy(): boolean {
    const now = Date.now();
    const heartbeatThreshold = 30000; // 30秒无心跳认为不健康
    return now - this.state.lastHeartbeat < heartbeatThreshold;
  }
}

type StateListener = (state: TaskState) => void;
```

## React中的流式UI更新策略

### 基于 Hooks 的集成

```tsx
import React, { useState, useEffect, useCallback, useRef } from 'react';

interface UseStreamingOptions {
  url: string;
  requestBody: any;
  onComplete?: (result: any) => void;
  onError?: (error: Error) => void;
}

export const useStreaming = ({ url, requestBody, onComplete, onError }: UseStreamingOptions) => {
  const [state, setState] = useState<TaskState | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const stateManagerRef = useRef<StateManager | null>(null);
  const sseClientRef = useRef<AdvancedSSEClient | null>(null);

  const startStreaming = useCallback(async () => {
    if (stateManagerRef.current) {
      // 清理之前的连接
      sseClientRef.current?.disconnect();
    }

    // 创建新的状态管理器
    const requestId = generateRequestId();
    const stateManager = new StateManager(requestId);
    stateManagerRef.current = stateManager;

    // 订阅状态变化
    const unsubscribe = stateManager.subscribe((newState) => {
      setState(newState);
      
      if (newState.status === 'completed' && onComplete) {
        onComplete(newState.finalResult);
      }
      
      if (newState.status === 'error' && onError) {
        onError(new Error(newState.error || 'Unknown error'));
      }
    });

    // 创建消息处理器
    const messageProcessor = new MessageProcessor(stateManager);

    // 创建SSE客户端
    const sseClient = new AdvancedSSEClient({
      body: { ...requestBody, requestId },
      handleMessage: (data) => {
        messageProcessor.processMessage(data);
      },
      handleError: (error) => {
        stateManager.setError(error.message);
        setIsConnected(false);
      },
      handleClose: () => {
        setIsConnected(false);
      },
      retryConfig: {
        maxRetries: 3,
        retryDelay: 1000,
        retryDelayMultiplier: 2,
        maxRetryDelay: 10000
      }
    });

    sseClientRef.current = sseClient;
    setIsConnected(true);

    try {
      await sseClient.connect(url);
    } catch (error) {
      console.error('连接失败:', error);
      setIsConnected(false);
      stateManager.setError(error.message);
    }

    // 返回清理函数
    return () => {
      unsubscribe();
      sseClient.disconnect();
    };
  }, [url, requestBody, onComplete, onError]);

  const stopStreaming = useCallback(() => {
    sseClientRef.current?.disconnect();
    setIsConnected(false);
  }, []);

  // 组件卸载时清理
  useEffect(() => {
    return () => {
      sseClientRef.current?.disconnect();
    };
  }, []);

  return {
    state,
    isConnected,
    startStreaming,
    stopStreaming,
    metrics: sseClientRef.current?.getMetrics()
  };
};
```

### 流式UI组件实现

```tsx
import React, { useState, useEffect } from 'react';
import { useStreaming } from './useStreaming';

interface StreamingChatProps {
  query: string;
  onComplete?: (result: any) => void;
}

export const StreamingChat: React.FC<StreamingChatProps> = ({ query, onComplete }) => {
  const { state, isConnected, startStreaming, stopStreaming } = useStreaming({
    url: '/web/api/v1/gpt/queryAgentStreamIncr',
    requestBody: { query, agentType: 'react' },
    onComplete
  });

  useEffect(() => {
    if (query) {
      startStreaming();
    }
    
    return () => {
      stopStreaming();
    };
  }, [query, startStreaming, stopStreaming]);

  if (!state) {
    return <div className="loading">准备连接...</div>;
  }

  return (
    <div className="streaming-chat">
      {/* 连接状态指示器 */}
      <ConnectionStatus isConnected={isConnected} />
      
      {/* 执行计划显示 */}
      {state.plans.length > 0 && (
        <PlanView plans={state.plans} />
      )}
      
      {/* 进度条 */}
      <ProgressBar progress={state.progress} />
      
      {/* 流式内容显示 */}
      {state.streamContent && (
        <StreamContent content={state.streamContent} />
      )}
      
      {/* 最终结果显示 */}
      {state.finalResult && (
        <FinalResult result={state.finalResult} />
      )}
      
      {/* 错误显示 */}
      {state.error && (
        <ErrorDisplay error={state.error} onRetry={startStreaming} />
      )}
      
      {/* 操作按钮 */}
      <ActionButtons 
        isRunning={state.status === 'running'}
        onStop={stopStreaming}
        onRetry={startStreaming}
      />
    </div>
  );
};

// 流式内容组件 - 支持打字机效果
const StreamContent: React.FC<{ content: string }> = ({ content }) => {
  const [displayedContent, setDisplayedContent] = useState('');
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    if (currentIndex < content.length) {
      const timer = setTimeout(() => {
        setDisplayedContent(prev => prev + content[currentIndex]);
        setCurrentIndex(prev => prev + 1);
      }, 30); // 30ms间隔的打字机效果

      return () => clearTimeout(timer);
    }
  }, [content, currentIndex]);

  // 如果内容发生变化，重置显示
  useEffect(() => {
    if (content.length < displayedContent.length) {
      setDisplayedContent(content);
      setCurrentIndex(content.length);
    }
  }, [content, displayedContent]);

  return (
    <div className="stream-content">
      <div className="content-text">
        {displayedContent}
        {currentIndex < content.length && (
          <span className="typing-cursor">|</span>
        )}
      </div>
    </div>
  );
};
```

## 前端缓存与性能优化

### 智能缓存策略

```typescript
interface CacheEntry {
  data: any;
  timestamp: number;
  ttl: number;
  hash: string;
}

class StreamingCache {
  private cache = new Map<string, CacheEntry>();
  private maxSize = 100;
  private defaultTTL = 5 * 60 * 1000; // 5分钟

  set(key: string, data: any, ttl: number = this.defaultTTL) {
    // 缓存容量控制
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }

    const hash = this.generateHash(data);
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
      hash
    });
  }

  get(key: string): any | null {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }

    // 检查是否过期
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  // 检查数据是否有变化
  hasChanged(key: string, newData: any): boolean {
    const entry = this.cache.get(key);
    if (!entry) return true;

    const newHash = this.generateHash(newData);
    return entry.hash !== newHash;
  }

  private evictOldest() {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, entry] of this.cache) {
      if (entry.timestamp < oldestTime) {
        oldestTime = entry.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  private generateHash(data: any): string {
    return btoa(JSON.stringify(data)).slice(0, 10);
  }

  clear() {
    this.cache.clear();
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      entries: Array.from(this.cache.keys())
    };
  }
}
```

### 虚拟滚动优化

```tsx
import React, { useState, useEffect, useMemo } from 'react';

interface VirtualScrollProps {
  items: any[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: any, index: number) => React.ReactNode;
  onScroll?: (scrollTop: number) => void;
}

export const VirtualScroll: React.FC<VirtualScrollProps> = ({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  onScroll
}) => {
  const [scrollTop, setScrollTop] = useState(0);

  // 计算可见范围
  const visibleRange = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const endIndex = Math.min(startIndex + visibleCount + 1, items.length);

    return { startIndex, endIndex, visibleCount };
  }, [scrollTop, itemHeight, containerHeight, items.length]);

  const totalHeight = items.length * itemHeight;
  const offsetY = visibleRange.startIndex * itemHeight;

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const newScrollTop = e.currentTarget.scrollTop;
    setScrollTop(newScrollTop);
    onScroll?.(newScrollTop);
  };

  // 自动滚动到底部（流式内容场景）
  const scrollToBottom = () => {
    setScrollTop(totalHeight - containerHeight);
  };

  return (
    <div 
      className="virtual-scroll-container"
      style={{ height: containerHeight, overflowY: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {items
            .slice(visibleRange.startIndex, visibleRange.endIndex)
            .map((item, index) => (
              <div
                key={visibleRange.startIndex + index}
                style={{ height: itemHeight }}
              >
                {renderItem(item, visibleRange.startIndex + index)}
              </div>
            ))}
        </div>
      </div>
    </div>
  );
};

// 用于流式消息显示的虚拟滚动
export const StreamMessageList: React.FC<{
  messages: StreamMessage[];
  autoScroll: boolean;
}> = ({ messages, autoScroll }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (autoScroll && containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight;
    }
  }, [messages, autoScroll]);

  return (
    <VirtualScroll
      items={messages}
      itemHeight={60}
      containerHeight={400}
      renderItem={(message, index) => (
        <MessageItem key={message.messageId || index} message={message} />
      )}
    />
  );
};
```

## 小结

客户端流式数据接收处理是实现良好用户体验的关键环节：

1. **连接管理**：实现稳定的连接和智能重连机制
2. **数据处理**：分类处理不同类型的流式消息
3. **状态管理**：使用批量更新和订阅模式优化性能
4. **UI优化**：虚拟滚动、打字机效果等提升用户体验
5. **缓存策略**：合理的缓存减少不必要的重新渲染

在下一节中，我们将探讨如何构建可靠的流式通信保障机制，确保系统在各种异常情况下都能稳定运行。

---

**本节关键要点：**
- EventSource API和fetch-event-source的高级用法
- 流式数据的分类处理和状态管理模式
- React中的流式UI更新最佳实践
- 前端性能优化策略：缓存、虚拟滚动等
- 用户体验增强：打字机效果、进度显示等
