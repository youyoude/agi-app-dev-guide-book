# 2.1.6 性能优化与监控

**学习目标：** 学会优化流式通信性能，建立完善的监控体系

## 流式传输的性能瓶颈分析

### 常见性能瓶颈识别

在流式通信系统中，性能瓶颈通常出现在以下几个方面：

#### 1. 网络层瓶颈

```java
@Component
public class NetworkBottleneckDetector {
    private final MeterRegistry meterRegistry;
    private final Timer networkLatencyTimer;
    private final Counter networkErrorCounter;
    
    public NetworkBottleneckDetector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.networkLatencyTimer = Timer.builder("network.latency")
            .description("网络延迟监控")
            .register(meterRegistry);
        this.networkErrorCounter = Counter.builder("network.errors")
            .description("网络错误计数")
            .register(meterRegistry);
    }

    public void detectBottlenecks(String requestId) {
        // 监控网络延迟
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // 执行网络请求
            performNetworkOperation();
            sample.stop(networkLatencyTimer);
            
            // 分析延迟模式
            analyzeLatencyPattern();
            
        } catch (Exception e) {
            networkErrorCounter.increment(Tags.of("error.type", e.getClass().getSimpleName()));
            throw e;
        }
    }

    private void analyzeLatencyPattern() {
        // 获取最近的延迟数据
        double averageLatency = networkLatencyTimer.mean(TimeUnit.MILLISECONDS);
        double maxLatency = networkLatencyTimer.max(TimeUnit.MILLISECONDS);
        
        if (averageLatency > 1000) { // 平均延迟超过1秒
            log.warn("检测到网络延迟过高: 平均{}ms, 最大{}ms", averageLatency, maxLatency);
            
            // 触发网络优化策略
            triggerNetworkOptimization();
        }
        
        // 检查延迟抖动
        if (maxLatency / averageLatency > 3) {
            log.warn("检测到网络延迟抖动严重: 平均{}ms, 最大{}ms", averageLatency, maxLatency);
        }
    }

    private void triggerNetworkOptimization() {
        // 1. 启用数据压缩
        // 2. 调整发送频率
        // 3. 启用批量发送
        // 4. 考虑连接池优化
    }
}
```

#### 2. CPU密集型操作瓶颈

```java
@Component
public class CPUBottleneckAnalyzer {
    private final OperatingSystemMXBean osBean;
    private final ScheduledExecutorService scheduler;
    private volatile double cpuUsageThreshold = 80.0;

    public CPUBottleneckAnalyzer() {
        this.osBean = ManagementFactory.getOperatingSystemMXBean();
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        startCPUMonitoring();
    }

    private void startCPUMonitoring() {
        scheduler.scheduleAtFixedRate(() -> {
            double cpuUsage = osBean.getProcessCpuLoad() * 100;
            
            if (cpuUsage > cpuUsageThreshold) {
                log.warn("CPU使用率过高: {}%", cpuUsage);
                
                // 分析CPU热点
                analyzeCPUHotspots();
                
                // 触发CPU优化策略
                triggerCPUOptimization(cpuUsage);
            }
        }, 5, 5, TimeUnit.SECONDS);
    }

    private void analyzeCPUHotspots() {
        // 获取线程CPU使用情况
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] threadIds = threadBean.getAllThreadIds();
        
        Map<String, Long> threadCpuTimes = new HashMap<>();
        for (long threadId : threadIds) {
            ThreadInfo threadInfo = threadBean.getThreadInfo(threadId);
            if (threadInfo != null) {
                long cpuTime = threadBean.getThreadCpuTime(threadId);
                threadCpuTimes.put(threadInfo.getThreadName(), cpuTime);
            }
        }
        
        // 找出CPU使用最高的线程
        threadCpuTimes.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .limit(5)
            .forEach(entry -> {
                log.info("高CPU使用线程: {} - {}ms", entry.getKey(), entry.getValue() / 1_000_000);
            });
    }

    private void triggerCPUOptimization(double cpuUsage) {
        if (cpuUsage > 90) {
            // 严重负载：限制新连接
            log.warn("CPU负载过高({}%), 限制新连接", cpuUsage);
            // 实现连接限制逻辑
            
        } else if (cpuUsage > 80) {
            // 中等负载：降低处理频率
            log.warn("CPU负载较高({}%), 降低处理频率", cpuUsage);
            // 实现频率控制逻辑
        }
    }
}
```

#### 3. 内存使用瓶颈

```java
@Component
public class MemoryBottleneckAnalyzer {
    private final MemoryMXBean memoryBean;
    private final List<GarbageCollectorMXBean> gcBeans;
    private final ScheduledExecutorService scheduler;

    public MemoryBottleneckAnalyzer() {
        this.memoryBean = ManagementFactory.getMemoryMXBean();
        this.gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        startMemoryMonitoring();
    }

    private void startMemoryMonitoring() {
        scheduler.scheduleAtFixedRate(() -> {
            analyzeMemoryUsage();
            analyzeGCPerformance();
        }, 10, 10, TimeUnit.SECONDS);
    }

    private void analyzeMemoryUsage() {
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        long usedMemory = heapUsage.getUsed();
        long maxMemory = heapUsage.getMax();
        
        double usagePercentage = (double) usedMemory / maxMemory * 100;
        
        if (usagePercentage > 85) {
            log.warn("堆内存使用率过高: {}% ({}MB / {}MB)", 
                usagePercentage, 
                usedMemory / 1024 / 1024, 
                maxMemory / 1024 / 1024);
            
            // 触发内存优化
            triggerMemoryOptimization(usagePercentage);
        }
        
        // 分析非堆内存（元空间等）
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        long nonHeapUsed = nonHeapUsage.getUsed();
        long nonHeapMax = nonHeapUsage.getMax();
        
        if (nonHeapMax > 0) {
            double nonHeapPercentage = (double) nonHeapUsed / nonHeapMax * 100;
            if (nonHeapPercentage > 80) {
                log.warn("非堆内存使用率过高: {}%", nonHeapPercentage);
            }
        }
    }

    private void analyzeGCPerformance() {
        long totalGCTime = 0;
        long totalGCCollections = 0;
        
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            totalGCTime += gcBean.getCollectionTime();
            totalGCCollections += gcBean.getCollectionCount();
        }
        
        // 分析GC频率和耗时
        log.info("GC统计 - 总次数: {}, 总耗时: {}ms", totalGCCollections, totalGCTime);
        
        // 如果GC时间占比过高，发出警告
        long uptime = ManagementFactory.getRuntimeMXBean().getUptime();
        double gcTimePercentage = (double) totalGCTime / uptime * 100;
        
        if (gcTimePercentage > 10) {
            log.warn("GC耗时占比过高: {}%", gcTimePercentage);
            triggerGCOptimization();
        }
    }

    private void triggerMemoryOptimization(double usagePercentage) {
        if (usagePercentage > 90) {
            // 紧急清理
            System.gc();
            clearCaches();
            limitNewConnections();
        } else if (usagePercentage > 85) {
            // 渐进清理
            clearExpiredCaches();
            optimizeBufferSizes();
        }
    }

    private void triggerGCOptimization() {
        // 建议JVM调优参数
        log.info("建议的JVM调优参数:");
        log.info("-XX:+UseG1GC");
        log.info("-XX:MaxGCPauseMillis=200");
        log.info("-XX:G1HeapRegionSize=16m");
    }
}
```

### 性能指标收集框架

```java
@Component
public class StreamingPerformanceCollector {
    private final MeterRegistry meterRegistry;
    private final Map<String, Timer> operationTimers = new ConcurrentHashMap<>();
    private final Map<String, Counter> operationCounters = new ConcurrentHashMap<>();
    private final Map<String, Gauge> resourceGauges = new ConcurrentHashMap<>();

    public StreamingPerformanceCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        initializeMetrics();
    }

    private void initializeMetrics() {
        // SSE连接相关指标
        Gauge.builder("sse.connections.active")
            .description("活跃SSE连接数")
            .register(meterRegistry, this, collector -> getActiveConnectionCount());

        Gauge.builder("sse.connections.total")
            .description("总SSE连接数")
            .register(meterRegistry, this, collector -> getTotalConnectionCount());

        // 消息处理指标
        Timer.builder("sse.message.processing.time")
            .description("消息处理时间")
            .register(meterRegistry);

        Counter.builder("sse.message.sent")
            .description("已发送消息数")
            .register(meterRegistry);

        Counter.builder("sse.message.failed")
            .description("发送失败消息数")
            .register(meterRegistry);

        // 系统资源指标
        Gauge.builder("system.memory.heap.used")
            .description("堆内存使用量")
            .register(meterRegistry, this, collector -> getHeapMemoryUsed());

        Gauge.builder("system.cpu.usage")
            .description("CPU使用率")
            .register(meterRegistry, this, collector -> getCPUUsage());
    }

    public void recordMessageProcessingTime(String messageType, long durationMs) {
        Timer timer = operationTimers.computeIfAbsent(
            "message.processing." + messageType,
            key -> Timer.builder(key)
                .description("消息处理时间: " + messageType)
                .register(meterRegistry)
        );
        
        timer.record(durationMs, TimeUnit.MILLISECONDS);
    }

    public void incrementMessageSent(String messageType) {
        Counter counter = operationCounters.computeIfAbsent(
            "message.sent." + messageType,
            key -> Counter.builder(key)
                .description("发送消息计数: " + messageType)
                .register(meterRegistry)
        );
        
        counter.increment();
    }

    public void recordConnectionLatency(String requestId, long latencyMs) {
        Timer.builder("connection.establishment.time")
            .tag("requestId", requestId)
            .register(meterRegistry)
            .record(latencyMs, TimeUnit.MILLISECONDS);
    }

    // 自定义指标收集方法
    private double getActiveConnectionCount() {
        // 实现获取活跃连接数的逻辑
        return SSEConnectionPool.getInstance().getActiveConnectionCount();
    }

    private double getTotalConnectionCount() {
        // 实现获取总连接数的逻辑
        return SSEConnectionPool.getInstance().getTotalConnectionCount();
    }

    private double getHeapMemoryUsed() {
        MemoryUsage heapUsage = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
        return heapUsage.getUsed();
    }

    private double getCPUUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        return osBean.getProcessCpuLoad() * 100;
    }

    /**
     * 生成性能报告
     */
    public PerformanceReport generateReport() {
        return PerformanceReport.builder()
            .timestamp(System.currentTimeMillis())
            .activeConnections(getActiveConnectionCount())
            .totalConnections(getTotalConnectionCount())
            .heapMemoryUsed(getHeapMemoryUsed())
            .cpuUsage(getCPUUsage())
            .averageMessageProcessingTime(calculateAverageProcessingTime())
            .messagesSentPerSecond(calculateMessageRate())
            .build();
    }

    private double calculateAverageProcessingTime() {
        return operationTimers.values().stream()
            .mapToDouble(timer -> timer.mean(TimeUnit.MILLISECONDS))
            .average()
            .orElse(0.0);
    }

    private double calculateMessageRate() {
        return operationCounters.values().stream()
            .mapToDouble(Counter::count)
            .sum();
    }
}
```

## 数据压缩与传输优化

### 多级数据压缩策略

```java
@Component
public class CompressionOptimizer {
    
    public enum CompressionLevel {
        NONE(0, "无压缩"),
        FAST(1, "快速压缩"),
        BALANCED(6, "平衡压缩"),
        BEST(9, "最佳压缩");
        
        private final int level;
        private final String description;
        
        CompressionLevel(int level, String description) {
            this.level = level;
            this.description = description;
        }
    }

    public String compressData(String data, CompressionLevel level) {
        if (level == CompressionLevel.NONE || data.length() < 100) {
            return data; // 小数据不压缩
        }

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            
            // 使用GZIP压缩
            try (GZIPOutputStream gzipOut = new GZIPOutputStream(baos) {{
                def.setLevel(level.level);
            }}) {
                gzipOut.write(data.getBytes(StandardCharsets.UTF_8));
            }
            
            byte[] compressed = baos.toByteArray();
            
            // 计算压缩率
            double compressionRatio = (double) compressed.length / data.length();
            
            log.debug("数据压缩 - 原始: {}bytes, 压缩后: {}bytes, 压缩率: {:.2f}%", 
                data.length(), compressed.length(), compressionRatio * 100);
            
            // 如果压缩效果不好，返回原始数据
            if (compressionRatio > 0.9) {
                return data;
            }
            
            // 返回Base64编码的压缩数据，添加压缩标识
            return "GZIP:" + Base64.getEncoder().encodeToString(compressed);
            
        } catch (IOException e) {
            log.error("数据压缩失败", e);
            return data; // 压缩失败时返回原始数据
        }
    }

    public String decompressData(String compressedData) {
        if (!compressedData.startsWith("GZIP:")) {
            return compressedData; // 非压缩数据
        }

        try {
            String base64Data = compressedData.substring(5);
            byte[] compressed = Base64.getDecoder().decode(base64Data);
            
            ByteArrayInputStream bais = new ByteArrayInputStream(compressed);
            try (GZIPInputStream gzipIn = new GZIPInputStream(bais);
                 ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                
                byte[] buffer = new byte[1024];
                int length;
                while ((length = gzipIn.read(buffer)) != -1) {
                    baos.write(buffer, 0, length);
                }
                
                return baos.toString(StandardCharsets.UTF_8);
            }
            
        } catch (Exception e) {
            log.error("数据解压失败", e);
            return compressedData; // 解压失败时返回原始数据
        }
    }

    /**
     * 自适应压缩级别选择
     */
    public CompressionLevel selectCompressionLevel(int dataSize, double networkLatency) {
        // 根据数据大小和网络延迟选择压缩级别
        if (dataSize < 1024) {
            return CompressionLevel.NONE; // 小数据不压缩
        } else if (networkLatency > 1000) {
            return CompressionLevel.BEST; // 高延迟网络使用最佳压缩
        } else if (networkLatency > 500) {
            return CompressionLevel.BALANCED; // 中等延迟使用平衡压缩
        } else {
            return CompressionLevel.FAST; // 低延迟网络使用快速压缩
        }
    }
}

@Component
public class AdaptiveCompressionSSEPrinter implements Printer {
    private final SseEmitter emitter;
    private final CompressionOptimizer compressionOptimizer;
    private final NetworkLatencyMonitor latencyMonitor;
    
    @Override
    public void send(String messageType, Object message) {
        try {
            String jsonData = JSON.toJSONString(message);
            
            // 获取当前网络延迟
            double latency = latencyMonitor.getCurrentLatency();
            
            // 选择适当的压缩级别
            CompressionOptimizer.CompressionLevel level = 
                compressionOptimizer.selectCompressionLevel(jsonData.length(), latency);
            
            // 压缩数据
            String compressedData = compressionOptimizer.compressData(jsonData, level);
            
            // 构造SSE消息
            SSEMessage sseMessage = SSEMessage.builder()
                .messageType(messageType)
                .data(compressedData)
                .compressed(!compressedData.equals(jsonData))
                .compressionLevel(level.name())
                .originalSize(jsonData.length())
                .compressedSize(compressedData.length())
                .build();
            
            emitter.send(sseMessage);
            
        } catch (Exception e) {
            log.error("发送压缩消息失败", e);
        }
    }
}
```

### 批量发送优化

```java
@Component
public class BatchingSseEmitter {
    private final SseEmitter emitter;
    private final List<Object> messageBuffer = new ArrayList<>();
    private final Object bufferLock = new Object();
    private final int batchSize;
    private final long flushIntervalMs;
    private final ScheduledExecutorService scheduler;
    private ScheduledFuture<?> flushTask;

    public BatchingSseEmitter(SseEmitter emitter, int batchSize, long flushIntervalMs) {
        this.emitter = emitter;
        this.batchSize = batchSize;
        this.flushIntervalMs = flushIntervalMs;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduleFlush();
    }

    public void send(Object message, boolean forceSend) {
        synchronized (bufferLock) {
            messageBuffer.add(message);
            
            // 检查是否需要立即发送
            if (forceSend || messageBuffer.size() >= batchSize) {
                flushBuffer();
            }
        }
    }

    private void scheduleFlush() {
        flushTask = scheduler.scheduleAtFixedRate(() -> {
            synchronized (bufferLock) {
                if (!messageBuffer.isEmpty()) {
                    flushBuffer();
                }
            }
        }, flushIntervalMs, flushIntervalMs, TimeUnit.MILLISECONDS);
    }

    private void flushBuffer() {
        if (messageBuffer.isEmpty()) {
            return;
        }

        try {
            // 创建批量消息
            BatchMessage batchMessage = BatchMessage.builder()
                .messages(new ArrayList<>(messageBuffer))
                .batchSize(messageBuffer.size())
                .timestamp(System.currentTimeMillis())
                .build();
            
            emitter.send(batchMessage);
            
            log.debug("批量发送消息: {} 条", messageBuffer.size());
            messageBuffer.clear();
            
        } catch (Exception e) {
            log.error("批量发送消息失败", e);
            // 考虑回退策略：逐条发送
            fallbackToIndividualSend();
        }
    }

    private void fallbackToIndividualSend() {
        for (Object message : messageBuffer) {
            try {
                emitter.send(message);
            } catch (Exception e) {
                log.error("单条消息发送也失败", e);
            }
        }
        messageBuffer.clear();
    }

    public void close() {
        synchronized (bufferLock) {
            if (flushTask != null) {
                flushTask.cancel(false);
            }
            flushBuffer(); // 发送剩余消息
        }
        scheduler.shutdown();
    }
}
```

## 连接池管理与资源复用

### 高级连接池实现

```java
@Configuration
public class AdvancedSSEConnectionPoolConfig {

    @Bean
    public AdvancedSSEConnectionPool advancedSSEConnectionPool() {
        return AdvancedSSEConnectionPool.builder()
            .maxConnections(1000)
            .maxConnectionsPerUser(10)
            .connectionTimeout(Duration.ofMinutes(1))
            .maxConnectionAge(Duration.ofHours(2))
            .idleTimeout(Duration.ofMinutes(30))
            .enableConnectionReuse(true)
            .enableConnectionWarmup(true)
            .build();
    }
}

@Component
public class AdvancedSSEConnectionPool {
    private final int maxConnections;
    private final int maxConnectionsPerUser;
    private final Duration connectionTimeout;
    private final Duration maxConnectionAge;
    private final Duration idleTimeout;
    private final boolean enableConnectionReuse;
    private final boolean enableConnectionWarmup;
    
    private final Map<String, ConnectionInfo> activeConnections = new ConcurrentHashMap<>();
    private final Map<String, Queue<ConnectionInfo>> userConnections = new ConcurrentHashMap<>();
    private final LoadingCache<String, AtomicInteger> userConnectionCounts;
    private final ScheduledExecutorService maintenanceScheduler;

    @Builder
    public AdvancedSSEConnectionPool(int maxConnections, int maxConnectionsPerUser,
                                   Duration connectionTimeout, Duration maxConnectionAge,
                                   Duration idleTimeout, boolean enableConnectionReuse,
                                   boolean enableConnectionWarmup) {
        this.maxConnections = maxConnections;
        this.maxConnectionsPerUser = maxConnectionsPerUser;
        this.connectionTimeout = connectionTimeout;
        this.maxConnectionAge = maxConnectionAge;
        this.idleTimeout = idleTimeout;
        this.enableConnectionReuse = enableConnectionReuse;
        this.enableConnectionWarmup = enableConnectionWarmup;
        
        // 用户连接计数缓存
        this.userConnectionCounts = Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterAccess(Duration.ofHours(1))
            .build(key -> new AtomicInteger(0));
        
        this.maintenanceScheduler = Executors.newScheduledThreadPool(2);
        startMaintenanceTasks();
    }

    public ConnectionResult acquireConnection(String userId, String requestId) {
        // 1. 检查全局连接限制
        if (activeConnections.size() >= maxConnections) {
            return ConnectionResult.failed("连接池已满");
        }

        // 2. 检查用户连接限制
        AtomicInteger userCount = userConnectionCounts.getIfPresent(userId);
        if (userCount != null && userCount.get() >= maxConnectionsPerUser) {
            return ConnectionResult.failed("用户连接数已达上限");
        }

        // 3. 尝试复用现有连接（如果启用）
        if (enableConnectionReuse) {
            ConnectionInfo reusableConnection = findReusableConnection(userId);
            if (reusableConnection != null) {
                return ConnectionResult.success(reusableConnection);
            }
        }

        // 4. 创建新连接
        return createNewConnection(userId, requestId);
    }

    private ConnectionInfo findReusableConnection(String userId) {
        Queue<ConnectionInfo> userQueue = userConnections.get(userId);
        if (userQueue == null || userQueue.isEmpty()) {
            return null;
        }

        ConnectionInfo connection = userQueue.poll();
        if (connection != null && isConnectionHealthy(connection)) {
            connection.updateLastUsed();
            return connection;
        }
        
        return null;
    }

    private ConnectionResult createNewConnection(String userId, String requestId) {
        try {
            SseEmitter emitter = new SseEmitterUTF8(connectionTimeout.toMillis());
            
            ConnectionInfo connectionInfo = ConnectionInfo.builder()
                .connectionId(requestId)
                .userId(userId)
                .emitter(emitter)
                .createTime(System.currentTimeMillis())
                .lastUsedTime(System.currentTimeMillis())
                .build();

            // 设置连接事件处理
            setupConnectionHandlers(connectionInfo);
            
            // 注册连接
            activeConnections.put(requestId, connectionInfo);
            userConnectionCounts.get(userId).incrementAndGet();
            
            // 预热连接（如果启用）
            if (enableConnectionWarmup) {
                warmupConnection(connectionInfo);
            }
            
            log.info("创建新的SSE连接: user={}, requestId={}", userId, requestId);
            return ConnectionResult.success(connectionInfo);
            
        } catch (Exception e) {
            log.error("创建连接失败: user={}, requestId={}", userId, requestId, e);
            return ConnectionResult.failed("连接创建失败: " + e.getMessage());
        }
    }

    private void setupConnectionHandlers(ConnectionInfo connectionInfo) {
        SseEmitter emitter = connectionInfo.getEmitter();
        String connectionId = connectionInfo.getConnectionId();
        String userId = connectionInfo.getUserId();

        emitter.onCompletion(() -> {
            log.info("SSE连接正常完成: {}", connectionId);
            releaseConnection(connectionId, userId, false);
        });

        emitter.onTimeout(() -> {
            log.info("SSE连接超时: {}", connectionId);
            releaseConnection(connectionId, userId, false);
        });

        emitter.onError((ex) -> {
            log.warn("SSE连接错误: {}", connectionId, ex);
            releaseConnection(connectionId, userId, false);
        });
    }

    private void warmupConnection(ConnectionInfo connectionInfo) {
        try {
            // 发送预热消息
            connectionInfo.getEmitter().send(SseEmitter.event()
                .name("warmup")
                .data("connection established"));
            
            log.debug("连接预热完成: {}", connectionInfo.getConnectionId());
        } catch (Exception e) {
            log.warn("连接预热失败: {}", connectionInfo.getConnectionId(), e);
        }
    }

    public void releaseConnection(String connectionId, String userId, boolean reusable) {
        ConnectionInfo connectionInfo = activeConnections.remove(connectionId);
        if (connectionInfo == null) {
            return;
        }

        // 减少用户连接计数
        AtomicInteger userCount = userConnectionCounts.getIfPresent(userId);
        if (userCount != null) {
            userCount.decrementAndGet();
        }

        if (reusable && enableConnectionReuse && isConnectionHealthy(connectionInfo)) {
            // 将连接放入复用队列
            userConnections.computeIfAbsent(userId, k -> new ConcurrentLinkedQueue<>())
                          .offer(connectionInfo);
            log.debug("连接已放入复用队列: {}", connectionId);
        } else {
            // 完全释放连接
            try {
                connectionInfo.getEmitter().complete();
            } catch (Exception e) {
                log.warn("关闭连接时出错: {}", connectionId, e);
            }
        }

        log.info("释放SSE连接: user={}, connectionId={}, reusable={}", 
                userId, connectionId, reusable);
    }

    private boolean isConnectionHealthy(ConnectionInfo connectionInfo) {
        long now = System.currentTimeMillis();
        
        // 检查连接年龄
        if (now - connectionInfo.getCreateTime() > maxConnectionAge.toMillis()) {
            return false;
        }
        
        // 检查空闲时间
        if (now - connectionInfo.getLastUsedTime() > idleTimeout.toMillis()) {
            return false;
        }
        
        // 可以添加更多健康检查逻辑
        return true;
    }

    private void startMaintenanceTasks() {
        // 定期清理过期连接
        maintenanceScheduler.scheduleAtFixedRate(() -> {
            cleanupExpiredConnections();
        }, 1, 1, TimeUnit.MINUTES);

        // 定期清理复用队列
        maintenanceScheduler.scheduleAtFixedRate(() -> {
            cleanupReusableConnections();
        }, 5, 5, TimeUnit.MINUTES);
    }

    private void cleanupExpiredConnections() {
        long now = System.currentTimeMillis();
        long maxAgeMs = maxConnectionAge.toMillis();
        
        activeConnections.entrySet().removeIf(entry -> {
            ConnectionInfo info = entry.getValue();
            if (now - info.getCreateTime() > maxAgeMs) {
                log.info("清理过期连接: {}", entry.getKey());
                try {
                    info.getEmitter().complete();
                } catch (Exception e) {
                    log.warn("关闭过期连接时出错", e);
                }
                return true;
            }
            return false;
        });
    }

    private void cleanupReusableConnections() {
        userConnections.forEach((userId, queue) -> {
            queue.removeIf(connectionInfo -> !isConnectionHealthy(connectionInfo));
        });
        
        // 移除空队列
        userConnections.entrySet().removeIf(entry -> entry.getValue().isEmpty());
    }

    public PoolStatistics getStatistics() {
        return PoolStatistics.builder()
            .activeConnections(activeConnections.size())
            .maxConnections(maxConnections)
            .reusableConnections(userConnections.values().stream()
                                              .mapToInt(Queue::size)
                                              .sum())
            .userCount(userConnectionCounts.asMap().size())
            .build();
    }
}

@Data
@Builder
public class ConnectionInfo {
    private final String connectionId;
    private final String userId;
    private final SseEmitter emitter;
    private final long createTime;
    private volatile long lastUsedTime;
    
    public void updateLastUsed() {
        this.lastUsedTime = System.currentTimeMillis();
    }
}

@Data
@Builder
public class ConnectionResult {
    private final boolean success;
    private final String message;
    private final ConnectionInfo connectionInfo;
    
    public static ConnectionResult success(ConnectionInfo connectionInfo) {
        return ConnectionResult.builder()
            .success(true)
            .connectionInfo(connectionInfo)
            .build();
    }
    
    public static ConnectionResult failed(String message) {
        return ConnectionResult.builder()
            .success(false)
            .message(message)
            .build();
    }
}
```

## 流式通信的监控指标设计

### 核心监控指标体系

```java
@Component
public class StreamingMonitoringSystem {
    private final MeterRegistry meterRegistry;
    private final Map<String, StreamingMetrics> sessionMetrics = new ConcurrentHashMap<>();

    public StreamingMonitoringSystem(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        setupGlobalMetrics();
    }

    private void setupGlobalMetrics() {
        // 连接相关指标
        Gauge.builder("streaming.connections.active")
            .description("活跃流式连接数")
            .register(meterRegistry, this, monitor -> getActiveConnectionCount());

        Gauge.builder("streaming.connections.success.rate")
            .description("连接成功率")
            .register(meterRegistry, this, monitor -> getConnectionSuccessRate());

        // 消息相关指标
        Counter.builder("streaming.messages.sent.total")
            .description("发送消息总数")
            .register(meterRegistry);

        Counter.builder("streaming.messages.failed.total")
            .description("发送失败消息总数")
            .register(meterRegistry);

        Timer.builder("streaming.message.processing.duration")
            .description("消息处理耗时")
            .register(meterRegistry);

        // 性能相关指标
        Timer.builder("streaming.connection.establishment.duration")
            .description("连接建立耗时")
            .register(meterRegistry);

        Gauge.builder("streaming.throughput.messages.per.second")
            .description("消息吞吐量（每秒）")
            .register(meterRegistry, this, monitor -> getMessagesPerSecond());

        // 资源相关指标
        Gauge.builder("streaming.memory.usage.bytes")
            .description("流式服务内存使用量")
            .register(meterRegistry, this, monitor -> getStreamingMemoryUsage());

        Gauge.builder("streaming.cpu.usage.percentage")
            .description("流式服务CPU使用率")
            .register(meterRegistry, this, monitor -> getStreamingCPUUsage());
    }

    public StreamingMetrics startSession(String sessionId) {
        StreamingMetrics metrics = new StreamingMetrics(sessionId, meterRegistry);
        sessionMetrics.put(sessionId, metrics);
        return metrics;
    }

    public void endSession(String sessionId) {
        StreamingMetrics metrics = sessionMetrics.remove(sessionId);
        if (metrics != null) {
            metrics.recordSessionEnd();
        }
    }

    // 指标计算方法
    private double getActiveConnectionCount() {
        return sessionMetrics.size();
    }

    private double getConnectionSuccessRate() {
        // 实现连接成功率计算逻辑
        return 0.95; // 示例值
    }

    private double getMessagesPerSecond() {
        return sessionMetrics.values().stream()
            .mapToDouble(StreamingMetrics::getMessagesPerSecond)
            .sum();
    }

    private double getStreamingMemoryUsage() {
        // 计算流式服务专用的内存使用量
        return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    }

    private double getStreamingCPUUsage() {
        return ManagementFactory.getOperatingSystemMXBean().getProcessCpuLoad() * 100;
    }

    /**
     * 生成监控报告
     */
    public MonitoringReport generateReport() {
        return MonitoringReport.builder()
            .timestamp(System.currentTimeMillis())
            .activeConnections(getActiveConnectionCount())
            .connectionSuccessRate(getConnectionSuccessRate())
            .totalMessagesPerSecond(getMessagesPerSecond())
            .memoryUsage(getStreamingMemoryUsage())
            .cpuUsage(getStreamingCPUUsage())
            .sessionMetrics(new HashMap<>(sessionMetrics))
            .alertsTriggered(checkAlerts())
            .build();
    }

    private List<Alert> checkAlerts() {
        List<Alert> alerts = new ArrayList<>();
        
        // CPU使用率告警
        double cpuUsage = getStreamingCPUUsage();
        if (cpuUsage > 80) {
            alerts.add(Alert.builder()
                .type("HIGH_CPU_USAGE")
                .severity(cpuUsage > 90 ? AlertSeverity.CRITICAL : AlertSeverity.WARNING)
                .message(String.format("CPU使用率过高: %.2f%%", cpuUsage))
                .timestamp(System.currentTimeMillis())
                .build());
        }
        
        // 内存使用率告警
        Runtime runtime = Runtime.getRuntime();
        double memoryUsagePercent = (double) (runtime.totalMemory() - runtime.freeMemory()) 
                                   / runtime.maxMemory() * 100;
        if (memoryUsagePercent > 85) {
            alerts.add(Alert.builder()
                .type("HIGH_MEMORY_USAGE")
                .severity(memoryUsagePercent > 95 ? AlertSeverity.CRITICAL : AlertSeverity.WARNING)
                .message(String.format("内存使用率过高: %.2f%%", memoryUsagePercent))
                .timestamp(System.currentTimeMillis())
                .build());
        }
        
        // 连接数告警
        double activeConnections = getActiveConnectionCount();
        if (activeConnections > 800) { // 假设最大连接数为1000
            alerts.add(Alert.builder()
                .type("HIGH_CONNECTION_COUNT")
                .severity(activeConnections > 950 ? AlertSeverity.CRITICAL : AlertSeverity.WARNING)
                .message(String.format("活跃连接数过多: %.0f", activeConnections))
                .timestamp(System.currentTimeMillis())
                .build());
        }
        
        return alerts;
    }
}

public class StreamingMetrics {
    private final String sessionId;
    private final MeterRegistry meterRegistry;
    private final long sessionStartTime;
    private final AtomicLong messagesSent = new AtomicLong(0);
    private final AtomicLong messagesReceived = new AtomicLong(0);
    private final AtomicLong bytesSent = new AtomicLong(0);
    private final AtomicLong bytesReceived = new AtomicLong(0);
    private final Timer messageSendTimer;
    private final Timer messageReceiveTimer;
    private volatile long sessionEndTime = 0;

    public StreamingMetrics(String sessionId, MeterRegistry meterRegistry) {
        this.sessionId = sessionId;
        this.meterRegistry = meterRegistry;
        this.sessionStartTime = System.currentTimeMillis();
        
        this.messageSendTimer = Timer.builder("streaming.session.message.send.duration")
            .tag("sessionId", sessionId)
            .register(meterRegistry);
            
        this.messageReceiveTimer = Timer.builder("streaming.session.message.receive.duration")
            .tag("sessionId", sessionId)
            .register(meterRegistry);
    }

    public void recordMessageSent(int messageSize, long processingTimeMs) {
        messagesSent.incrementAndGet();
        bytesSent.addAndGet(messageSize);
        messageSendTimer.record(processingTimeMs, TimeUnit.MILLISECONDS);
    }

    public void recordMessageReceived(int messageSize, long processingTimeMs) {
        messagesReceived.incrementAndGet();
        bytesReceived.addAndGet(messageSize);
        messageReceiveTimer.record(processingTimeMs, TimeUnit.MILLISECONDS);
    }

    public void recordSessionEnd() {
        this.sessionEndTime = System.currentTimeMillis();
        
        // 记录会话级别指标
        long sessionDuration = sessionEndTime - sessionStartTime;
        Timer.builder("streaming.session.duration")
            .tag("sessionId", sessionId)
            .register(meterRegistry)
            .record(sessionDuration, TimeUnit.MILLISECONDS);
        
        // 记录会话总体统计
        Gauge.builder("streaming.session.messages.sent.total")
            .tag("sessionId", sessionId)
            .register(meterRegistry, messagesSent, AtomicLong::get);
            
        Gauge.builder("streaming.session.bytes.sent.total")
            .tag("sessionId", sessionId)
            .register(meterRegistry, bytesSent, AtomicLong::get);
    }

    public double getMessagesPerSecond() {
        long duration = (sessionEndTime > 0 ? sessionEndTime : System.currentTimeMillis()) 
                       - sessionStartTime;
        if (duration <= 0) return 0;
        
        return (double) messagesSent.get() / (duration / 1000.0);
    }

    public double getAverageMessageSize() {
        long totalMessages = messagesSent.get();
        return totalMessages > 0 ? (double) bytesSent.get() / totalMessages : 0;
    }

    // Getter methods...
    public String getSessionId() { return sessionId; }
    public long getMessagesSent() { return messagesSent.get(); }
    public long getMessagesReceived() { return messagesReceived.get(); }
    public long getBytesSent() { return bytesSent.get(); }
    public long getBytesReceived() { return bytesReceived.get(); }
    public long getSessionDuration() { 
        return (sessionEndTime > 0 ? sessionEndTime : System.currentTimeMillis()) - sessionStartTime; 
    }
}
```

### 实时监控仪表板

```typescript
interface MonitoringDashboardState {
  globalMetrics: GlobalMetrics;
  sessionMetrics: Map<string, SessionMetrics>;
  alerts: Alert[];
  performanceHistory: PerformanceDataPoint[];
  isConnected: boolean;
}

interface GlobalMetrics {
  activeConnections: number;
  totalConnections: number;
  connectionSuccessRate: number;
  messagesPerSecond: number;
  cpuUsage: number;
  memoryUsage: number;
  memoryUsagePercent: number;
}

export const MonitoringDashboard: React.FC = () => {
  const [dashboardState, setDashboardState] = useState<MonitoringDashboardState>({
    globalMetrics: {
      activeConnections: 0,
      totalConnections: 0,
      connectionSuccessRate: 0,
      messagesPerSecond: 0,
      cpuUsage: 0,
      memoryUsage: 0,
      memoryUsagePercent: 0
    },
    sessionMetrics: new Map(),
    alerts: [],
    performanceHistory: [],
    isConnected: false
  });

  useEffect(() => {
    const monitoringSSE = new EventSource('/actuator/monitoring/stream');
    
    monitoringSSE.onopen = () => {
      setDashboardState(prev => ({ ...prev, isConnected: true }));
    };

    monitoringSSE.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleMonitoringData(data);
    };

    monitoringSSE.onerror = () => {
      setDashboardState(prev => ({ ...prev, isConnected: false }));
    };

    return () => {
      monitoringSSE.close();
    };
  }, []);

  const handleMonitoringData = (data: any) => {
    switch (data.type) {
      case 'global_metrics':
        setDashboardState(prev => ({
          ...prev,
          globalMetrics: data.metrics,
          performanceHistory: [
            ...prev.performanceHistory.slice(-29), // 保留最近30个数据点
            {
              timestamp: data.timestamp,
              cpuUsage: data.metrics.cpuUsage,
              memoryUsage: data.metrics.memoryUsagePercent,
              messagesPerSecond: data.metrics.messagesPerSecond,
              activeConnections: data.metrics.activeConnections
            }
          ]
        }));
        break;

      case 'session_metrics':
        setDashboardState(prev => {
          const newSessionMetrics = new Map(prev.sessionMetrics);
          newSessionMetrics.set(data.sessionId, data.metrics);
          return { ...prev, sessionMetrics: newSessionMetrics };
        });
        break;

      case 'alert':
        setDashboardState(prev => ({
          ...prev,
          alerts: [data.alert, ...prev.alerts.slice(0, 9)] // 保留最近10个告警
        }));
        break;
    }
  };

  return (
    <div className="monitoring-dashboard">
      {/* 连接状态指示器 */}
      <div className="connection-status">
        <StatusIndicator 
          connected={dashboardState.isConnected}
          label="监控连接"
        />
      </div>

      {/* 全局指标卡片 */}
      <div className="metrics-cards">
        <MetricCard
          title="活跃连接"
          value={dashboardState.globalMetrics.activeConnections}
          unit="个"
          trend={calculateTrend(dashboardState.performanceHistory, 'activeConnections')}
          status={getConnectionStatus(dashboardState.globalMetrics.activeConnections)}
        />
        
        <MetricCard
          title="CPU使用率"
          value={dashboardState.globalMetrics.cpuUsage}
          unit="%"
          trend={calculateTrend(dashboardState.performanceHistory, 'cpuUsage')}
          status={getCPUStatus(dashboardState.globalMetrics.cpuUsage)}
        />
        
        <MetricCard
          title="内存使用率"
          value={dashboardState.globalMetrics.memoryUsagePercent}
          unit="%"
          trend={calculateTrend(dashboardState.performanceHistory, 'memoryUsage')}
          status={getMemoryStatus(dashboardState.globalMetrics.memoryUsagePercent)}
        />
        
        <MetricCard
          title="消息/秒"
          value={dashboardState.globalMetrics.messagesPerSecond}
          unit="msg/s"
          trend={calculateTrend(dashboardState.performanceHistory, 'messagesPerSecond')}
          status="normal"
        />
      </div>

      {/* 性能趋势图 */}
      <div className="performance-charts">
        <div className="chart-container">
          <h3>性能趋势</h3>
          <PerformanceTrendChart data={dashboardState.performanceHistory} />
        </div>
      </div>

      {/* 告警面板 */}
      {dashboardState.alerts.length > 0 && (
        <div className="alerts-panel">
          <h3>告警信息</h3>
          <AlertList alerts={dashboardState.alerts} />
        </div>
      )}

      {/* 会话详情表格 */}
      <div className="sessions-table">
        <h3>活跃会话</h3>
        <SessionMetricsTable sessions={Array.from(dashboardState.sessionMetrics)} />
      </div>
    </div>
  );
};

// 辅助函数
const calculateTrend = (history: PerformanceDataPoint[], metric: keyof PerformanceDataPoint): 'up' | 'down' | 'stable' => {
  if (history.length < 2) return 'stable';
  
  const recent = history.slice(-3);
  const avg = recent.reduce((sum, point) => sum + (point[metric] as number), 0) / recent.length;
  const current = recent[recent.length - 1][metric] as number;
  
  const difference = current - avg;
  const threshold = avg * 0.1; // 10% threshold
  
  if (difference > threshold) return 'up';
  if (difference < -threshold) return 'down';
  return 'stable';
};

const getConnectionStatus = (count: number): 'normal' | 'warning' | 'critical' => {
  if (count > 900) return 'critical';
  if (count > 700) return 'warning';
  return 'normal';
};

const getCPUStatus = (usage: number): 'normal' | 'warning' | 'critical' => {
  if (usage > 90) return 'critical';
  if (usage > 70) return 'warning';
  return 'normal';
};

const getMemoryStatus = (usage: number): 'normal' | 'warning' | 'critical' => {
  if (usage > 90) return 'critical';
  if (usage > 80) return 'warning';
  return 'normal';
};
```

## 问题诊断与性能调优实战

### 自动化问题诊断系统

```java
@Component
public class AutomatedDiagnosticSystem {
    private final List<DiagnosticRule> diagnosticRules;
    private final PerformanceDataCollector dataCollector;
    private final AlertService alertService;

    public AutomatedDiagnosticSystem() {
        this.diagnosticRules = initializeDiagnosticRules();
        this.dataCollector = new PerformanceDataCollector();
        this.alertService = new AlertService();
    }

    private List<DiagnosticRule> initializeDiagnosticRules() {
        List<DiagnosticRule> rules = new ArrayList<>();
        
        // 高延迟诊断规则
        rules.add(DiagnosticRule.builder()
            .name("HIGH_LATENCY_DETECTION")
            .condition(data -> data.getAverageLatency() > 1000) // 平均延迟 > 1秒
            .diagnosis("网络延迟过高")
            .suggestions(Arrays.asList(
                "检查网络连接质量",
                "启用数据压缩",
                "优化数据包大小",
                "考虑使用CDN"
            ))
            .severity(DiagnosticSeverity.WARNING)
            .build());

        // 高CPU使用率诊断规则
        rules.add(DiagnosticRule.builder()
            .name("HIGH_CPU_USAGE")
            .condition(data -> data.getCpuUsage() > 80)
            .diagnosis("CPU使用率过高")
            .suggestions(Arrays.asList(
                "优化消息处理算法",
                "启用异步处理",
                "增加线程池大小",
                "考虑水平扩展"
            ))
            .severity(DiagnosticSeverity.CRITICAL)
            .build());

        // 内存泄漏诊断规则
        rules.add(DiagnosticRule.builder()
            .name("MEMORY_LEAK_DETECTION")
            .condition(data -> isMemoryLeakSuspected(data))
            .diagnosis("疑似内存泄漏")
            .suggestions(Arrays.asList(
                "检查连接是否正确释放",
                "清理过期缓存",
                "检查循环引用",
                "启用JVM堆分析"
            ))
            .severity(DiagnosticSeverity.CRITICAL)
            .build());

        // 连接池耗尽诊断规则
        rules.add(DiagnosticRule.builder()
            .name("CONNECTION_POOL_EXHAUSTION")
            .condition(data -> data.getConnectionPoolUsage() > 0.9)
            .diagnosis("连接池接近耗尽")
            .suggestions(Arrays.asList(
                "增加连接池大小",
                "优化连接复用策略",
                "减少连接持有时间",
                "实现连接队列机制"
            ))
            .severity(DiagnosticSeverity.WARNING)
            .build());

        return rules;
    }

    @Scheduled(fixedRate = 30000) // 每30秒执行一次诊断
    public void runDiagnostics() {
        PerformanceData currentData = dataCollector.collect();
        
        for (DiagnosticRule rule : diagnosticRules) {
            if (rule.getCondition().test(currentData)) {
                DiagnosticResult result = DiagnosticResult.builder()
                    .ruleName(rule.getName())
                    .diagnosis(rule.getDiagnosis())
                    .suggestions(rule.getSuggestions())
                    .severity(rule.getSeverity())
                    .data(currentData)
                    .timestamp(System.currentTimeMillis())
                    .build();

                handleDiagnosticResult(result);
            }
        }
    }

    private boolean isMemoryLeakSuspected(PerformanceData data) {
        // 检查内存使用趋势
        List<Double> memoryHistory = data.getMemoryUsageHistory();
        if (memoryHistory.size() < 10) return false;

        // 计算内存使用的线性增长趋势
        double trend = calculateLinearTrend(memoryHistory);
        
        // 如果内存使用呈现持续上升趋势，且增长率超过阈值，则怀疑内存泄漏
        return trend > 0.5 && data.getCurrentMemoryUsage() > 0.8;
    }

    private double calculateLinearTrend(List<Double> values) {
        int n = values.size();
        double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        
        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values.get(i);
            sumXY += i * values.get(i);
            sumX2 += i * i;
        }
        
        // 线性回归斜率计算
        return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    }

    private void handleDiagnosticResult(DiagnosticResult result) {
        log.warn("诊断发现问题: {} - {}", result.getRuleName(), result.getDiagnosis());
        
        // 发送告警
        alertService.sendAlert(Alert.builder()
            .type("DIAGNOSTIC_ISSUE")
            .severity(convertSeverity(result.getSeverity()))
            .message(result.getDiagnosis())
            .details(result.getSuggestions())
            .timestamp(result.getTimestamp())
            .build());
        
        // 尝试自动修复（针对某些问题）
        attemptAutoRemediation(result);
    }

    private void attemptAutoRemediation(DiagnosticResult result) {
        switch (result.getRuleName()) {
            case "HIGH_CPU_USAGE":
                // 自动降低处理频率
                adjustProcessingRate(0.8);
                break;
                
            case "CONNECTION_POOL_EXHAUSTION":
                // 临时增加连接池大小
                temporarilyExpandConnectionPool();
                break;
                
            case "MEMORY_LEAK_DETECTION":
                // 强制垃圾回收
                System.gc();
                // 清理缓存
                clearCaches();
                break;
        }
    }
}

@Data
@Builder
public class DiagnosticRule {
    private String name;
    private Predicate<PerformanceData> condition;
    private String diagnosis;
    private List<String> suggestions;
    private DiagnosticSeverity severity;
}

@Data
@Builder
public class DiagnosticResult {
    private String ruleName;
    private String diagnosis;
    private List<String> suggestions;
    private DiagnosticSeverity severity;
    private PerformanceData data;
    private long timestamp;
}
```

### 性能调优实战指南

```java
@Component
public class PerformanceTuningOrchestrator {
    
    /**
     * 综合性能调优策略
     */
    public void performComprehensiveTuning(PerformanceData currentData) {
        // 1. JVM调优
        tuneJVMParameters(currentData);
        
        // 2. 线程池调优
        tuneThreadPools(currentData);
        
        // 3. 网络调优
        tuneNetworkSettings(currentData);
        
        // 4. 应用层调优
        tuneApplicationLayer(currentData);
    }

    private void tuneJVMParameters(PerformanceData data) {
        if (data.getGcTimePercentage() > 10) {
            log.info("GC时间占比过高，建议调优参数:");
            log.info("# 使用G1GC收集器");
            log.info("-XX:+UseG1GC");
            log.info("-XX:MaxGCPauseMillis=200");
            log.info("-XX:G1HeapRegionSize=16m");
            
            if (data.getHeapMemoryUsage() > 0.8) {
                long recommendedHeapSize = (long) (data.getCurrentHeapSize() * 1.5);
                log.info("# 增加堆内存大小");
                log.info("-Xmx{}m", recommendedHeapSize / 1024 / 1024);
            }
        }

        if (data.getMetaspaceUsage() > 0.8) {
            log.info("# 增加元空间大小");
            log.info("-XX:MetaspaceSize=256m");
            log.info("-XX:MaxMetaspaceSize=512m");
        }
    }

    private void tuneThreadPools(PerformanceData data) {
        if (data.getThreadPoolQueueSize() > data.getThreadPoolMaxSize() * 0.8) {
            int recommendedCoreSize = data.getThreadPoolCoreSize() * 2;
            int recommendedMaxSize = data.getThreadPoolMaxSize() * 2;
            
            log.info("线程池调优建议:");
            log.info("# 增加线程池大小");
            log.info("core-pool-size: {}", recommendedCoreSize);
            log.info("max-pool-size: {}", recommendedMaxSize);
            log.info("queue-capacity: {}", data.getThreadPoolQueueCapacity() * 2);
        }

        if (data.getAverageTaskExecutionTime() > 1000) {
            log.info("# 任务执行时间过长，考虑:");
            log.info("1. 启用任务分片");
            log.info("2. 增加异步处理");
            log.info("3. 优化业务逻辑");
        }
    }

    private void tuneNetworkSettings(PerformanceData data) {
        if (data.getAverageLatency() > 500) {
            log.info("网络调优建议:");
            log.info("# 启用TCP_NODELAY");
            log.info("server.tomcat.socket-options.tcp-no-delay=true");
            
            log.info("# 调整连接超时");
            log.info("server.tomcat.connection-timeout=30000");
            
            log.info("# 启用压缩");
            log.info("server.compression.enabled=true");
            log.info("server.compression.mime-types=application/json,text/plain");
        }

        if (data.getThroughput() < data.getExpectedThroughput() * 0.8) {
            log.info("# 优化连接池设置");
            log.info("server.tomcat.max-connections=2000");
            log.info("server.tomcat.threads.max=200");
            log.info("server.tomcat.threads.min-spare=20");
        }
    }

    private void tuneApplicationLayer(PerformanceData data) {
        if (data.getCacheHitRate() < 0.8) {
            log.info("缓存调优建议:");
            log.info("# 增加缓存大小");
            log.info("# 优化缓存键设计");
            log.info("# 实现预热策略");
        }

        if (data.getDatabaseConnectionPoolUsage() > 0.8) {
            log.info("数据库连接池调优:");
            log.info("# 增加连接池大小");
            log.info("spring.datasource.hikari.maximum-pool-size=30");
            log.info("spring.datasource.hikari.minimum-idle=10");
        }
    }

    /**
     * 实时性能调优
     */
    @EventListener
    public void handlePerformanceEvent(PerformanceEvent event) {
        PerformanceData data = event.getData();
        
        // 动态调整策略
        if (data.getCpuUsage() > 90) {
            // 紧急降负载
            emergencyLoadReduction();
        } else if (data.getCpuUsage() > 80) {
            // 适度降负载
            moderateLoadReduction();
        } else if (data.getCpuUsage() < 50) {
            // 可以增加负载
            increaseCapacity();
        }
    }

    private void emergencyLoadReduction() {
        log.warn("执行紧急降负载策略");
        // 1. 限制新连接
        // 2. 降低消息发送频率
        // 3. 暂停非关键任务
        // 4. 启用最高级别压缩
    }

    private void moderateLoadReduction() {
        log.info("执行适度降负载策略");
        // 1. 调整线程池大小
        // 2. 启用批量处理
        // 3. 增加缓存使用
    }

    private void increaseCapacity() {
        log.info("系统负载较低，可以增加处理能力");
        // 1. 接受更多连接
        // 2. 提高消息处理频率
        // 3. 启动后台维护任务
    }
}
```

## 小结

流式通信的性能优化与监控是一个系统性工程：

1. **性能瓶颈分析**：从网络、CPU、内存等多个维度识别瓶颈
2. **数据压缩优化**：通过自适应压缩和批量发送提升传输效率
3. **资源管理**：高级连接池和资源复用策略
4. **监控体系**：完善的指标收集和实时监控仪表板
5. **问题诊断**：自动化问题发现和修复建议
6. **性能调优**：从JVM到应用层的全方位优化策略

这些技术手段结合使用，能够确保流式通信系统在高负载下仍能保持优异的性能表现。在下一节中，我们将探讨如何将这些技术应用到企业级部署和运维实践中。

---

**本节关键要点：**
- 流式传输性能瓶颈的系统性分析方法
- 多级数据压缩和批量传输优化策略
- 高级连接池管理和资源复用技术
- 完善的监控指标体系和实时仪表板
- 自动化问题诊断和性能调优实战
