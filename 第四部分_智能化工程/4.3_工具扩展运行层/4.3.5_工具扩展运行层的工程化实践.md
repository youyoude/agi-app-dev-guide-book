# 4.3.5 å·¥å…·æ‰©å±•è¿è¡Œå±‚çš„å·¥ç¨‹åŒ–å®è·µ

> "ç†è®ºå†å®Œç¾ï¼Œä¹Ÿéœ€è¦é€šè¿‡å·¥ç¨‹åŒ–å®è·µæ¥æ£€éªŒå’Œå®Œå–„ã€‚æœ¬èŠ‚å°†ç†è®ºè½¬åŒ–ä¸ºå¯è½åœ°çš„å·¥ç¨‹æ–¹æ¡ˆï¼Œè§£å†³å®é™…éƒ¨ç½²ä¸­çš„å…³é”®é—®é¢˜ã€‚"

## ğŸ¯ æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡MCPåè®®ç­‰æ ‡å‡†åŒ–å·¥å…·é›†æˆæ–¹æ¡ˆ
- âœ… è§£å†³å·¥å…·å¹¶å‘æ‰§è¡Œå’Œèµ„æºç«äº‰é—®é¢˜
- âœ… å®ç°å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ•…éšœæ¢å¤æœºåˆ¶
- âœ… æ„å»ºä¼ä¸šçº§çš„å·¥å…·è¿è¡Œç›‘æ§ä½“ç³»

## æ ‡å‡†åŒ–å·¥å…·é›†æˆ

### MCPåè®®å®ç°

Model Context Protocol (MCP)æ˜¯å·¥å…·æ ‡å‡†åŒ–é›†æˆçš„é‡è¦åè®®ï¼Œä¸ºAIåº”ç”¨æä¾›äº†ç»Ÿä¸€çš„å·¥å…·æ¥å£æ ‡å‡†ï¼š

```mermaid
graph TB
    subgraph "MCPåè®®æ¶æ„"
        CLIENT[ğŸ–¥ï¸ MCPå®¢æˆ·ç«¯<br/>AIåº”ç”¨]
        SERVER[ğŸ”§ MCPæœåŠ¡å™¨<br/>å·¥å…·æä¾›è€…]
        TRANSPORT[ğŸŒ ä¼ è¾“å±‚<br/>WebSocket/HTTP]
        
        subgraph "åè®®å±‚"
            HANDSHAKE[ğŸ¤ æ¡æ‰‹åè®®]
            DISCOVERY[ğŸ” å·¥å…·å‘ç°]
            EXECUTION[âš¡ æ‰§è¡Œåè®®]
            STREAMING[ğŸ“¡ æµå¼ä¼ è¾“]
        end
    end
    
    CLIENT <--> TRANSPORT
    TRANSPORT <--> SERVER
    
    CLIENT --> HANDSHAKE
    CLIENT --> DISCOVERY
    CLIENT --> EXECUTION
    CLIENT --> STREAMING
```

#### MCPå®¢æˆ·ç«¯å®ç°

```python
import asyncio
import json
import websockets
from typing import Dict, List, Any, Optional, AsyncGenerator
from dataclasses import dataclass
from enum import Enum

class MCPMessageType(Enum):
    INITIALIZE = "initialize"
    INITIALIZED = "initialized"
    LIST_TOOLS = "tools/list"
    CALL_TOOL = "tools/call"
    RESULT = "result"
    ERROR = "error"
    NOTIFICATION = "notification"

@dataclass
class MCPTool:
    """MCPå·¥å…·æè¿°"""
    name: str
    description: str
    inputSchema: Dict[str, Any]
    outputSchema: Optional[Dict[str, Any]] = None

@dataclass
class MCPMessage:
    """MCPæ¶ˆæ¯æ ¼å¼"""
    jsonrpc: str = "2.0"
    id: Optional[str] = None
    method: Optional[str] = None
    params: Optional[Dict[str, Any]] = None
    result: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None

class MCPClient:
    """MCPåè®®å®¢æˆ·ç«¯"""
    
    def __init__(self, server_uri: str):
        self.server_uri = server_uri
        self.websocket = None
        self.connected = False
        self.request_counter = 0
        self.pending_requests = {}
        self.available_tools = {}
        self.message_handlers = {
            "result": self._handle_result,
            "error": self._handle_error,
            "notification": self._handle_notification
        }
    
    async def connect(self) -> bool:
        """è¿æ¥MCPæœåŠ¡å™¨"""
        try:
            self.websocket = await websockets.connect(self.server_uri)
            
            # å¯åŠ¨æ¶ˆæ¯ç›‘å¬
            asyncio.create_task(self._message_listener())
            
            # æ‰§è¡Œæ¡æ‰‹
            if await self._handshake():
                # è·å–å¯ç”¨å·¥å…·åˆ—è¡¨
                await self._discover_tools()
                self.connected = True
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Failed to connect to MCP server: {e}")
            return False
    
    async def _handshake(self) -> bool:
        """æ‰§è¡ŒMCPæ¡æ‰‹åè®®"""
        
        initialize_message = MCPMessage(
            id=self._generate_request_id(),
            method=MCPMessageType.INITIALIZE.value,
            params={
                "protocolVersion": "1.0",
                "capabilities": {
                    "tools": {"listChanged": True}
                },
                "clientInfo": {
                    "name": "AI-Tool-Runtime",
                    "version": "1.0.0"
                }
            }
        )
        
        response = await self._send_request(initialize_message)
        
        if response and not response.error:
            # å‘é€initializedé€šçŸ¥
            initialized_notification = MCPMessage(
                method=MCPMessageType.INITIALIZED.value,
                params={}
            )
            await self._send_notification(initialized_notification)
            return True
        
        return False
    
    async def _discover_tools(self) -> None:
        """å‘ç°å¯ç”¨å·¥å…·"""
        
        list_tools_message = MCPMessage(
            id=self._generate_request_id(),
            method=MCPMessageType.LIST_TOOLS.value,
            params={}
        )
        
        response = await self._send_request(list_tools_message)
        
        if response and response.result:
            tools_data = response.result.get("tools", [])
            for tool_data in tools_data:
                tool = MCPTool(
                    name=tool_data["name"],
                    description=tool_data["description"],
                    inputSchema=tool_data.get("inputSchema", {}),
                    outputSchema=tool_data.get("outputSchema")
                )
                self.available_tools[tool.name] = tool
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """è°ƒç”¨å·¥å…·"""
        
        if tool_name not in self.available_tools:
            raise ValueError(f"Tool {tool_name} not available")
        
        call_message = MCPMessage(
            id=self._generate_request_id(),
            method=MCPMessageType.CALL_TOOL.value,
            params={
                "name": tool_name,
                "arguments": arguments
            }
        )
        
        response = await self._send_request(call_message)
        
        if response.error:
            raise Exception(f"Tool call failed: {response.error}")
        
        return response.result
    
    async def _send_request(self, message: MCPMessage) -> MCPMessage:
        """å‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”"""
        
        if not self.connected or not self.websocket:
            raise ConnectionError("Not connected to MCP server")
        
        # åˆ›å»ºå“åº”Future
        response_future = asyncio.Future()
        self.pending_requests[message.id] = response_future
        
        # å‘é€æ¶ˆæ¯
        await self.websocket.send(json.dumps(message.__dict__))
        
        # ç­‰å¾…å“åº”
        try:
            response = await asyncio.wait_for(response_future, timeout=30.0)
            return response
        except asyncio.TimeoutError:
            if message.id in self.pending_requests:
                del self.pending_requests[message.id]
            raise TimeoutError(f"Request {message.id} timed out")
    
    async def _message_listener(self):
        """æ¶ˆæ¯ç›‘å¬å™¨"""
        
        try:
            async for message_data in self.websocket:
                try:
                    message_dict = json.loads(message_data)
                    
                    # å¤„ç†å“åº”æ¶ˆæ¯
                    if "id" in message_dict and message_dict["id"] in self.pending_requests:
                        response = MCPMessage(**message_dict)
                        future = self.pending_requests.pop(response.id)
                        future.set_result(response)
                    
                    # å¤„ç†é€šçŸ¥æ¶ˆæ¯
                    elif "method" in message_dict:
                        await self._handle_notification(MCPMessage(**message_dict))
                        
                except json.JSONDecodeError as e:
                    self.logger.error(f"Failed to parse MCP message: {e}")
                except Exception as e:
                    self.logger.error(f"Error processing MCP message: {e}")
                    
        except websockets.exceptions.ConnectionClosed:
            self.connected = False
            self.logger.info("MCP connection closed")
        except Exception as e:
            self.logger.error(f"MCP message listener error: {e}")
    
    def _generate_request_id(self) -> str:
        """ç”Ÿæˆè¯·æ±‚ID"""
        self.request_counter += 1
        return f"req_{self.request_counter}"
```

### å·¥å…·é€‚é…å™¨æ¨¡å¼

```python
class ToolAdapter:
    """å·¥å…·é€‚é…å™¨åŸºç±»"""
    
    def __init__(self, tool_config: Dict[str, Any]):
        self.config = tool_config
        self.tool_id = tool_config["id"]
        self.tool_name = tool_config["name"]
        
    async def adapt_input(self, raw_input: Any) -> Any:
        """é€‚é…è¾“å…¥æ ¼å¼"""
        raise NotImplementedError
    
    async def adapt_output(self, raw_output: Any) -> Any:
        """é€‚é…è¾“å‡ºæ ¼å¼"""
        raise NotImplementedError
    
    async def execute(self, adapted_input: Any) -> Any:
        """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
        raise NotImplementedError

class APIToolAdapter(ToolAdapter):
    """APIå·¥å…·é€‚é…å™¨"""
    
    def __init__(self, tool_config: Dict[str, Any]):
        super().__init__(tool_config)
        self.http_client = HttpClient()
        self.base_url = tool_config.get("base_url")
        self.headers = tool_config.get("headers", {})
        
    async def adapt_input(self, raw_input: Dict[str, Any]) -> Dict[str, Any]:
        """é€‚é…APIè¾“å…¥æ ¼å¼"""
        
        adapted_input = {
            "method": self.config.get("http_method", "POST"),
            "url": f"{self.base_url}{self.config.get('endpoint')}",
            "headers": {**self.headers, **raw_input.get("headers", {})},
            "timeout": raw_input.get("timeout", 30)
        }
        
        # å¤„ç†è¯·æ±‚ä½“
        if "data" in raw_input:
            if self.config.get("content_type") == "application/json":
                adapted_input["json"] = raw_input["data"]
            else:
                adapted_input["data"] = raw_input["data"]
        
        # å¤„ç†æŸ¥è¯¢å‚æ•°
        if "params" in raw_input:
            adapted_input["params"] = raw_input["params"]
        
        return adapted_input
    
    async def adapt_output(self, raw_output: Any) -> Dict[str, Any]:
        """é€‚é…APIè¾“å‡ºæ ¼å¼"""
        
        if hasattr(raw_output, 'json'):
            try:
                return {
                    "success": True,
                    "data": raw_output.json(),
                    "status_code": raw_output.status_code,
                    "headers": dict(raw_output.headers)
                }
            except ValueError:
                return {
                    "success": True,
                    "data": raw_output.text,
                    "status_code": raw_output.status_code,
                    "headers": dict(raw_output.headers)
                }
        else:
            return {
                "success": False,
                "error": str(raw_output),
                "status_code": None
            }
    
    async def execute(self, adapted_input: Dict[str, Any]) -> Any:
        """æ‰§è¡ŒAPIè°ƒç”¨"""
        
        try:
            response = await self.http_client.request(**adapted_input)
            return await self.adapt_output(response)
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "error_type": type(e).__name__
            }
```

## å¹¶å‘æ‰§è¡Œç®¡ç†

### å¹¶å‘æ‰§è¡Œæ§åˆ¶å™¨

```python
import asyncio
from asyncio import Semaphore, Queue
from typing import Dict, List, Any, Optional, Callable
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
import time

@dataclass
class ExecutionTask:
    """æ‰§è¡Œä»»åŠ¡"""
    task_id: str
    tool_name: str
    input_data: Any
    priority: int = 0
    timeout: float = 30.0
    retry_count: int = 0
    max_retries: int = 3
    callback: Optional[Callable] = None

@dataclass
class ExecutionResult:
    """æ‰§è¡Œç»“æœ"""
    task_id: str
    success: bool
    result: Any = None
    error: Optional[str] = None
    execution_time: float = 0.0
    retry_count: int = 0

class ConcurrentExecutionController:
    """å¹¶å‘æ‰§è¡Œæ§åˆ¶å™¨"""
    
    def __init__(self, max_concurrent_tasks: int = 10):
        self.max_concurrent_tasks = max_concurrent_tasks
        self.semaphore = Semaphore(max_concurrent_tasks)
        self.task_queue = Queue()
        self.active_tasks = {}
        self.completed_tasks = {}
        self.resource_locks = {}
        self.thread_pool = ThreadPoolExecutor(max_workers=max_concurrent_tasks)
        self.running = False
        
    async def start(self):
        """å¯åŠ¨æ‰§è¡Œæ§åˆ¶å™¨"""
        self.running = True
        # å¯åŠ¨ä»»åŠ¡è°ƒåº¦å™¨
        asyncio.create_task(self._task_scheduler())
        
    async def stop(self):
        """åœæ­¢æ‰§è¡Œæ§åˆ¶å™¨"""
        self.running = False
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        await self._wait_for_completion()
        self.thread_pool.shutdown(wait=True)
    
    async def submit_task(self, task: ExecutionTask) -> str:
        """æäº¤æ‰§è¡Œä»»åŠ¡"""
        await self.task_queue.put(task)
        return task.task_id
    
    async def submit_batch_tasks(self, tasks: List[ExecutionTask]) -> List[str]:
        """æ‰¹é‡æäº¤ä»»åŠ¡"""
        task_ids = []
        for task in tasks:
            await self.task_queue.put(task)
            task_ids.append(task.task_id)
        return task_ids
    
    async def _task_scheduler(self):
        """ä»»åŠ¡è°ƒåº¦å™¨"""
        
        while self.running:
            try:
                # ä»é˜Ÿåˆ—è·å–ä»»åŠ¡ï¼ˆéé˜»å¡ï¼‰
                try:
                    task = await asyncio.wait_for(
                        self.task_queue.get(), timeout=1.0
                    )
                    
                    # æ£€æŸ¥èµ„æºå¯ç”¨æ€§
                    if await self._can_execute_task(task):
                        # åˆ›å»ºæ‰§è¡Œä»»åŠ¡
                        execution_coroutine = self._execute_task_with_control(task)
                        asyncio.create_task(execution_coroutine)
                    else:
                        # èµ„æºä¸è¶³ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
                        await self.task_queue.put(task)
                        await asyncio.sleep(0.1)  # çŸ­æš‚ç­‰å¾…
                        
                except asyncio.TimeoutError:
                    continue  # é˜Ÿåˆ—ç©ºï¼Œç»§ç»­å¾ªç¯
                    
            except Exception as e:
                self.logger.error(f"Task scheduler error: {e}")
                await asyncio.sleep(1.0)
    
    async def _can_execute_task(self, task: ExecutionTask) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å¯ä»¥æ‰§è¡Œ"""
        
        # æ£€æŸ¥å¹¶å‘é™åˆ¶
        if len(self.active_tasks) >= self.max_concurrent_tasks:
            return False
        
        # æ£€æŸ¥èµ„æºé”
        resource_key = self._get_resource_key(task)
        if resource_key in self.resource_locks:
            return False
        
        return True
    
    async def _execute_task_with_control(self, task: ExecutionTask):
        """å¸¦æ§åˆ¶çš„ä»»åŠ¡æ‰§è¡Œ"""
        
        async with self.semaphore:
            # è·å–èµ„æºé”
            resource_key = self._get_resource_key(task)
            if resource_key:
                self.resource_locks[resource_key] = task.task_id
            
            try:
                # è®°å½•ä»»åŠ¡å¼€å§‹
                self.active_tasks[task.task_id] = task
                start_time = time.time()
                
                # æ‰§è¡Œä»»åŠ¡
                result = await self._execute_task(task)
                
                # è®¡ç®—æ‰§è¡Œæ—¶é—´
                execution_time = time.time() - start_time
                result.execution_time = execution_time
                
                # è®°å½•å®Œæˆçš„ä»»åŠ¡
                self.completed_tasks[task.task_id] = result
                
                # æ‰§è¡Œå›è°ƒ
                if task.callback:
                    try:
                        await task.callback(result)
                    except Exception as e:
                        self.logger.error(f"Task callback error: {e}")
                
            except Exception as e:
                # è®°å½•æ‰§è¡Œå¤±è´¥
                result = ExecutionResult(
                    task_id=task.task_id,
                    success=False,
                    error=str(e),
                    execution_time=time.time() - start_time
                )
                self.completed_tasks[task.task_id] = result
                
            finally:
                # æ¸…ç†èµ„æº
                if task.task_id in self.active_tasks:
                    del self.active_tasks[task.task_id]
                if resource_key in self.resource_locks:
                    del self.resource_locks[resource_key]
    
    async def _execute_task(self, task: ExecutionTask) -> ExecutionResult:
        """æ‰§è¡Œå•ä¸ªä»»åŠ¡"""
        
        for attempt in range(task.max_retries + 1):
            try:
                # è·å–å·¥å…·å®ä¾‹
                tool = await self._get_tool_instance(task.tool_name)
                
                if not tool:
                    return ExecutionResult(
                        task_id=task.task_id,
                        success=False,
                        error=f"Tool {task.tool_name} not found"
                    )
                
                # æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆå¸¦è¶…æ—¶ï¼‰
                result = await asyncio.wait_for(
                    tool.execute(task.input_data),
                    timeout=task.timeout
                )
                
                return ExecutionResult(
                    task_id=task.task_id,
                    success=True,
                    result=result,
                    retry_count=attempt
                )
                
            except asyncio.TimeoutError:
                if attempt < task.max_retries:
                    await asyncio.sleep(2 ** attempt)  # æŒ‡æ•°é€€é¿
                    continue
                return ExecutionResult(
                    task_id=task.task_id,
                    success=False,
                    error="Task execution timeout",
                    retry_count=attempt
                )
                
            except Exception as e:
                if attempt < task.max_retries:
                    await asyncio.sleep(2 ** attempt)
                    continue
                return ExecutionResult(
                    task_id=task.task_id,
                    success=False,
                    error=str(e),
                    retry_count=attempt
                )
    
    def _get_resource_key(self, task: ExecutionTask) -> Optional[str]:
        """è·å–èµ„æºé”®"""
        
        # å¯¹äºæŸäº›å·¥å…·ï¼Œå¯èƒ½éœ€è¦ç‹¬å è®¿é—®
        exclusive_tools = ["file_writer", "database_updater", "config_modifier"]
        
        if task.tool_name in exclusive_tools:
            return f"exclusive_{task.tool_name}"
        
        return None
    
    async def get_task_status(self, task_id: str) -> Optional[str]:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        
        if task_id in self.completed_tasks:
            return "completed"
        elif task_id in self.active_tasks:
            return "running"
        else:
            # æ£€æŸ¥æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­
            # æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œå®é™…ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„çŠ¶æ€è·Ÿè¸ª
            return "unknown"
    
    async def cancel_task(self, task_id: str) -> bool:
        """å–æ¶ˆä»»åŠ¡"""
        
        if task_id in self.active_tasks:
            # æ ‡è®°ä»»åŠ¡ä¸ºå–æ¶ˆçŠ¶æ€
            task = self.active_tasks[task_id]
            # å®é™…çš„å–æ¶ˆé€»è¾‘ä¼šæ›´å¤æ‚
            self.logger.info(f"Task {task_id} cancellation requested")
            return True
        
        return False
```

## å¼‚å¸¸å¤„ç†æœºåˆ¶

### å¼‚å¸¸å¤„ç†å’Œæ¢å¤ç³»ç»Ÿ

```python
from enum import Enum
from typing import Dict, List, Any, Optional, Callable
import traceback
import asyncio
from dataclasses import dataclass

class ExceptionSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class RecoveryStrategy(Enum):
    RETRY = "retry"
    FALLBACK = "fallback"
    SKIP = "skip"
    ABORT = "abort"
    MANUAL = "manual"

@dataclass
class ExceptionContext:
    """å¼‚å¸¸ä¸Šä¸‹æ–‡"""
    exception_id: str
    task_id: str
    tool_name: str
    exception_type: str
    exception_message: str
    stack_trace: str
    severity: ExceptionSeverity
    timestamp: float
    retry_count: int = 0
    recovery_attempts: List[str] = None

class ExceptionHandler:
    """å¼‚å¸¸å¤„ç†å™¨"""
    
    def __init__(self):
        self.exception_strategies = {}
        self.recovery_handlers = {}
        self.exception_history = []
        self.circuit_breakers = {}
        
        # æ³¨å†Œé»˜è®¤ç­–ç•¥
        self._register_default_strategies()
    
    def register_strategy(self, 
                         exception_type: str,
                         strategy: RecoveryStrategy,
                         handler: Callable):
        """æ³¨å†Œå¼‚å¸¸å¤„ç†ç­–ç•¥"""
        
        if exception_type not in self.exception_strategies:
            self.exception_strategies[exception_type] = []
        
        self.exception_strategies[exception_type].append({
            "strategy": strategy,
            "handler": handler
        })
    
    async def handle_exception(self, 
                             exception: Exception,
                             context: Dict[str, Any]) -> ExceptionContext:
        """å¤„ç†å¼‚å¸¸"""
        
        # åˆ›å»ºå¼‚å¸¸ä¸Šä¸‹æ–‡
        exception_context = ExceptionContext(
            exception_id=self._generate_exception_id(),
            task_id=context.get("task_id", "unknown"),
            tool_name=context.get("tool_name", "unknown"),
            exception_type=type(exception).__name__,
            exception_message=str(exception),
            stack_trace=traceback.format_exc(),
            severity=self._assess_severity(exception),
            timestamp=time.time(),
            retry_count=context.get("retry_count", 0)
        )
        
        # è®°å½•å¼‚å¸¸å†å²
        self.exception_history.append(exception_context)
        
        # æ£€æŸ¥æ–­è·¯å™¨çŠ¶æ€
        if self._should_trigger_circuit_breaker(exception_context):
            self._trigger_circuit_breaker(exception_context.tool_name)
        
        # æ‰§è¡Œæ¢å¤ç­–ç•¥
        await self._execute_recovery_strategy(exception_context)
        
        return exception_context
    
    def _register_default_strategies(self):
        """æ³¨å†Œé»˜è®¤å¼‚å¸¸å¤„ç†ç­–ç•¥"""
        
        # ç½‘ç»œå¼‚å¸¸ - é‡è¯•ç­–ç•¥
        self.register_strategy(
            "ConnectionError",
            RecoveryStrategy.RETRY,
            self._retry_with_backoff
        )
        
        self.register_strategy(
            "TimeoutError",
            RecoveryStrategy.RETRY,
            self._retry_with_backoff
        )
        
        # æƒé™å¼‚å¸¸ - å›é€€ç­–ç•¥
        self.register_strategy(
            "PermissionError",
            RecoveryStrategy.FALLBACK,
            self._use_fallback_tool
        )
        
        # æ•°æ®å¼‚å¸¸ - è·³è¿‡ç­–ç•¥
        self.register_strategy(
            "ValidationError",
            RecoveryStrategy.SKIP,
            self._skip_with_warning
        )
        
        # ä¸¥é‡å¼‚å¸¸ - ä¸­æ­¢ç­–ç•¥
        self.register_strategy(
            "CriticalSystemError",
            RecoveryStrategy.ABORT,
            self._abort_execution
        )
    
    async def _execute_recovery_strategy(self, context: ExceptionContext):
        """æ‰§è¡Œæ¢å¤ç­–ç•¥"""
        
        exception_type = context.exception_type
        strategies = self.exception_strategies.get(exception_type, [])
        
        if not strategies:
            # æ²¡æœ‰æ³¨å†Œç­–ç•¥ï¼Œä½¿ç”¨é»˜è®¤å¤„ç†
            await self._default_exception_handling(context)
            return
        
        # å°è¯•æ¯ç§ç­–ç•¥
        for strategy_config in strategies:
            try:
                strategy = strategy_config["strategy"]
                handler = strategy_config["handler"]
                
                success = await handler(context)
                
                if success:
                    self.logger.info(
                        f"Recovery successful using {strategy.value} for {context.exception_id}"
                    )
                    return
                    
            except Exception as e:
                self.logger.error(f"Recovery strategy failed: {e}")
                continue
        
        # æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥ï¼Œè®°å½•å¹¶ä¸ŠæŠ¥
        await self._escalate_exception(context)
    
    async def _retry_with_backoff(self, context: ExceptionContext) -> bool:
        """é‡è¯•ç­–ç•¥ï¼ˆå¸¦æŒ‡æ•°é€€é¿ï¼‰"""
        
        max_retries = 3
        if context.retry_count >= max_retries:
            return False
        
        # è®¡ç®—é€€é¿æ—¶é—´
        backoff_time = min(2 ** context.retry_count, 30)  # æœ€å¤§30ç§’
        
        self.logger.info(
            f"Retrying task {context.task_id} after {backoff_time}s "
            f"(attempt {context.retry_count + 1})"
        )
        
        await asyncio.sleep(backoff_time)
        
        # è¿™é‡Œåº”è¯¥é‡æ–°æäº¤ä»»åŠ¡åˆ°æ‰§è¡Œé˜Ÿåˆ—
        # å®é™…å®ç°ä¼šä¾èµ–äºå…·ä½“çš„ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ
        return True
    
    async def _use_fallback_tool(self, context: ExceptionContext) -> bool:
        """å›é€€å·¥å…·ç­–ç•¥"""
        
        # æŸ¥æ‰¾å›é€€å·¥å…·
        fallback_tool = await self._find_fallback_tool(context.tool_name)
        
        if fallback_tool:
            self.logger.info(
                f"Using fallback tool {fallback_tool} for {context.tool_name}"
            )
            # å®é™…å®ç°ä¸­ä¼šé‡æ–°æ‰§è¡Œä»»åŠ¡
            return True
        
        return False
    
    async def _skip_with_warning(self, context: ExceptionContext) -> bool:
        """è·³è¿‡ç­–ç•¥"""
        
        self.logger.warning(
            f"Skipping task {context.task_id} due to {context.exception_type}: "
            f"{context.exception_message}"
        )
        
        # æ ‡è®°ä»»åŠ¡ä¸ºè·³è¿‡çŠ¶æ€
        return True
    
    async def _abort_execution(self, context: ExceptionContext) -> bool:
        """ä¸­æ­¢æ‰§è¡Œç­–ç•¥"""
        
        self.logger.critical(
            f"Aborting execution due to critical error in task {context.task_id}: "
            f"{context.exception_message}"
        )
        
        # å‘é€ç´§æ€¥é€šçŸ¥
        await self._send_critical_alert(context)
        
        # ä¸­æ­¢ç›¸å…³çš„æ‰€æœ‰ä»»åŠ¡
        await self._abort_related_tasks(context)
        
        return True
    
    def _assess_severity(self, exception: Exception) -> ExceptionSeverity:
        """è¯„ä¼°å¼‚å¸¸ä¸¥é‡ç¨‹åº¦"""
        
        critical_exceptions = [
            "SystemExit", "KeyboardInterrupt", "MemoryError", "SystemError"
        ]
        high_exceptions = [
            "PermissionError", "SecurityError", "AuthenticationError"
        ]
        medium_exceptions = [
            "TimeoutError", "ConnectionError", "HTTPError"
        ]
        
        exception_type = type(exception).__name__
        
        if exception_type in critical_exceptions:
            return ExceptionSeverity.CRITICAL
        elif exception_type in high_exceptions:
            return ExceptionSeverity.HIGH
        elif exception_type in medium_exceptions:
            return ExceptionSeverity.MEDIUM
        else:
            return ExceptionSeverity.LOW
    
    def _should_trigger_circuit_breaker(self, context: ExceptionContext) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘æ–­è·¯å™¨"""
        
        tool_name = context.tool_name
        
        # ç»Ÿè®¡æœ€è¿‘çš„å¼‚å¸¸é¢‘ç‡
        recent_exceptions = [
            exc for exc in self.exception_history[-100:]  # æœ€è¿‘100ä¸ªå¼‚å¸¸
            if exc.tool_name == tool_name and 
               time.time() - exc.timestamp < 300  # 5åˆ†é’Ÿå†…
        ]
        
        # å¦‚æœ5åˆ†é’Ÿå†…å¼‚å¸¸è¶…è¿‡10æ¬¡ï¼Œè§¦å‘æ–­è·¯å™¨
        return len(recent_exceptions) > 10
    
    def _trigger_circuit_breaker(self, tool_name: str):
        """è§¦å‘æ–­è·¯å™¨"""
        
        self.circuit_breakers[tool_name] = {
            "opened_at": time.time(),
            "failure_count": self._get_recent_failure_count(tool_name),
            "state": "open"
        }
        
        self.logger.warning(f"Circuit breaker opened for tool {tool_name}")
```

## ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ

### ç»¼åˆç›‘æ§ç³»ç»Ÿ

```python
import asyncio
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import psutil
import time

@dataclass
class PerformanceMetrics:
    """æ€§èƒ½æŒ‡æ ‡"""
    timestamp: float
    cpu_usage: float
    memory_usage: float
    active_tasks: int
    completed_tasks: int
    failed_tasks: int
    average_execution_time: float
    throughput: float  # æ¯ç§’å¤„ç†ä»»åŠ¡æ•°

@dataclass
class ToolMetrics:
    """å·¥å…·æŒ‡æ ‡"""
    tool_name: str
    total_calls: int
    successful_calls: int
    failed_calls: int
    average_response_time: float
    min_response_time: float
    max_response_time: float
    last_call_time: float

class MonitoringSystem:
    """ç›‘æ§ç³»ç»Ÿ"""
    
    def __init__(self, metrics_retention_hours: int = 24):
        self.metrics_history = []
        self.tool_metrics = {}
        self.alerts = []
        self.metrics_retention = metrics_retention_hours
        self.monitoring_active = False
        self.metric_collectors = []
        
    async def start_monitoring(self):
        """å¯åŠ¨ç›‘æ§"""
        self.monitoring_active = True
        
        # å¯åŠ¨æŒ‡æ ‡æ”¶é›†ä»»åŠ¡
        asyncio.create_task(self._collect_metrics())
        asyncio.create_task(self._cleanup_old_metrics())
        asyncio.create_task(self._analyze_metrics())
    
    async def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.monitoring_active = False
    
    async def _collect_metrics(self):
        """æ”¶é›†æ€§èƒ½æŒ‡æ ‡"""
        
        while self.monitoring_active:
            try:
                # æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
                metrics = PerformanceMetrics(
                    timestamp=time.time(),
                    cpu_usage=psutil.cpu_percent(interval=1),
                    memory_usage=psutil.virtual_memory().percent,
                    active_tasks=self._get_active_task_count(),
                    completed_tasks=self._get_completed_task_count(),
                    failed_tasks=self._get_failed_task_count(),
                    average_execution_time=self._calculate_average_execution_time(),
                    throughput=self._calculate_throughput()
                )
                
                self.metrics_history.append(metrics)
                
                # æ£€æŸ¥å‘Šè­¦æ¡ä»¶
                await self._check_alert_conditions(metrics)
                
                await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ”¶é›†ä¸€æ¬¡
                
            except Exception as e:
                self.logger.error(f"Metrics collection error: {e}")
                await asyncio.sleep(60)
    
    async def _analyze_metrics(self):
        """åˆ†ææŒ‡æ ‡è¶‹åŠ¿"""
        
        while self.monitoring_active:
            try:
                if len(self.metrics_history) >= 10:  # è‡³å°‘10ä¸ªæ•°æ®ç‚¹
                    # åˆ†æCPUè¶‹åŠ¿
                    cpu_trend = self._analyze_cpu_trend()
                    if cpu_trend == "increasing":
                        await self._create_alert(
                            "HIGH_CPU_TREND",
                            "CPU usage showing increasing trend",
                            "warning"
                        )
                    
                    # åˆ†æå†…å­˜è¶‹åŠ¿
                    memory_trend = self._analyze_memory_trend()
                    if memory_trend == "increasing":
                        await self._create_alert(
                            "HIGH_MEMORY_TREND",
                            "Memory usage showing increasing trend",
                            "warning"
                        )
                    
                    # åˆ†æååé‡è¶‹åŠ¿
                    throughput_trend = self._analyze_throughput_trend()
                    if throughput_trend == "decreasing":
                        await self._create_alert(
                            "DECLINING_THROUGHPUT",
                            "System throughput is declining",
                            "warning"
                        )
                
                await asyncio.sleep(300)  # æ¯5åˆ†é’Ÿåˆ†æä¸€æ¬¡
                
            except Exception as e:
                self.logger.error(f"Metrics analysis error: {e}")
                await asyncio.sleep(300)
    
    def record_tool_execution(self, 
                            tool_name: str,
                            success: bool,
                            execution_time: float):
        """è®°å½•å·¥å…·æ‰§è¡ŒæŒ‡æ ‡"""
        
        if tool_name not in self.tool_metrics:
            self.tool_metrics[tool_name] = ToolMetrics(
                tool_name=tool_name,
                total_calls=0,
                successful_calls=0,
                failed_calls=0,
                average_response_time=0.0,
                min_response_time=float('inf'),
                max_response_time=0.0,
                last_call_time=time.time()
            )
        
        metrics = self.tool_metrics[tool_name]
        metrics.total_calls += 1
        metrics.last_call_time = time.time()
        
        if success:
            metrics.successful_calls += 1
        else:
            metrics.failed_calls += 1
        
        # æ›´æ–°å“åº”æ—¶é—´ç»Ÿè®¡
        metrics.min_response_time = min(metrics.min_response_time, execution_time)
        metrics.max_response_time = max(metrics.max_response_time, execution_time)
        
        # æ›´æ–°å¹³å‡å“åº”æ—¶é—´ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
        if metrics.total_calls == 1:
            metrics.average_response_time = execution_time
        else:
            # ä½¿ç”¨æŒ‡æ•°ç§»åŠ¨å¹³å‡
            alpha = 0.1  # å¹³æ»‘å› å­
            metrics.average_response_time = (
                alpha * execution_time + 
                (1 - alpha) * metrics.average_response_time
            )
    
    async def _check_alert_conditions(self, metrics: PerformanceMetrics):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        
        # CPUä½¿ç”¨ç‡å‘Šè­¦
        if metrics.cpu_usage > 80:
            await self._create_alert(
                "HIGH_CPU_USAGE",
                f"CPU usage: {metrics.cpu_usage:.1f}%",
                "warning" if metrics.cpu_usage < 90 else "critical"
            )
        
        # å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦
        if metrics.memory_usage > 85:
            await self._create_alert(
                "HIGH_MEMORY_USAGE", 
                f"Memory usage: {metrics.memory_usage:.1f}%",
                "warning" if metrics.memory_usage < 95 else "critical"
            )
        
        # ä»»åŠ¡å¤±è´¥ç‡å‘Šè­¦
        if metrics.failed_tasks > 0:
            failure_rate = metrics.failed_tasks / (metrics.completed_tasks + metrics.failed_tasks)
            if failure_rate > 0.1:  # 10%å¤±è´¥ç‡
                await self._create_alert(
                    "HIGH_FAILURE_RATE",
                    f"Task failure rate: {failure_rate:.1%}",
                    "warning" if failure_rate < 0.2 else "critical"
                )
        
        # ååé‡å‘Šè­¦
        if metrics.throughput < 1.0:  # æ¯ç§’å°‘äº1ä¸ªä»»åŠ¡
            await self._create_alert(
                "LOW_THROUGHPUT",
                f"Low system throughput: {metrics.throughput:.2f} tasks/sec",
                "warning"
            )
    
    async def _create_alert(self, alert_type: str, message: str, severity: str):
        """åˆ›å»ºå‘Šè­¦"""
        
        alert = {
            "type": alert_type,
            "message": message,
            "severity": severity,
            "timestamp": time.time(),
            "acknowledged": False
        }
        
        self.alerts.append(alert)
        
        # å‘é€å‘Šè­¦é€šçŸ¥
        await self._send_alert_notification(alert)
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """è·å–ä»ªè¡¨æ¿æ•°æ®"""
        
        if not self.metrics_history:
            return {"error": "No metrics available"}
        
        latest_metrics = self.metrics_history[-1]
        
        return {
            "system_status": {
                "cpu_usage": latest_metrics.cpu_usage,
                "memory_usage": latest_metrics.memory_usage,
                "active_tasks": latest_metrics.active_tasks,
                "throughput": latest_metrics.throughput
            },
            "tool_metrics": {
                name: asdict(metrics) 
                for name, metrics in self.tool_metrics.items()
            },
            "recent_alerts": [
                alert for alert in self.alerts[-10:]  # æœ€è¿‘10ä¸ªå‘Šè­¦
                if not alert["acknowledged"]
            ],
            "performance_trends": {
                "cpu_trend": self._get_recent_cpu_values(),
                "memory_trend": self._get_recent_memory_values(),
                "throughput_trend": self._get_recent_throughput_values()
            }
        }
```

## æœ¬èŠ‚æ€»ç»“

æœ¬èŠ‚æ·±å…¥ä»‹ç»äº†å·¥å…·æ‰©å±•è¿è¡Œå±‚çš„å·¥ç¨‹åŒ–å®è·µï¼š

### ğŸ¯ æ ¸å¿ƒå®ç°è¦ç‚¹
1. **æ ‡å‡†åŒ–é›†æˆ**ï¼šåŸºäºMCPåè®®çš„ç»Ÿä¸€å·¥å…·æ¥å£
2. **å¹¶å‘æ§åˆ¶**ï¼šä¿¡å·é‡ã€èµ„æºé”ã€ä»»åŠ¡é˜Ÿåˆ—çš„ååŒç®¡ç†
3. **å¼‚å¸¸å¤„ç†**ï¼šå¤šç­–ç•¥æ¢å¤å’Œæ–­è·¯å™¨ä¿æŠ¤æœºåˆ¶
4. **ç›‘æ§ä½“ç³»**ï¼šå…¨æ–¹ä½çš„æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ

### ğŸ”§ å…³é”®æŠ€æœ¯æ–¹æ¡ˆ
- MCPåè®®å®¢æˆ·ç«¯å’Œå·¥å…·é€‚é…å™¨çš„å®ç°
- åŸºäºä¿¡å·é‡å’Œèµ„æºé”çš„å¹¶å‘æ§åˆ¶ç®—æ³•
- å¤šå±‚æ¬¡å¼‚å¸¸å¤„ç†å’Œè‡ªåŠ¨æ¢å¤æœºåˆ¶
- å®æ—¶æ€§èƒ½ç›‘æ§å’Œè¶‹åŠ¿åˆ†æç³»ç»Ÿ

### ğŸš€ å·¥ç¨‹åŒ–ä»·å€¼
- **æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€çš„å·¥å…·æ¥å£æé«˜äº’æ“ä½œæ€§
- **é«˜å¹¶å‘**ï¼šå……åˆ†åˆ©ç”¨ç³»ç»Ÿèµ„æºæå‡å¤„ç†èƒ½åŠ›
- **é«˜å¯é **ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†ç¡®ä¿ç³»ç»Ÿç¨³å®š
- **å¯è§‚æµ‹**ï¼šå…¨é¢çš„ç›‘æ§ä¸ºè¿ç»´æä¾›æ•°æ®æ”¯æ’‘

---

**ä¸‹ä¸€æ­¥å­¦ä¹ **ï¼šæŒæ¡äº†åŸºæœ¬çš„å·¥ç¨‹åŒ–å®è·µåï¼Œæˆ‘ä»¬å°†åœ¨4.3.6èŠ‚å­¦ä¹ æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§çš„æ·±å…¥å†…å®¹ï¼Œäº†è§£å¦‚ä½•è¿›ä¸€æ­¥æå‡ç³»ç»Ÿæ€§èƒ½å’Œè¿ç»´æ•ˆç‡ã€‚

> **ğŸ’¡ å®è·µå»ºè®®**ï¼šå·¥ç¨‹åŒ–å®è·µçš„å…³é”®åœ¨äºå¾ªåºæ¸è¿›ï¼Œå»ºè®®å…ˆåœ¨å°è§„æ¨¡ç¯å¢ƒä¸­éªŒè¯å„ä¸ªç»„ä»¶ï¼Œç„¶åé€æ­¥æ‰©å±•åˆ°ç”Ÿäº§ç¯å¢ƒï¼Œå¹¶æŒç»­ä¼˜åŒ–å„é¡¹æŒ‡æ ‡ã€‚
